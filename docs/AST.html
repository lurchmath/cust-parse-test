<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>Customizable Parsing Test Repository: AST</title>
    
      <link type="text/css" rel="stylesheet" href="styles/vendor/prism-default.css">
    
    <link type="text/css" rel="stylesheet" href="styles/styles.css">
    
    
    <style>
      :root {
      
      
        --nav-width: 335px;
      
      }
    </style>
    

<script>
    MathJax = { tex: { inlineMath: [['$', '$'], ['\\(', '\\)']] } };
</script>
<script id="MathJax-script" async
        src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js">
</script>
</head>
<body>

<header class="layout-header">
  
  <h1>
    <a href="./index.html">
      Customizable Parsing Test Repository
    </a>
  </h1>
  <nav class="layout-nav">
    <ul><li class="nav-heading">Tutorials</li><li class="nav-item"><a href="tutorial-Test Results.html">Test Results</a></li></ul><ul><li class="nav-heading">Classes</li><li class="nav-heading"><span class="nav-item-type type-class" title="class">C</span><span class="nav-item-name is-class"><a href="AST.html">AST</a></span></li><li class="nav-item"><span class="nav-item-type type-function" title="function">F</span><span class="nav-item-name is-function"><a href="AST.html#.fromJSON">fromJSON</a></span></li><li class="nav-item"><span class="nav-item-type type-function" title="function">F</span><span class="nav-item-name is-function"><a href="AST.html#arg">arg</a></span></li><li class="nav-item"><span class="nav-item-type type-function" title="function">F</span><span class="nav-item-name is-function"><a href="AST.html#args">args</a></span></li><li class="nav-item"><span class="nav-item-type type-function" title="function">F</span><span class="nav-item-name is-function"><a href="AST.html#concept">concept</a></span></li><li class="nav-item"><span class="nav-item-type type-function" title="function">F</span><span class="nav-item-name is-function"><a href="AST.html#head">head</a></span></li><li class="nav-item"><span class="nav-item-type type-function" title="function">F</span><span class="nav-item-name is-function"><a href="AST.html#isCompound">isCompound</a></span></li><li class="nav-item"><span class="nav-item-type type-function" title="function">F</span><span class="nav-item-name is-function"><a href="AST.html#isConcept">isConcept</a></span></li><li class="nav-item"><span class="nav-item-type type-function" title="function">F</span><span class="nav-item-name is-function"><a href="AST.html#isLeaf">isLeaf</a></span></li><li class="nav-item"><span class="nav-item-type type-function" title="function">F</span><span class="nav-item-name is-function"><a href="AST.html#numArgs">numArgs</a></span></li><li class="nav-item"><span class="nav-item-type type-function" title="function">F</span><span class="nav-item-name is-function"><a href="AST.html#toJSON">toJSON</a></span></li><li class="nav-item"><span class="nav-item-type type-function" title="function">F</span><span class="nav-item-name is-function"><a href="AST.html#toLanguage">toLanguage</a></span></li><li class="nav-item"><span class="nav-item-type type-function" title="function">F</span><span class="nav-item-name is-function"><a href="AST.html#toString">toString</a></span></li><li class="nav-heading"><span class="nav-item-type type-class" title="class">C</span><span class="nav-item-name is-class"><a href="Converter.html">Converter</a></span></li><li class="nav-item"><span class="nav-item-type type-function" title="function">F</span><span class="nav-item-name is-function"><a href="Converter.html#addBuiltIns">addBuiltIns</a></span></li><li class="nav-item"><span class="nav-item-type type-function" title="function">F</span><span class="nav-item-name is-function"><a href="Converter.html#addConcept">addConcept</a></span></li><li class="nav-item"><span class="nav-item-type type-function" title="function">F</span><span class="nav-item-name is-function"><a href="Converter.html#concept">concept</a></span></li><li class="nav-item"><span class="nav-item-type type-function" title="function">F</span><span class="nav-item-name is-function"><a href="Converter.html#convert">convert</a></span></li><li class="nav-item"><span class="nav-item-type type-function" title="function">F</span><span class="nav-item-name is-function"><a href="Converter.html#isConcept">isConcept</a></span></li><li class="nav-item"><span class="nav-item-type type-function" title="function">F</span><span class="nav-item-name is-function"><a href="Converter.html#isLanguage">isLanguage</a></span></li><li class="nav-item"><span class="nav-item-type type-function" title="function">F</span><span class="nav-item-name is-function"><a href="Converter.html#language">language</a></span></li><li class="nav-heading"><span class="nav-item-type type-class" title="class">C</span><span class="nav-item-name is-class"><a href="Language.html">Language</a></span></li><li class="nav-item"><span class="nav-item-type type-member" title="member">M</span><span class="nav-item-name is-member"><a href="Language.html#regularExpressions">regularExpressions</a></span></li><li class="nav-item"><span class="nav-item-type type-function" title="function">F</span><span class="nav-item-name is-function"><a href="Language.html#.fromJSON">fromJSON</a></span></li><li class="nav-item"><span class="nav-item-type type-function" title="function">F</span><span class="nav-item-name is-function"><a href="Language.html#addNotation">addNotation</a></span></li><li class="nav-item"><span class="nav-item-type type-function" title="function">F</span><span class="nav-item-name is-function"><a href="Language.html#convertTo">convertTo</a></span></li><li class="nav-item"><span class="nav-item-type type-function" title="function">F</span><span class="nav-item-name is-function"><a href="Language.html#parse">parse</a></span></li><li class="nav-item"><span class="nav-item-type type-function" title="function">F</span><span class="nav-item-name is-function"><a href="Language.html#rulesFor">rulesFor</a></span></li></ul><ul><li class="nav-heading">Modules</li><li class="nav-heading"><span class="nav-item-type type-module" title="module">M</span><span class="nav-item-name is-module"><a href="module-SyntacticTypes.html">SyntacticTypes</a></span></li><li class="nav-item"><span class="nav-item-type type-member" title="member">M</span><span class="nav-item-name is-member"><a href="module-SyntacticTypes.html#.hierarchies">hierarchies</a></span></li><li class="nav-item"><span class="nav-item-type type-member" title="member">M</span><span class="nav-item-name is-member"><a href="module-SyntacticTypes.html#.isAtomic">isAtomic</a></span></li><li class="nav-item"><span class="nav-item-type type-member" title="member">M</span><span class="nav-item-name is-member"><a href="module-SyntacticTypes.html#.isSupertype">isSupertype</a></span></li><li class="nav-item"><span class="nav-item-type type-member" title="member">M</span><span class="nav-item-name is-member"><a href="module-SyntacticTypes.html#.isSupertypeOrEqual">isSupertypeOrEqual</a></span></li><li class="nav-item"><span class="nav-item-type type-member" title="member">M</span><span class="nav-item-name is-member"><a href="module-SyntacticTypes.html#.lowestSubtype">lowestSubtype</a></span></li><li class="nav-item"><span class="nav-item-type type-member" title="member">M</span><span class="nav-item-name is-member"><a href="module-SyntacticTypes.html#.types">types</a></span></li></ul><li class="nav-heading"><a href="global.html">Globals</a></li><li class="nav-item"><span class="nav-item-type type-member" title="member">M</span><span class="nav-item-name is-member"><a href="global.html#escapeRegExp">escapeRegExp</a></span></li><li class="nav-item"><span class="nav-item-type type-member" title="member">M</span><span class="nav-item-name is-member"><a href="global.html#notationStringToArray">notationStringToArray</a></span></li><li class="nav-item"><span class="nav-item-type type-member" title="member">M</span><span class="nav-item-name is-member"><a href="global.html#putdownLeaves">putdownLeaves</a></span></li>
  </nav>
</header>


<main class="layout-main ">
  <div class="container">
    <p class="page-kind">Class</p>
    <h1 class="page-title">AST</h1>
    




<section>


<header class="class">


    
        
        <!-- <h2>AST</h2> -->

        

        

        
            
            <div class="class-description"><p>An abstract syntax tree (AST) is a data structure typically created by
parsing text using a grammar.  We create this class for that purpose.  It has
the following attributes:</p>
<ul>
<li>Its contents, which may be a string to indicate that this AST is a leaf
of the tree, or it may be an array of other ASTs, which would be the
operator and operands, in that order.</li>
<li>The <a href="Language.html">Language</a> from which it was parsed.</li>
</ul>
<p>Any AST object then has methods for workflows that involve parsing,
representing, and classifying.</p></div>
        
    
</header>

<article>
    <div class="container-overview">



    
        





    


    
    <h3 class="subtitle">Constructor</h3>
    

    <div class="method-type">
    
    </div>

    <h4 class="method-name" id="AST">new AST<span class="signature">(language, contents)</span><span class="return-type-signature"></span>
    </h4>





<div class="method-description">
    
    <p>Construct a new AST from two ingredients, the <a href="Language.html">Language</a> from which
it was parsed, and its contents (which can be a string if this AST is a
leaf, or an array of ASTs otherwise).  Also, the second parameter can be
a JSON structure of nested arrays and strings, which will be recursively
passed to AST constructors to convert it to an AST.</p>
<p>Note that constructing an AST from a JSON structure takes it as given,
and does not alter it.  To construct an AST that performs changes based
on associativity of concepts, see <a href="AST.html#.fromJSON">fromJSON()</a>.</p>
<p>In an AST, every head (i.e., operator) must be a leaf AST.  Even if, for
example, you plan to use ASTs to represent function application, you must
use a leaf AST to represent the idea of function application.  Thus, for
example, &quot;f composed with g, applied to x&quot; should not be represented as
the structure
<code>[ [ 'compose', 'f', 'g' ], 'x' ]</code>, but rather as the structure
<code>[ 'apply', [ 'compose', 'f', 'g' ], 'x' ]</code>.</p>
</div>









    <h4 class="method-heading">Parameters</h4>
    

<ul class="method-params">
    

        <li>
            
                <span class="param-name">language</span>
            

            
                


    <span class="param-type">
        <code><a href="Language.html">Language</a></code>
    </span>
    

            

            

            

            <div class="param-description"><p>the language from which this AST was parsed</p></div>
            
        </li>

    

        <li>
            
                <span class="param-name">contents</span>
            

            
                


    <span class="param-type">
        <code>String</code>
    </span>
    |

    <span class="param-type">
        <code>Array</code>
    </span>
    

            

            

            

            <div class="param-description"><p>see explanation above</p></div>
            
        </li>

    
</ul>





<div class="details">
    

    

    

    

    

    

    

    

    

    

    

    

    

    
        <h4 class="method-heading">See</h4>
        <ul>
            
                <li><a href="AST.html#.fromJSON">fromJSON()</a></li>
            
        </ul>
    

    
</div>


















    <h4 class="method-heading">Source</h4>
    <ul>
        <li class="method-source">
            <a href="ast.js.html">ast.js</a><a href="ast.js.html#source.18">, line 18</a>
        </li>
    </ul>



    
    </div>

    

    
        <h3 class="subsection-title">Classes</h3>

        <dl>
            <dt><a href="AST.html">AST</a></dt>
            <dd></dd>
        </dl>
    

     

    

    


    

    
        <h3 class="subtitle">Methods</h3>

        
            


    <article class="method">




    


    

    <div class="method-type">
    <span class="method-type-signature is-static">static</span>
    </div>

    <h4 class="method-name" id=".fromJSON">fromJSON<span class="signature">(language, json, top<span class="signature-attributes">nullable</span>)</span><span class="return-type-signature"> &rarr; {<a href="AST.html">AST</a>}</span>
    </h4>





<div class="method-description">
    
    <p>The <a href="Language.html">Language</a> class can parse text into hierarchies of JavaScript
arrays.  Those arrays sometimes contain unnecessary information about the
details of the parsing.  For instance, if <code>x*y</code> were the notation for
multiplication in some language, then that <a href="Language.html">Language</a> class's
<a href="Language.html#parse">parsing function</a> would return an array with
contents something like <code>['multiplication','x','*','y']</code>.  In other
words, all tokens that were parsed become part of the parsing result,
even though one of them is redundant now that the semantic type (in this
example <code>&quot;multiplication&quot;</code>) has been added.</p>
<p>This function not only converts such an array into an AST instance, but
also removes the unnecessary tokens (the <code>'*'</code> entry in the example
above), since the meaning is clear from the first element of the array,
the name of the semantic type parsed from the <code>'*'</code> infix operator.</p>
<p>This function also flattens any nested ASTs for concepts that are
classified as associative.  For example, if the JSON representation of
the AST were <code>['addition','x',['addition','y','z']]</code>, and the concept of
addition were marked associative (in the <a href="Converter.html">Converter</a>'s list of
concepts), then this function will not create a nested tree imitating
that JSON, but will create one isomorphic to <code>['addition','x','y','z']</code>
instead.  (Note that associativity is actually a predicate about each
operator separately, but a binary relation between the outer and inner
operators, so this example is a special case.)</p>
</div>









    <h4 class="method-heading">Parameters</h4>
    

<ul class="method-params">
    

        <li>
            
                <span class="param-name">language</span>
            

            
                


    <span class="param-type">
        <code><a href="Language.html">Language</a></code>
    </span>
    

            

            
                <span class="param-attributes">
                

                

                
                </span>
            

            
                
            

            <div class="param-description"><p>the language from which the JSON was parsed,
and which should be used when constructing the AST</p></div>
            
        </li>

    

        <li>
            
                <span class="param-name">json</span>
            

            
                


    <span class="param-type">
        <code>Array</code>
    </span>
    

            

            
                <span class="param-attributes">
                

                

                
                </span>
            

            
                
            

            <div class="param-description"><p>a hierarchy of JavaScript Arrays (with strings as
leaves) representing an AST</p></div>
            
        </li>

    

        <li>
            
                <span class="param-name">top</span>
            

            
                


    <span class="param-type">
        <code>boolean</code>
    </span>
    

            

            
                <span class="param-attributes">
                

                
                    &lt;nullable&gt;<br>
                

                
                </span>
            

            
                
                    <span class="param-default">
                        true
                    </span>
                
            

            <div class="param-description"><p><code>true</code> if this is the top-level call, for internal
use only; clients should omit this parameter</p></div>
            
        </li>

    
</ul>





<div class="details">
    

    

    

    

    

    

    

    

    

    

    

    

    

    

    
</div>



    <h4 class="method-heading">Returns</h4>
    <ul>
    
        <li class="method-returns">
            
                <code>AST</code>
            
            
                <p>the AST represented by the JSON</p>
            
        </li>
    
    </ul>
















    <h4 class="method-heading">Source</h4>
    <ul>
        <li class="method-source">
            <a href="ast.js.html">ast.js</a><a href="ast.js.html#source.256">, line 256</a>
        </li>
    </ul>



    </article>

        
            


    <article class="method">




    


    

    <div class="method-type">
    
    </div>

    <h4 class="method-name" id="arg">arg<span class="signature">(index)</span><span class="return-type-signature"> &rarr; {<a href="AST.html">AST</a>}</span>
    </h4>





<div class="method-description">
    
    <p>A non-leaf AST has a nonempty array of children, beginning with the
operator of the AST, often called its head, followed by the operands.
This function returns the operand at the given index, where the first
operand after the head has index 0, and the last operand has index
<code>this.numArgs() - 1</code>.  If this AST is a leaf, this function returns
undefined.</p>
</div>









    <h4 class="method-heading">Parameters</h4>
    

<ul class="method-params">
    

        <li>
            
                <span class="param-name">index</span>
            

            
                


    <span class="param-type">
        <code>number</code>
    </span>
    

            

            

            

            <div class="param-description"><p>the index of the operand to return</p></div>
            
        </li>

    
</ul>





<div class="details">
    

    

    

    

    

    

    

    

    

    

    

    

    

    
        <h4 class="method-heading">See</h4>
        <ul>
            
                <li><a href="AST.html#args">args()</a></li>
            
                <li><a href="AST.html#numArgs">numArgs()</a></li>
            
        </ul>
    

    
</div>



    <h4 class="method-heading">Returns</h4>
    <ul>
    
        <li class="method-returns">
            
                <code>AST</code>
            
            
                <p>the operand at the given index</p>
            
        </li>
    
    </ul>
















    <h4 class="method-heading">Source</h4>
    <ul>
        <li class="method-source">
            <a href="ast.js.html">ast.js</a><a href="ast.js.html#source.129">, line 129</a>
        </li>
    </ul>



    </article>

        
            


    <article class="method">




    


    

    <div class="method-type">
    
    </div>

    <h4 class="method-name" id="args">args<span class="signature">()</span><span class="return-type-signature"> &rarr; {<a href="AST.html">AST</a>}</span>
    </h4>





<div class="method-description">
    
    <p>A non-leaf AST has a nonempty array of children, beginning with the
operator of the AST, often called its head.  This function returns the
rest of that list, the operands, as a JavaScript array (not an AST).  If
this AST is a leaf, this function returns undefined.</p>
</div>













<div class="details">
    

    

    

    

    

    

    

    

    

    

    

    

    

    
        <h4 class="method-heading">See</h4>
        <ul>
            
                <li><a href="AST.html#head">head()</a></li>
            
        </ul>
    

    
</div>



    <h4 class="method-heading">Returns</h4>
    <ul>
    
        <li class="method-returns">
            
                <code>AST</code>
            
            
                <p>the operands of this AST</p>
            
        </li>
    
    </ul>
















    <h4 class="method-heading">Source</h4>
    <ul>
        <li class="method-source">
            <a href="ast.js.html">ast.js</a><a href="ast.js.html#source.102">, line 102</a>
        </li>
    </ul>



    </article>

        
            


    <article class="method">




    


    

    <div class="method-type">
    
    </div>

    <h4 class="method-name" id="concept">concept<span class="signature">()</span><span class="return-type-signature"> &rarr; {Object}</span>
    </h4>





<div class="method-description">
    
    <p>The <a href="module-SyntacticTypes.html">SyntacticTypes module</a> defines a set of
syntactic types common to mathematical notation.  Each <a href="Converter.html">Converter</a>
instance can define a set of semantic types to add to the set of
syntactic types.  Those semantic types are called <em>concepts.</em>  An AST can
represent a concept in either of two ways, as documented in the
<a href="AST.html#isConcept">isConcept()</a> method.</p>
<p>When an AST represents a concept, this function returns that concept as
an object with the following properties.</p>
<ul>
<li><code>parentType</code>, the name of the parent syntactic type</li>
<li><code>putdown</code>, the putdown representation of the concept (for example, it
might be <code>(+ summand summand)</code> for the concept <code>addition</code>)</li>
<li><code>typeSequence</code>, an array of the syntactic types of each of the
arguments extracted from the putdown notation (for example, it would
be <code>[&quot;summand&quot;,&quot;summand&quot;]</code> in the example above)</li>
</ul>
</div>













<div class="details">
    

    

    

    

    

    

    

    

    

    

    

    

    

    

    
</div>



    <h4 class="method-heading">Returns</h4>
    <ul>
    
        <li class="method-returns">
            
                <code>Object</code>
            
            
                <p>the data about the concept represented in this AST</p>
            
        </li>
    
    </ul>
















    <h4 class="method-heading">Source</h4>
    <ul>
        <li class="method-source">
            <a href="ast.js.html">ast.js</a><a href="ast.js.html#source.186">, line 186</a>
        </li>
    </ul>



    </article>

        
            


    <article class="method">




    


    

    <div class="method-type">
    
    </div>

    <h4 class="method-name" id="head">head<span class="signature">()</span><span class="return-type-signature"> &rarr; {<a href="AST.html">AST</a>}</span>
    </h4>





<div class="method-description">
    
    <p>A non-leaf AST has a nonempty array of children, beginning with the
operator of the AST, often called its head.  This function returns that
entry.  (It does not shift the head off the array, but only returns it,
leaving the AST unaltered.)  If this AST is a leaf, this function
returns undefined.</p>
</div>













<div class="details">
    

    

    

    

    

    

    

    

    

    

    

    

    

    
        <h4 class="method-heading">See</h4>
        <ul>
            
                <li><a href="AST.html#args">args()</a></li>
            
        </ul>
    

    
</div>



    <h4 class="method-heading">Returns</h4>
    <ul>
    
        <li class="method-returns">
            
                <code>AST</code>
            
            
                <p>the operator of this AST, if one exists</p>
            
        </li>
    
    </ul>
















    <h4 class="method-heading">Source</h4>
    <ul>
        <li class="method-source">
            <a href="ast.js.html">ast.js</a><a href="ast.js.html#source.91">, line 91</a>
        </li>
    </ul>



    </article>

        
            


    <article class="method">




    


    

    <div class="method-type">
    
    </div>

    <h4 class="method-name" id="isCompound">isCompound<span class="signature">()</span><span class="return-type-signature"> &rarr; {boolean}</span>
    </h4>





<div class="method-description">
    
    <p>An AST may be a leaf or it may have subtrees, that is to say, it may be
<em>compound.</em>  This function detects which is the case, and returns true
iff this AST is compound.</p>
</div>













<div class="details">
    

    

    

    

    

    

    

    

    

    

    

    

    

    
        <h4 class="method-heading">See</h4>
        <ul>
            
                <li><a href="AST.html#isLeaf">isLeaf()</a></li>
            
        </ul>
    

    
</div>



    <h4 class="method-heading">Returns</h4>
    <ul>
    
        <li class="method-returns">
            
                <code>boolean</code>
            
            
                <p>whether this AST is a non-leaf (i.e., is compound)</p>
            
        </li>
    
    </ul>
















    <h4 class="method-heading">Source</h4>
    <ul>
        <li class="method-source">
            <a href="ast.js.html">ast.js</a><a href="ast.js.html#source.68">, line 68</a>
        </li>
    </ul>



    </article>

        
            


    <article class="method">




    


    

    <div class="method-type">
    
    </div>

    <h4 class="method-name" id="isConcept">isConcept<span class="signature">()</span><span class="return-type-signature"> &rarr; {boolean}</span>
    </h4>





<div class="method-description">
    
    <p>The <a href="module-SyntacticTypes.html">SyntacticTypes module</a> defines a set of
syntactic types common to mathematical notation.  Each <a href="Converter.html">Converter</a>
instance can define a set of semantic types to add to the set of
syntactic types.  Those semantic types are called <em>concepts.</em>  This
function asks whether this AST represents a concept.  This can happen in
two ways.</p>
<ul>
<li>First, if this AST is <a href="AST.html#isCompound">compound</a>, then its
<a href="AST.html#head">head</a> may represent a concept.  Consider two examples:
<ul>
<li>If the operator were the leaf <code>&quot;expression&quot;</code>, that would indicate
that this AST represents an instance of the syntactic type
<code>&quot;expression&quot;</code>, and this AST would not be a concept, and this
function would return false.</li>
<li>If this AST were for a <a href="Language.html">Language</a> whose <a href="Converter.html">Converter</a>
defined the concept <code>&quot;factorial&quot;</code> to be a specific type of
expression, and this AST began with the operator <code>&quot;factorial&quot;</code>,
then this function would return true, because this AST is not an
instance of a syntactic type (expression), but an instance of a
semantic type (factorial).</li>
</ul>
</li>
<li>Second, if this AST is a <a href="AST.html#isLeaf">leaf</a>, then its contents
(as a string) may represent a concept.  For example, if this AST were
for a <a href="Language.html">Language</a> whose <a href="Converter.html">Converter</a> defined the constant
<code>&quot;pi&quot;</code> as a concept, and this AST is a leaf containing just the string
<code>&quot;pi&quot;</code>, then this function would return true.</li>
</ul>
</div>













<div class="details">
    

    

    

    

    

    

    

    

    

    

    

    

    

    
        <h4 class="method-heading">See</h4>
        <ul>
            
                <li><a href="Converter.html#isConcept">isConcept()</a></li>
            
                <li><a href="AST.html#concept">concept()</a></li>
            
        </ul>
    

    
</div>



    <h4 class="method-heading">Returns</h4>
    <ul>
    
        <li class="method-returns">
            
                <code>boolean</code>
            
            
                <p><code>true</code> if this AST represents a concept</p>
            
        </li>
    
    </ul>
















    <h4 class="method-heading">Source</h4>
    <ul>
        <li class="method-source">
            <a href="ast.js.html">ast.js</a><a href="ast.js.html#source.161">, line 161</a>
        </li>
    </ul>



    </article>

        
            


    <article class="method">




    


    

    <div class="method-type">
    
    </div>

    <h4 class="method-name" id="isLeaf">isLeaf<span class="signature">()</span><span class="return-type-signature"> &rarr; {boolean}</span>
    </h4>





<div class="method-description">
    
    <p>An AST may be a leaf or it may have subtrees.  This function detects
which is the case, and returns true iff this AST is a leaf.  This is
equivalent to <code>!this.isCompound()</code>, and is therefore just a convenience
function.</p>
</div>













<div class="details">
    

    

    

    

    

    

    

    

    

    

    

    

    

    
        <h4 class="method-heading">See</h4>
        <ul>
            
                <li><a href="AST.html#isCompound">isCompound()</a></li>
            
        </ul>
    

    
</div>



    <h4 class="method-heading">Returns</h4>
    <ul>
    
        <li class="method-returns">
            
                <code>boolean</code>
            
            
                <p>whether this AST is a leaf</p>
            
        </li>
    
    </ul>
















    <h4 class="method-heading">Source</h4>
    <ul>
        <li class="method-source">
            <a href="ast.js.html">ast.js</a><a href="ast.js.html#source.79">, line 79</a>
        </li>
    </ul>



    </article>

        
            


    <article class="method">




    


    

    <div class="method-type">
    
    </div>

    <h4 class="method-name" id="numArgs">numArgs<span class="signature">()</span><span class="return-type-signature"> &rarr; {number}</span>
    </h4>





<div class="method-description">
    
    <p>A non-leaf AST has a nonempty array of children, beginning with the
operator of the AST, often called its head, followed by the operands.
This function returns the number of operands (which is one less than the
length of the array).  If this AST is a leaf, this function returns
undefined.</p>
</div>













<div class="details">
    

    

    

    

    

    

    

    

    

    

    

    

    

    
        <h4 class="method-heading">See</h4>
        <ul>
            
                <li><a href="AST.html#args">args()</a></li>
            
        </ul>
    

    
</div>



    <h4 class="method-heading">Returns</h4>
    <ul>
    
        <li class="method-returns">
            
                <code>number</code>
            
            
                <p>the number of operands</p>
            
        </li>
    
    </ul>
















    <h4 class="method-heading">Source</h4>
    <ul>
        <li class="method-source">
            <a href="ast.js.html">ast.js</a><a href="ast.js.html#source.114">, line 114</a>
        </li>
    </ul>



    </article>

        
            


    <article class="method">




    


    

    <div class="method-type">
    
    </div>

    <h4 class="method-name" id="toJSON">toJSON<span class="signature">()</span><span class="return-type-signature"> &rarr; {Array|String}</span>
    </h4>





<div class="method-description">
    
    <p>Converts this AST into a nested hierarchy of JavaScript arrays, which is
isomorphic to the AST hierarchy itself, but without any of the data or
features provided by the AST class.  For example, the <a href="AST.html#isCompound">compound</a> AST whose <a href="AST.html#toString">string representation</a> is <code>addition(x,multiplication(y,z))</code> would have the JSON
form <code>[ 'addition', 'x', [ 'multiplication', 'y', 'z' ] ]</code>.  But a leaf
AST has its string contents as its JSON form (i.e., it is not an array).</p>
</div>













<div class="details">
    

    

    

    

    

    

    

    

    

    

    

    

    

    
        <h4 class="method-heading">See</h4>
        <ul>
            
                <li><a href="AST.html#.fromJSON">fromJSON()</a></li>
            
                <li><a href="AST.html#toString">toString()</a></li>
            
        </ul>
    

    
</div>



    <h4 class="method-heading">Returns</h4>
    <ul>
    
        <li class="method-returns">
            
                <code>Array</code>
            
                <code>String</code>
            
            
                <p>a JSON representation of this AST</p>
            
        </li>
    
    </ul>
















    <h4 class="method-heading">Source</h4>
    <ul>
        <li class="method-source">
            <a href="ast.js.html">ast.js</a><a href="ast.js.html#source.218">, line 218</a>
        </li>
    </ul>



    </article>

        
            


    <article class="method">




    


    

    <div class="method-type">
    
    </div>

    <h4 class="method-name" id="toLanguage">toLanguage<span class="signature">(language)</span><span class="return-type-signature"> &rarr; {String}</span>
    </h4>





<div class="method-description">
    
    <p>Represent this AST in the given language.  For example, if the AST were
one whose <a href="AST.html#toString">string representation</a> were
<code>addition(x,y)</code>, then we might call <code>.toLanguage(latex)</code> on that
AST and expect to get <code>x+y</code>, or we might call <code>.toLanguage(putdown)</code> and
expect to get <code>(+ x y)</code>.  The parameter passed to <code>toLanguage()</code> must be
a <a href="Language.html">Language</a> that shares the same <a href="Converter.html">Converter</a> instance as
this AST's language.</p>
<p>This function requires the AST on which it is called to be in compact
form, as produced by the compact() member function.
The behavior of this function is undefined if this requirement is not
met.</p>
</div>









    <h4 class="method-heading">Parameters</h4>
    

<ul class="method-params">
    

        <li>
            
                <span class="param-name">language</span>
            

            
                


    <span class="param-type">
        <code><a href="Language.html">Language</a></code>
    </span>
    

            

            

            

            <div class="param-description"><p>the language in which to write the
expression stored in this AST</p></div>
            
        </li>

    
</ul>





<div class="details">
    

    

    

    

    

    

    

    

    

    

    

    

    

    

    
</div>



    <h4 class="method-heading">Returns</h4>
    <ul>
    
        <li class="method-returns">
            
                <code>String</code>
            
            
                <p>the representation, in the specified language, of this
AST</p>
            
        </li>
    
    </ul>
















    <h4 class="method-heading">Source</h4>
    <ul>
        <li class="method-source">
            <a href="ast.js.html">ast.js</a><a href="ast.js.html#source.418">, line 418</a>
        </li>
    </ul>



    </article>

        
            


    <article class="method">




    


    

    <div class="method-type">
    
    </div>

    <h4 class="method-name" id="toString">toString<span class="signature">()</span><span class="return-type-signature"> &rarr; {String}</span>
    </h4>





<div class="method-description">
    
    <p>A simple string representation of this AST, useful for debugging.  For
example, if this AST represented the addition of x and the product of y
and z, the representation might be <code>addition(x,multiplication(y,z))</code>.</p>
</div>













<div class="details">
    

    

    

    

    

    

    

    

    

    

    

    

    

    

    
</div>



    <h4 class="method-heading">Returns</h4>
    <ul>
    
        <li class="method-returns">
            
                <code>String</code>
            
            
                <p>a simple string representation of this AST</p>
            
        </li>
    
    </ul>
















    <h4 class="method-heading">Source</h4>
    <ul>
        <li class="method-source">
            <a href="ast.js.html">ast.js</a><a href="ast.js.html#source.198">, line 198</a>
        </li>
    </ul>



    </article>

        
    

    

    
</article>

</section>




  </div>
</main>

<footer class="layout-footer">
  <div class="container">
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.6.11</a>
  </div>
</footer>



<script src="scripts/prism.dev.js"></script>
</body>
</html>