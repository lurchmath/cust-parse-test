<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>Customizable Parsing Test Repository: Converter</title>
    
      <link type="text/css" rel="stylesheet" href="styles/vendor/prism-default.css">
    
    <link type="text/css" rel="stylesheet" href="styles/styles.css">
    
    
    <style>
      :root {
      
      
        --nav-width: 335px;
      
      }
    </style>
    

<script>
    MathJax = { tex: { inlineMath: [['$', '$'], ['\\(', '\\)']] } };
</script>
<script id="MathJax-script" async
        src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js">
</script>
</head>
<body>

<header class="layout-header">
  
  <h1>
    <a href="./index.html">
      Customizable Parsing Test Repository
    </a>
  </h1>
  <nav class="layout-nav">
    <ul><li class="nav-heading">Tutorials</li><li class="nav-item"><a href="tutorial-Test Results.html">Test Results</a></li></ul><ul><li class="nav-heading">Classes</li><li class="nav-heading"><span class="nav-item-type type-class" title="class">C</span><span class="nav-item-name is-class"><a href="AST.html">AST</a></span></li><li class="nav-item"><span class="nav-item-type type-function" title="function">F</span><span class="nav-item-name is-function"><a href="AST.html#.fromJSON">fromJSON</a></span></li><li class="nav-item"><span class="nav-item-type type-function" title="function">F</span><span class="nav-item-name is-function"><a href="AST.html#arg">arg</a></span></li><li class="nav-item"><span class="nav-item-type type-function" title="function">F</span><span class="nav-item-name is-function"><a href="AST.html#args">args</a></span></li><li class="nav-item"><span class="nav-item-type type-function" title="function">F</span><span class="nav-item-name is-function"><a href="AST.html#concept">concept</a></span></li><li class="nav-item"><span class="nav-item-type type-function" title="function">F</span><span class="nav-item-name is-function"><a href="AST.html#head">head</a></span></li><li class="nav-item"><span class="nav-item-type type-function" title="function">F</span><span class="nav-item-name is-function"><a href="AST.html#isCompound">isCompound</a></span></li><li class="nav-item"><span class="nav-item-type type-function" title="function">F</span><span class="nav-item-name is-function"><a href="AST.html#isConcept">isConcept</a></span></li><li class="nav-item"><span class="nav-item-type type-function" title="function">F</span><span class="nav-item-name is-function"><a href="AST.html#isLeaf">isLeaf</a></span></li><li class="nav-item"><span class="nav-item-type type-function" title="function">F</span><span class="nav-item-name is-function"><a href="AST.html#numArgs">numArgs</a></span></li><li class="nav-item"><span class="nav-item-type type-function" title="function">F</span><span class="nav-item-name is-function"><a href="AST.html#toJSON">toJSON</a></span></li><li class="nav-item"><span class="nav-item-type type-function" title="function">F</span><span class="nav-item-name is-function"><a href="AST.html#toLanguage">toLanguage</a></span></li><li class="nav-item"><span class="nav-item-type type-function" title="function">F</span><span class="nav-item-name is-function"><a href="AST.html#toString">toString</a></span></li><li class="nav-heading"><span class="nav-item-type type-class" title="class">C</span><span class="nav-item-name is-class"><a href="Converter.html">Converter</a></span></li><li class="nav-item"><span class="nav-item-type type-function" title="function">F</span><span class="nav-item-name is-function"><a href="Converter.html#addConcept">addConcept</a></span></li><li class="nav-item"><span class="nav-item-type type-function" title="function">F</span><span class="nav-item-name is-function"><a href="Converter.html#concept">concept</a></span></li><li class="nav-item"><span class="nav-item-type type-function" title="function">F</span><span class="nav-item-name is-function"><a href="Converter.html#convert">convert</a></span></li><li class="nav-item"><span class="nav-item-type type-function" title="function">F</span><span class="nav-item-name is-function"><a href="Converter.html#isConcept">isConcept</a></span></li><li class="nav-item"><span class="nav-item-type type-function" title="function">F</span><span class="nav-item-name is-function"><a href="Converter.html#isLanguage">isLanguage</a></span></li><li class="nav-item"><span class="nav-item-type type-function" title="function">F</span><span class="nav-item-name is-function"><a href="Converter.html#language">language</a></span></li><li class="nav-heading"><span class="nav-item-type type-class" title="class">C</span><span class="nav-item-name is-class"><a href="Language.html">Language</a></span></li><li class="nav-item"><span class="nav-item-type type-member" title="member">M</span><span class="nav-item-name is-member"><a href="Language.html#regularExpressions">regularExpressions</a></span></li><li class="nav-item"><span class="nav-item-type type-function" title="function">F</span><span class="nav-item-name is-function"><a href="Language.html#addNotation">addNotation</a></span></li><li class="nav-item"><span class="nav-item-type type-function" title="function">F</span><span class="nav-item-name is-function"><a href="Language.html#convertTo">convertTo</a></span></li><li class="nav-item"><span class="nav-item-type type-function" title="function">F</span><span class="nav-item-name is-function"><a href="Language.html#parse">parse</a></span></li><li class="nav-item"><span class="nav-item-type type-function" title="function">F</span><span class="nav-item-name is-function"><a href="Language.html#rulesFor">rulesFor</a></span></li></ul><ul><li class="nav-heading">Modules</li><li class="nav-heading"><span class="nav-item-type type-module" title="module">M</span><span class="nav-item-name is-module"><a href="module-SyntacticTypes.html">SyntacticTypes</a></span></li><li class="nav-item"><span class="nav-item-type type-member" title="member">M</span><span class="nav-item-name is-member"><a href="module-SyntacticTypes.html#.hierarchies">hierarchies</a></span></li><li class="nav-item"><span class="nav-item-type type-member" title="member">M</span><span class="nav-item-name is-member"><a href="module-SyntacticTypes.html#.isAtomic">isAtomic</a></span></li><li class="nav-item"><span class="nav-item-type type-member" title="member">M</span><span class="nav-item-name is-member"><a href="module-SyntacticTypes.html#.isSupertype">isSupertype</a></span></li><li class="nav-item"><span class="nav-item-type type-member" title="member">M</span><span class="nav-item-name is-member"><a href="module-SyntacticTypes.html#.isSupertypeOrEqual">isSupertypeOrEqual</a></span></li><li class="nav-item"><span class="nav-item-type type-member" title="member">M</span><span class="nav-item-name is-member"><a href="module-SyntacticTypes.html#.lowestSubtype">lowestSubtype</a></span></li><li class="nav-item"><span class="nav-item-type type-member" title="member">M</span><span class="nav-item-name is-member"><a href="module-SyntacticTypes.html#.types">types</a></span></li></ul><li class="nav-heading"><a href="global.html">Globals</a></li><li class="nav-item"><span class="nav-item-type type-member" title="member">M</span><span class="nav-item-name is-member"><a href="global.html#escapeRegExp">escapeRegExp</a></span></li><li class="nav-item"><span class="nav-item-type type-member" title="member">M</span><span class="nav-item-name is-member"><a href="global.html#notationStringToArray">notationStringToArray</a></span></li><li class="nav-item"><span class="nav-item-type type-member" title="member">M</span><span class="nav-item-name is-member"><a href="global.html#putdownLeaves">putdownLeaves</a></span></li>
  </nav>
</header>


<main class="layout-main ">
  <div class="container">
    <p class="page-kind">Class</p>
    <h1 class="page-title">Converter</h1>
    




<section>


<header class="class">


    
        
        <!-- <h2>Converter</h2> -->

        

        

        
            
            <div class="class-description"><h2>Class overview</h2>
<p>A converter is an object in which you can define mathematical languages with
greater ease than defining a grammar from scratch, because a lot of the work
is already built into the class.  After defining one or more languages, you
can use the class to convert between any two of the languages, or between any
one of the languages and an <a href="AST.html">abstract syntax tree</a> representing the
meaning of the expression that was parsed.</p>
<p>The workflow for using the class is as follows.</p>
<ul>
<li>Construct one using the constructor.  Doing
so automatically installs in the converter a language named &quot;putdown&quot;.</li>
<li>Add any other languages you want by calling the <a href="Language.html">Language</a>
constructor.  (You almost certainly want to add at least one language,
because otherwise you can parse only putdown, which is not interesting.)</li>
<li>Add all concepts that you want your language(s) to be able to represent by
making repeated calls to <a href="Converter.html#addConcept">addConcept()</a>.  (See
below for detailed explanation of concepts.)</li>
<li>For each concept you add, specify how it is written in each of the
language(s) you added, with calls to <a href="Language.html#addNotation">addNotation()</a>.</li>
<li>Convert between any two languages using the
<a href="Converter.html#convert">convert()</a> function.</li>
</ul>
<h2>Core definitions</h2>
<p><strong>Using this class requires understanding the distinction among syntactic
types, primitive concepts, and derived concepts.</strong>  We explain these here.  A
key distinction in the definitions below is whether a concept has an assigned
meaning.  The Converter class (and all other classes in this repository)
single out the putdown language as the one in which meaning will be
represented, and thus any concept with an assigned putdown notation has a
meaning, and any concept without an assigned putdown notation has no meaning.
As you read the definitions below, you will need to remember that &quot;having a
meaning&quot; is synonymous with &quot;having an assigned putdown form.&quot;</p>
<ul>
<li><strong>Syntactic types are those that have no meaning.</strong>  They exist to provide
a skeleton that represents the relationships among the most common
mathematical notations, so that defining a new language can just put flesh
onto this skeleton and not have to start from scratch.  For example, all
common mathematical notations expect <code>1+2*3</code> to be interpreted with the
<code>2*3</code> taking precedence and sitting inside the <code>1+...</code>.  For more details
on syntactic types, see the <a href="module-SyntacticTypes.html">SyntacticTypes module</a>.  The other two categories below have assigned meanings, and thus
are disjoint from the syntactic types; we call those two categories
together the <em>semantic</em> types, or for short, <em>concepts.</em>  They come in two
types, <em>primitive</em> and <em>derived,</em> which we will explain now.</li>
<li><strong>A <em>primitive concept</em> is one whose putdown meaning introduces a new
operator specifically for that concept.</strong>  For example, if one of the
concepts in our language were addition, and we expressed it in putdown as
<code>(+ arg1 arg2)</code>, where <code>+</code> had not been used before, then addition is a
primitive concept.  Other concepts later may choose to represent
themselves in terms of addition (for example, perhaps subtraction will be
represented as <code>(+ arg1 (- arg2))</code>, where unary negation is another
primitive concept distinct from subtraction).  But subtraction could also
be its own primitive concept if its putdown form were specified as
<code>(- arg1 arg2)</code>, for example.</li>
<li><strong>A <em>derived concept</em> is one whose putdown meaning uses the operators
introduced by earlier primitive concepts.</strong>  In the previous bullet point,
we saw an example of how one could introduce subtraction in such a way.
Here we provide two additional examples for why this feature can be
useful.
<ul>
<li>Imagine you are creating a Converter that will translate among three
languages, putdown and two others, called A and B.  Now imagine that
both A and B allow you to use the symbols <code>*</code> and <code>x</code> to both mean
multiplication.  When translating <code>7*4</code> from A to B, we want the result
to use the <code>*</code> operator, but when translating <code>7x4</code> from A to B, we
want the result to use the <code>x</code> operator, even though the meanings are
the same.  When translating either one into putdown, we want it to use
the one, unique putdown operator that means multiplication (perhaps it
is <code>(mul 7 4)</code>, as an example).  To solve this problem, create one
primitive concept, <code>multiplication</code>, whose putdown form is
<code>(* arg1 arg2)</code>.  Then create one derived concept, <code>x-multiplication</code>,
whose putdown form is the same.  Now when defining languages A and B,
the notation <code>7*4</code> can map to the multiplication concept, while the
notation <code>7x4</code> can map to the x-multiplication concept.  When
translating between A and B, those concepts will mediate correct
conversion of notation, but when translating to putdown, to compute the
meaning of either expression, both will render as <code>(mul 7 4)</code>.  Note
that derived concepts will never be the target of a translation that
comes <em>out of</em> putdown, and thus if you ask the Converter to translate
<code>(mul 7 4)</code> into language A or B, it will always use the <code>*</code> operator,
because that is the primitive concept associated with the <code>mul</code>
operator.</li>
<li>Imagine you are creating a Converter that will translate LaTeX to and
from putdown.  You want <code>x\in A</code> to mean <code>(in x A)</code> in putdown, but you
do not want a separate operator for <code>x\notin A</code>.  Instead, you want
that notation to be shorthand for the internal meaning
<code>(not (in x A))</code>.  To solve this, make a primitive <code>setmembership</code>
concept whose putdown meaning is <code>(in arg1 arg2)</code>, and assign the
<code>x\in A</code> notation to map to that concept.  Then create a derived
<code>notsetmembership</code> concept whose putdown meaning is
<code>(not (in arg1 arg2))</code>, and assign the <code>x\notin A</code> notation to map to
that concept.  As in the previous example, if you have the expression
<code>(not (in x A))</code> in putdown and ask the Converter to translate to
LaTeX, because <code>notsetmembership</code> is a derived concept, it will not be
used for parsing putdown.  That is, the expanded form <code>(not (in x A))</code>
will not be collapsed back into the notation <code>x\notin A</code>, but rather
the expanded form (which you can view as a canonical form) will be
preserved in the conversion to LaTeX, presumably as something like
<code>\neg(x\in A)</code>, depending on the LaTeX notation you have specified for
negation and grouping symbols.</li>
</ul>
</li>
</ul>
<p>Syntactic types are fixed, defined in the <a href="module-SyntacticTypes.html">SyntacticTypes module</a>, and are not designed to be altered by clients of this
class.  All semantic types (both primitive and derived concepts) are
completely up to the user of this class to introduce, including which
concepts to introduce, what notation to use for each, and thus which ones are
primitive vs. derived.  Each instance of this class is a separate semantic
universe, in the sense that you can create one Converter instance and add to
it one set of concepts, then create another Converter instance and add to it
a completely different set of concepts.  The two instances will not share
concepts, but they will both share the same underlying set of syntactic
types.</p></div>
        
    
</header>

<article>
    <div class="container-overview">



    
        





    


    
    <h3 class="subtitle">Constructor</h3>
    

    <div class="method-type">
    
    </div>

    <h4 class="method-name" id="Converter">new Converter<span class="signature">()</span><span class="return-type-signature"></span>
    </h4>





<div class="method-description">
    
    <p>Creates a new converter.  No arguments are required.  To customize the
converter to your needs, refer to the documentation <a href="Converter.html">at the top of the class</a>, which lists a workflow for how you should call the
other functions in this class to set an instance up for your needs.</p>
</div>













<div class="details">
    

    

    

    

    

    

    

    

    

    

    

    

    

    

    
</div>


















    <h4 class="method-heading">Source</h4>
    <ul>
        <li class="method-source">
            <a href="converter.js.html">converter.js</a><a href="converter.js.html#source.124">, line 124</a>
        </li>
    </ul>



    
    </div>

    

    
        <h3 class="subsection-title">Classes</h3>

        <dl>
            <dt><a href="Converter.html">Converter</a></dt>
            <dd></dd>
        </dl>
    

     

    

    


    

    
        <h3 class="subtitle">Methods</h3>

        
            


    <article class="method">




    


    

    <div class="method-type">
    
    </div>

    <h4 class="method-name" id="addConcept">addConcept<span class="signature">(name, parentType, putdown, options<span class="signature-attributes">nullable</span>)</span><span class="return-type-signature"></span>
    </h4>





<div class="method-description">
    
    <p>The <a href="module-SyntacticTypes.html">SyntacticTypes module</a> defines a set of
types called &quot;syntactic types&quot; (explained in greater detail in that
module) that make it easier to define a language.  Converter instances
define their own set of &quot;semantic types&quot; that sit within the hierarchy
established by those syntactic types.  Such &quot;semantic types&quot; are called
&quot;concepts&quot; and you add them to a converter using this function.</p>
<p>The most complex parameter here is the third one, which specifies the
putdown notation for the concept.  This can be one of two things:</p>
<ul>
<li>If it is a regular expression, it will be used during tokenization, to
find portions of input in this language that represent this concept.
For example, if you want your language to include integers, you might
call this function, passing the word &quot;integer&quot; as the concept name,
&quot;atomicnumber&quot; as the parent type, and a regular expression like
<code>/-?[0-9]+/</code> as the putdown notation.  This not only makes that
regular expression the putdown notation, but it also makes it the
default notation for all future languages added to this converter.
Clients can override that default with later calls to
<a href="Language.html#addNotation">addNotation()</a>.</li>
<li>If it is a string, it should be appropriate putdown code for an
application or binding, and its leaves may include any syntactic or
semantic type name, to restrict parsing appropriately.  For example,
if you want your language to include addition of integers, you might
call this function, passing the word &quot;intsum&quot; as the concept name,
&quot;sum&quot; as the parent type, and the putdown notation
<code>&quot;(+ integer integer)&quot;</code>.</li>
<li>If you omit the third argument, the concept name is used as the
default putdown notation.  This is useful in some cases, such as
<code>addConcept('infinity','number')</code>, which will make the default putdown
notation just the word &quot;infinity&quot;.</li>
</ul>
<p>Note that this function does not allow you to specify how the concept is
written in any language other than putdown.  To do so, you must make
calls to <a href="Language.html#addNotation">addNotation()</a>.</p>
<p>The final parameter is an options object, which supports the following
fields.</p>
<ul>
<li><code>primitive</code> - this allows you to specify whether this concept is a
primitive concept (the default) or a derived concept (by setting the
option to <code>false</code>).  See the documentation for this class for an
overview of primitive vs. derived concepts.  The final parameter is
ignored in the case where <code>putdown</code> is a regular expression, because
such a value makes sense only if the concept is primitive.</li>
<li><code>associative</code> - this allows you to specify whether this concept
functions as an associative operator, in the sense that nested copies
of it should be flattened out into a single copy with more arguments.
The default is that the concept is not associative, which will cause
most operators to associate to the right, so that, for example,
<code>A -&gt; B -&gt; C</code> is stored internally as <code>A -&gt; (B -&gt; C)</code>.  You can change
this behavior by setting the option to a list of other concepts that,
if they show up as children of this one, will be flattened into this
one.  For example, for a concept &quot;add&quot; you might use <code>[&quot;add&quot;]</code> to say
that it only flattens into itself.  But if you have multiple ways to
add numbers, you can add all the concepts to the list.  You typically
want to do this in the definitions for all of those concepts, forming
an equivalence class, so all will merge with one another in any order
in which they might be nested.</li>
</ul>
</div>









    <h4 class="method-heading">Parameters</h4>
    

<ul class="method-params">
    

        <li>
            
                <span class="param-name">name</span>
            

            
                


    <span class="param-type">
        <code>String</code>
    </span>
    

            

            
                <span class="param-attributes">
                

                

                
                </span>
            

            

            <div class="param-description"><p>the name of the concept to add</p></div>
            
        </li>

    

        <li>
            
                <span class="param-name">parentType</span>
            

            
                


    <span class="param-type">
        <code>String</code>
    </span>
    

            

            
                <span class="param-attributes">
                

                

                
                </span>
            

            

            <div class="param-description"><p>the name of the parent type, which must be a
<a href="module-SyntacticTypes.html">syntactic type</a></p></div>
            
        </li>

    

        <li>
            
                <span class="param-name">putdown</span>
            

            
                


    <span class="param-type">
        <code>String</code>
    </span>
    |

    <span class="param-type">
        <code>RegExp</code>
    </span>
    

            

            
                <span class="param-attributes">
                

                

                
                </span>
            

            

            <div class="param-description"><p>the notation for this concept in the
putdown language</p></div>
            
        </li>

    

        <li>
            
                <span class="param-name">options</span>
            

            
                


    <span class="param-type">
        <code>Object</code>
    </span>
    

            

            
                <span class="param-attributes">
                

                
                    &lt;nullable&gt;<br>
                

                
                </span>
            

            

            <div class="param-description"><p>see supported fields above</p></div>
            
        </li>

    
</ul>





<div class="details">
    

    

    

    

    

    

    

    

    

    

    

    

    

    

    
</div>


















    <h4 class="method-heading">Source</h4>
    <ul>
        <li class="method-source">
            <a href="converter.js.html">converter.js</a><a href="converter.js.html#source.238">, line 238</a>
        </li>
    </ul>



    </article>

        
            


    <article class="method">




    


    

    <div class="method-type">
    
    </div>

    <h4 class="method-name" id="concept">concept<span class="signature">(name)</span><span class="return-type-signature"> &rarr; {Object}</span>
    </h4>





<div class="method-description">
    
    <p>Returns the concept with the given name, if any.  Concepts are added by
calls to <a href="Converter.html#addConcept">addConcept()</a>.</p>
</div>









    <h4 class="method-heading">Parameters</h4>
    

<ul class="method-params">
    

        <li>
            
                <span class="param-name">name</span>
            

            
                


    <span class="param-type">
        <code>String</code>
    </span>
    

            

            

            

            <div class="param-description"><p>the name of the concept to retrieve</p></div>
            
        </li>

    
</ul>





<div class="details">
    

    

    

    

    

    

    

    

    

    

    

    

    

    
        <h4 class="method-heading">See</h4>
        <ul>
            
                <li><a href="Converter.html#addConcept">addConcept()</a></li>
            
                <li><a href="Converter.html#isConcept">isConcept()</a></li>
            
        </ul>
    

    
</div>



    <h4 class="method-heading">Returns</h4>
    <ul>
    
        <li class="method-returns">
            
                <code>Object</code>
            
            
                <p>the concept with the given name</p>
            
        </li>
    
    </ul>
















    <h4 class="method-heading">Source</h4>
    <ul>
        <li class="method-source">
            <a href="converter.js.html">converter.js</a><a href="converter.js.html#source.296">, line 296</a>
        </li>
    </ul>



    </article>

        
            


    <article class="method">




    


    

    <div class="method-type">
    
    </div>

    <h4 class="method-name" id="convert">convert<span class="signature">(sourceLang, destLang, text)</span><span class="return-type-signature"> &rarr; {String}</span>
    </h4>





<div class="method-description">
    
    <p>Use this converter to convert text in any language it knows into text in
any of the other languages it knows.  For example,
<code>converter.convert( 'putdown', 'latex', input )</code> parses the given input
as putdown notation and returns LaTeX (assuming that you have defined a
LaTeX language in this converter; you can use any language you have
defined in place of LaTeX).  Similarly, you can convert into putdown from
LaTeX, or between two non-putdown languages.</p>
</div>









    <h4 class="method-heading">Parameters</h4>
    

<ul class="method-params">
    

        <li>
            
                <span class="param-name">sourceLang</span>
            

            
                


    <span class="param-type">
        <code>String</code>
    </span>
    

            

            

            

            <div class="param-description"><p>the name of the language in which the input
is expressed</p></div>
            
        </li>

    

        <li>
            
                <span class="param-name">destLang</span>
            

            
                


    <span class="param-type">
        <code>String</code>
    </span>
    

            

            

            

            <div class="param-description"><p>the name of the language into which to convert
the input</p></div>
            
        </li>

    

        <li>
            
                <span class="param-name">text</span>
            

            
                


    <span class="param-type">
        <code>String</code>
    </span>
    

            

            

            

            <div class="param-description"><p>the input to be converter</p></div>
            
        </li>

    
</ul>





<div class="details">
    

    

    

    

    

    

    

    

    

    

    

    

    

    
        <h4 class="method-heading">See</h4>
        <ul>
            
                <li><a href="Language.html#convertTo">convertTo()</a></li>
            
        </ul>
    

    
</div>



    <h4 class="method-heading">Returns</h4>
    <ul>
    
        <li class="method-returns">
            
                <code>String</code>
            
            
                <p>the converted output</p>
            
        </li>
    
    </ul>
















    <h4 class="method-heading">Source</h4>
    <ul>
        <li class="method-source">
            <a href="converter.js.html">converter.js</a><a href="converter.js.html#source.317">, line 317</a>
        </li>
    </ul>



    </article>

        
            


    <article class="method">




    


    

    <div class="method-type">
    
    </div>

    <h4 class="method-name" id="isConcept">isConcept<span class="signature">(name)</span><span class="return-type-signature"> &rarr; {boolean}</span>
    </h4>





<div class="method-description">
    
    <p>Does this converter know a concept with the given name?</p>
</div>









    <h4 class="method-heading">Parameters</h4>
    

<ul class="method-params">
    

        <li>
            
                <span class="param-name">name</span>
            

            
                


    <span class="param-type">
        <code>String</code>
    </span>
    

            

            

            

            <div class="param-description"><p>the name of the concept to check</p></div>
            
        </li>

    
</ul>





<div class="details">
    

    

    

    

    

    

    

    

    

    

    

    

    

    
        <h4 class="method-heading">See</h4>
        <ul>
            
                <li><a href="Converter.html#addConcept">addConcept()</a></li>
            
                <li><a href="Converter.html#concept">concept()</a></li>
            
        </ul>
    

    
</div>



    <h4 class="method-heading">Returns</h4>
    <ul>
    
        <li class="method-returns">
            
                <code>boolean</code>
            
            
                <p>whether a concept with that name has been added to
this converter</p>
            
        </li>
    
    </ul>
















    <h4 class="method-heading">Source</h4>
    <ul>
        <li class="method-source">
            <a href="converter.js.html">converter.js</a><a href="converter.js.html#source.283">, line 283</a>
        </li>
    </ul>



    </article>

        
            


    <article class="method">




    


    

    <div class="method-type">
    
    </div>

    <h4 class="method-name" id="isLanguage">isLanguage<span class="signature">(name)</span><span class="return-type-signature"> &rarr; {boolean}</span>
    </h4>





<div class="method-description">
    
    <p>Does this converter have a language of the given name?</p>
</div>









    <h4 class="method-heading">Parameters</h4>
    

<ul class="method-params">
    

        <li>
            
                <span class="param-name">name</span>
            

            
                


    <span class="param-type">
        <code>String</code>
    </span>
    

            

            

            

            <div class="param-description"><p>the name of the language to check</p></div>
            
        </li>

    
</ul>





<div class="details">
    

    

    

    

    

    

    

    

    

    

    

    

    

    
        <h4 class="method-heading">See</h4>
        <ul>
            
                <li><a href="Language.html">Language</a></li>
            
                <li><a href="Converter.html#language">language</a></li>
            
        </ul>
    

    
</div>



    <h4 class="method-heading">Returns</h4>
    <ul>
    
        <li class="method-returns">
            
                <code>boolean</code>
            
            
                <p>whether a language with that name has been added to
this converter</p>
            
        </li>
    
    </ul>
















    <h4 class="method-heading">Source</h4>
    <ul>
        <li class="method-source">
            <a href="converter.js.html">converter.js</a><a href="converter.js.html#source.153">, line 153</a>
        </li>
    </ul>



    </article>

        
            


    <article class="method">




    


    

    <div class="method-type">
    
    </div>

    <h4 class="method-name" id="language">language<span class="signature">(name)</span><span class="return-type-signature"> &rarr; {<a href="Language.html">Language</a>}</span>
    </h4>





<div class="method-description">
    
    <p>Returns the language with the given name, if any.  Languages are added by
calls to the <a href="Language.html">Language</a> constructor.</p>
</div>









    <h4 class="method-heading">Parameters</h4>
    

<ul class="method-params">
    

        <li>
            
                <span class="param-name">name</span>
            

            
                


    <span class="param-type">
        <code>String</code>
    </span>
    

            

            

            

            <div class="param-description"><p>the name of the language to retrieve</p></div>
            
        </li>

    
</ul>





<div class="details">
    

    

    

    

    

    

    

    

    

    

    

    

    

    
        <h4 class="method-heading">See</h4>
        <ul>
            
                <li><a href="Language.html">Language</a></li>
            
                <li><a href="Converter.html#isLanguage">isLanguage()</a></li>
            
        </ul>
    

    
</div>



    <h4 class="method-heading">Returns</h4>
    <ul>
    
        <li class="method-returns">
            
                <code>Language</code>
            
            
                <p>the language with the given name</p>
            
        </li>
    
    </ul>
















    <h4 class="method-heading">Source</h4>
    <ul>
        <li class="method-source">
            <a href="converter.js.html">converter.js</a><a href="converter.js.html#source.166">, line 166</a>
        </li>
    </ul>



    </article>

        
    

    

    
</article>

</section>




  </div>
</main>

<footer class="layout-footer">
  <div class="container">
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.6.11</a>
  </div>
</footer>



<script src="scripts/prism.dev.js"></script>
</body>
</html>