<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>Customizable Parsing Test Repository: Tutorial: Test Results</title>
    
      <link type="text/css" rel="stylesheet" href="styles/vendor/prism-default.css">
    
    <link type="text/css" rel="stylesheet" href="styles/styles.css">
    
    
    <style>
      :root {
      
      
        --nav-width: 335px;
      
      }
    </style>
    

<script>
    MathJax = { tex: { inlineMath: [['$', '$'], ['\\(', '\\)']] } };
</script>
<script id="MathJax-script" async
        src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js">
</script>
</head>
<body>

<header class="layout-header">
  
  <h1>
    <a href="./index.html">
      Customizable Parsing Test Repository
    </a>
  </h1>
  <nav class="layout-nav">
    <ul><li class="nav-heading">Tutorials</li><li class="nav-item"><a href="tutorial-Test Results.html">Test Results</a></li></ul><ul><li class="nav-heading">Classes</li><li class="nav-heading"><span class="nav-item-type type-class" title="class">C</span><span class="nav-item-name is-class"><a href="AST.html">AST</a></span></li><li class="nav-item"><span class="nav-item-type type-function" title="function">F</span><span class="nav-item-name is-function"><a href="AST.html#.fromJSON">fromJSON</a></span></li><li class="nav-item"><span class="nav-item-type type-function" title="function">F</span><span class="nav-item-name is-function"><a href="AST.html#arg">arg</a></span></li><li class="nav-item"><span class="nav-item-type type-function" title="function">F</span><span class="nav-item-name is-function"><a href="AST.html#args">args</a></span></li><li class="nav-item"><span class="nav-item-type type-function" title="function">F</span><span class="nav-item-name is-function"><a href="AST.html#concept">concept</a></span></li><li class="nav-item"><span class="nav-item-type type-function" title="function">F</span><span class="nav-item-name is-function"><a href="AST.html#head">head</a></span></li><li class="nav-item"><span class="nav-item-type type-function" title="function">F</span><span class="nav-item-name is-function"><a href="AST.html#isCompound">isCompound</a></span></li><li class="nav-item"><span class="nav-item-type type-function" title="function">F</span><span class="nav-item-name is-function"><a href="AST.html#isConcept">isConcept</a></span></li><li class="nav-item"><span class="nav-item-type type-function" title="function">F</span><span class="nav-item-name is-function"><a href="AST.html#isLeaf">isLeaf</a></span></li><li class="nav-item"><span class="nav-item-type type-function" title="function">F</span><span class="nav-item-name is-function"><a href="AST.html#numArgs">numArgs</a></span></li><li class="nav-item"><span class="nav-item-type type-function" title="function">F</span><span class="nav-item-name is-function"><a href="AST.html#toJSON">toJSON</a></span></li><li class="nav-item"><span class="nav-item-type type-function" title="function">F</span><span class="nav-item-name is-function"><a href="AST.html#toLanguage">toLanguage</a></span></li><li class="nav-item"><span class="nav-item-type type-function" title="function">F</span><span class="nav-item-name is-function"><a href="AST.html#toString">toString</a></span></li><li class="nav-heading"><span class="nav-item-type type-class" title="class">C</span><span class="nav-item-name is-class"><a href="Converter.html">Converter</a></span></li><li class="nav-item"><span class="nav-item-type type-function" title="function">F</span><span class="nav-item-name is-function"><a href="Converter.html#addBuiltIns">addBuiltIns</a></span></li><li class="nav-item"><span class="nav-item-type type-function" title="function">F</span><span class="nav-item-name is-function"><a href="Converter.html#addConcept">addConcept</a></span></li><li class="nav-item"><span class="nav-item-type type-function" title="function">F</span><span class="nav-item-name is-function"><a href="Converter.html#concept">concept</a></span></li><li class="nav-item"><span class="nav-item-type type-function" title="function">F</span><span class="nav-item-name is-function"><a href="Converter.html#convert">convert</a></span></li><li class="nav-item"><span class="nav-item-type type-function" title="function">F</span><span class="nav-item-name is-function"><a href="Converter.html#isConcept">isConcept</a></span></li><li class="nav-item"><span class="nav-item-type type-function" title="function">F</span><span class="nav-item-name is-function"><a href="Converter.html#isLanguage">isLanguage</a></span></li><li class="nav-item"><span class="nav-item-type type-function" title="function">F</span><span class="nav-item-name is-function"><a href="Converter.html#language">language</a></span></li><li class="nav-heading"><span class="nav-item-type type-class" title="class">C</span><span class="nav-item-name is-class"><a href="Language.html">Language</a></span></li><li class="nav-item"><span class="nav-item-type type-member" title="member">M</span><span class="nav-item-name is-member"><a href="Language.html#regularExpressions">regularExpressions</a></span></li><li class="nav-item"><span class="nav-item-type type-function" title="function">F</span><span class="nav-item-name is-function"><a href="Language.html#.fromJSON">fromJSON</a></span></li><li class="nav-item"><span class="nav-item-type type-function" title="function">F</span><span class="nav-item-name is-function"><a href="Language.html#addNotation">addNotation</a></span></li><li class="nav-item"><span class="nav-item-type type-function" title="function">F</span><span class="nav-item-name is-function"><a href="Language.html#convertTo">convertTo</a></span></li><li class="nav-item"><span class="nav-item-type type-function" title="function">F</span><span class="nav-item-name is-function"><a href="Language.html#parse">parse</a></span></li><li class="nav-item"><span class="nav-item-type type-function" title="function">F</span><span class="nav-item-name is-function"><a href="Language.html#rulesFor">rulesFor</a></span></li><li class="nav-heading"><span class="nav-item-type type-class" title="class">C</span><span class="nav-item-name is-class"><a href="Template.html">Template</a></span></li><li class="nav-item"><span class="nav-item-type type-member" title="member">M</span><span class="nav-item-name is-member"><a href="Template.html#defaultVariableNames">defaultVariableNames</a></span></li><li class="nav-item"><span class="nav-item-type type-function" title="function">F</span><span class="nav-item-name is-function"><a href="Template.html#arity">arity</a></span></li><li class="nav-item"><span class="nav-item-type type-function" title="function">F</span><span class="nav-item-name is-function"><a href="Template.html#fillIn">fillIn</a></span></li><li class="nav-item"><span class="nav-item-type type-function" title="function">F</span><span class="nav-item-name is-function"><a href="Template.html#toString">toString</a></span></li></ul><ul><li class="nav-heading">Modules</li><li class="nav-heading"><span class="nav-item-type type-module" title="module">M</span><span class="nav-item-name is-module"><a href="module-SyntacticTypes.html">SyntacticTypes</a></span></li><li class="nav-item"><span class="nav-item-type type-member" title="member">M</span><span class="nav-item-name is-member"><a href="module-SyntacticTypes.html#.hierarchies">hierarchies</a></span></li><li class="nav-item"><span class="nav-item-type type-member" title="member">M</span><span class="nav-item-name is-member"><a href="module-SyntacticTypes.html#.isAtomic">isAtomic</a></span></li><li class="nav-item"><span class="nav-item-type type-member" title="member">M</span><span class="nav-item-name is-member"><a href="module-SyntacticTypes.html#.isSupertype">isSupertype</a></span></li><li class="nav-item"><span class="nav-item-type type-member" title="member">M</span><span class="nav-item-name is-member"><a href="module-SyntacticTypes.html#.isSupertypeOrEqual">isSupertypeOrEqual</a></span></li><li class="nav-item"><span class="nav-item-type type-member" title="member">M</span><span class="nav-item-name is-member"><a href="module-SyntacticTypes.html#.lowestSubtype">lowestSubtype</a></span></li><li class="nav-item"><span class="nav-item-type type-member" title="member">M</span><span class="nav-item-name is-member"><a href="module-SyntacticTypes.html#.types">types</a></span></li></ul><li class="nav-heading"><a href="global.html">Globals</a></li><li class="nav-item"><span class="nav-item-type type-member" title="member">M</span><span class="nav-item-name is-member"><a href="global.html#escapeRegExp">escapeRegExp</a></span></li><li class="nav-item"><span class="nav-item-type type-member" title="member">M</span><span class="nav-item-name is-member"><a href="global.html#notationStringToArray">notationStringToArray</a></span></li><li class="nav-item"><span class="nav-item-type type-member" title="member">M</span><span class="nav-item-name is-member"><a href="global.html#putdownLeaves">putdownLeaves</a></span></li>
  </nav>
</header>


<main class="layout-main ">
  <div class="container">
    <p class="page-kind"></p>
    <h1 class="page-title">Tutorial: Test Results</h1>
    <section>

<header>
    

    <h2>Test Results</h2>
</header>

<article>
    <p>The following page lists all tests run using the example converter in this
repository, which was built to verify that the language-building and conversion
tools in this repository work.  It can convert among LaTeX, putdown, and JSON
formats (as of this writing).  The specific conversions it performed (to
satisfy the requirements of the test suite) are shown below.</p>
<h2>Table of contents</h2>
<ul>
<li><a href="#Parsing-putdown">Parsing putdown</a></li>
<li><a href="#Rendering-JSON-into-putdown">Rendering JSON into putdown</a></li>
<li><a href="#Parsing-LaTeX">Parsing LaTeX</a></li>
<li><a href="#Rendering-JSON-into-LaTeX">Rendering JSON into LaTeX</a></li>
<li><a href="#Converting-putdown-to-LaTeX">Converting putdown to LaTeX</a></li>
<li><a href="#Converting-LaTeX-to-putdown">Converting LaTeX to putdown</a></li>
<li><a href="#Parsing-MathLive-style-LaTeX">Parsing MathLive-style LaTeX</a></li>
</ul>
<h2><a name="Parsing-putdown">Parsing putdown</a></h2>
<h3>can convert putdown numbers to JSON</h3>
<ul>
<li>Test 1
<ul>
<li>input: putdown <code>0</code></li>
<li>output: JSON <code>[&quot;Number&quot;,&quot;0&quot;]</code></li>
</ul>
</li>
<li>Test 2
<ul>
<li>input: putdown <code>453789</code></li>
<li>output: JSON <code>[&quot;Number&quot;,&quot;453789&quot;]</code></li>
</ul>
</li>
<li>Test 3
<ul>
<li>input: putdown <code>99999999999999999999999999999999999999999</code></li>
<li>output: JSON <code>[&quot;Number&quot;,&quot;99999999999999999999999999999999999999999&quot;]</code></li>
</ul>
</li>
<li>Test 4
<ul>
<li>input: putdown <code>(- 453789)</code></li>
<li>output: JSON <code>[&quot;NumberNegation&quot;,[&quot;Number&quot;,&quot;453789&quot;]]</code></li>
</ul>
</li>
<li>Test 5
<ul>
<li>input: putdown <code>(- 99999999999999999999999999999999999999999)</code></li>
<li>output: JSON <code>[&quot;NumberNegation&quot;,[&quot;Number&quot;,&quot;99999999999999999999999999999999999999999&quot;]]</code></li>
</ul>
</li>
<li>Test 6
<ul>
<li>input: putdown <code>0.0</code></li>
<li>output: JSON <code>[&quot;Number&quot;,&quot;0.0&quot;]</code></li>
</ul>
</li>
<li>Test 7
<ul>
<li>input: putdown <code>29835.6875940</code></li>
<li>output: JSON <code>[&quot;Number&quot;,&quot;29835.6875940&quot;]</code></li>
</ul>
</li>
<li>Test 8
<ul>
<li>input: putdown <code>653280458689.</code></li>
<li>output: JSON <code>[&quot;Number&quot;,&quot;653280458689.&quot;]</code></li>
</ul>
</li>
<li>Test 9
<ul>
<li>input: putdown <code>.000006327589</code></li>
<li>output: JSON <code>[&quot;Number&quot;,&quot;.000006327589&quot;]</code></li>
</ul>
</li>
<li>Test 10
<ul>
<li>input: putdown <code>(- 29835.6875940)</code></li>
<li>output: JSON <code>[&quot;NumberNegation&quot;,[&quot;Number&quot;,&quot;29835.6875940&quot;]]</code></li>
</ul>
</li>
<li>Test 11
<ul>
<li>input: putdown <code>(- 653280458689.)</code></li>
<li>output: JSON <code>[&quot;NumberNegation&quot;,[&quot;Number&quot;,&quot;653280458689.&quot;]]</code></li>
</ul>
</li>
<li>Test 12
<ul>
<li>input: putdown <code>(- .000006327589)</code></li>
<li>output: JSON <code>[&quot;NumberNegation&quot;,[&quot;Number&quot;,&quot;.000006327589&quot;]]</code></li>
</ul>
</li>
</ul>
<h3>can convert any size variable name to JSON</h3>
<ul>
<li>Test 1
<ul>
<li>input: putdown <code>x</code></li>
<li>output: JSON <code>[&quot;FunctionVariable&quot;,&quot;x&quot;]</code></li>
</ul>
</li>
<li>Test 2
<ul>
<li>input: putdown <code>E</code></li>
<li>output: JSON <code>[&quot;FunctionVariable&quot;,&quot;E&quot;]</code></li>
</ul>
</li>
<li>Test 3
<ul>
<li>input: putdown <code>q</code></li>
<li>output: JSON <code>[&quot;FunctionVariable&quot;,&quot;q&quot;]</code></li>
</ul>
</li>
<li>Test 4
<ul>
<li>input: putdown <code>foo</code></li>
<li>output: JSON <code>null</code></li>
</ul>
</li>
<li>Test 5
<ul>
<li>input: putdown <code>bar</code></li>
<li>output: JSON <code>null</code></li>
</ul>
</li>
<li>Test 6
<ul>
<li>input: putdown <code>to</code></li>
<li>output: JSON <code>null</code></li>
</ul>
</li>
</ul>
<h3>can convert numeric constants from putdown to JSON</h3>
<ul>
<li>Test 1
<ul>
<li>input: putdown <code>infinity</code></li>
<li>output: JSON <code>&quot;Infinity&quot;</code></li>
</ul>
</li>
<li>Test 2
<ul>
<li>input: putdown <code>pi</code></li>
<li>output: JSON <code>&quot;Pi&quot;</code></li>
</ul>
</li>
<li>Test 3
<ul>
<li>input: putdown <code>eulersnumber</code></li>
<li>output: JSON <code>&quot;EulersNumber&quot;</code></li>
</ul>
</li>
</ul>
<h3>can convert exponentiation of atomics to JSON</h3>
<ul>
<li>Test 1
<ul>
<li>input: putdown <code>(^ 1 2)</code></li>
<li>output: JSON <code>[&quot;Exponentiation&quot;,[&quot;Number&quot;,&quot;1&quot;],[&quot;Number&quot;,&quot;2&quot;]]</code></li>
</ul>
</li>
<li>Test 2
<ul>
<li>input: putdown <code>(^ e x)</code></li>
<li>output: JSON <code>[&quot;Exponentiation&quot;,[&quot;NumberVariable&quot;,&quot;e&quot;],[&quot;NumberVariable&quot;,&quot;x&quot;]]</code></li>
</ul>
</li>
<li>Test 3
<ul>
<li>input: putdown <code>(^ 1 infinity)</code></li>
<li>output: JSON <code>[&quot;Exponentiation&quot;,[&quot;Number&quot;,&quot;1&quot;],&quot;Infinity&quot;]</code></li>
</ul>
</li>
</ul>
<h3>can convert atomic percentages and factorials to JSON</h3>
<ul>
<li>Test 1
<ul>
<li>input: putdown <code>(% 10)</code></li>
<li>output: JSON <code>[&quot;Percentage&quot;,[&quot;Number&quot;,&quot;10&quot;]]</code></li>
</ul>
</li>
<li>Test 2
<ul>
<li>input: putdown <code>(% t)</code></li>
<li>output: JSON <code>[&quot;Percentage&quot;,[&quot;NumberVariable&quot;,&quot;t&quot;]]</code></li>
</ul>
</li>
<li>Test 3
<ul>
<li>input: putdown <code>(! 6)</code></li>
<li>output: JSON <code>[&quot;Factorial&quot;,[&quot;Number&quot;,&quot;6&quot;]]</code></li>
</ul>
</li>
<li>Test 4
<ul>
<li>input: putdown <code>(! n)</code></li>
<li>output: JSON <code>[&quot;Factorial&quot;,[&quot;NumberVariable&quot;,&quot;n&quot;]]</code></li>
</ul>
</li>
</ul>
<h3>can convert division of atomics or factors to JSON</h3>
<ul>
<li>Test 1
<ul>
<li>input: putdown <code>(/ 1 2)</code></li>
<li>output: JSON <code>[&quot;Division&quot;,[&quot;Number&quot;,&quot;1&quot;],[&quot;Number&quot;,&quot;2&quot;]]</code></li>
</ul>
</li>
<li>Test 2
<ul>
<li>input: putdown <code>(/ x y)</code></li>
<li>output: JSON <code>[&quot;Division&quot;,[&quot;NumberVariable&quot;,&quot;x&quot;],[&quot;NumberVariable&quot;,&quot;y&quot;]]</code></li>
</ul>
</li>
<li>Test 3
<ul>
<li>input: putdown <code>(/ 0 infinity)</code></li>
<li>output: JSON <code>[&quot;Division&quot;,[&quot;Number&quot;,&quot;0&quot;],&quot;Infinity&quot;]</code></li>
</ul>
</li>
<li>Test 4
<ul>
<li>input: putdown <code>(/ (^ x 2) 3)</code></li>
<li>output: JSON <code>[&quot;Division&quot;,[&quot;Exponentiation&quot;,[&quot;NumberVariable&quot;,&quot;x&quot;],[&quot;Number&quot;,&quot;2&quot;]],[&quot;Number&quot;,&quot;3&quot;]]</code></li>
</ul>
</li>
<li>Test 5
<ul>
<li>input: putdown <code>(/ 1 (^ e x))</code></li>
<li>output: JSON <code>[&quot;Division&quot;,[&quot;Number&quot;,&quot;1&quot;],[&quot;Exponentiation&quot;,[&quot;NumberVariable&quot;,&quot;e&quot;],[&quot;NumberVariable&quot;,&quot;x&quot;]]]</code></li>
</ul>
</li>
<li>Test 6
<ul>
<li>input: putdown <code>(/ (% 10) (^ 2 100))</code></li>
<li>output: JSON <code>[&quot;Division&quot;,[&quot;Percentage&quot;,[&quot;Number&quot;,&quot;10&quot;]],[&quot;Exponentiation&quot;,[&quot;Number&quot;,&quot;2&quot;],[&quot;Number&quot;,&quot;100&quot;]]]</code></li>
</ul>
</li>
</ul>
<h3>can convert multiplication of atomics or factors to JSON</h3>
<ul>
<li>Test 1
<ul>
<li>input: putdown <code>(* 1 2)</code></li>
<li>output: JSON <code>[&quot;Multiplication&quot;,[&quot;Number&quot;,&quot;1&quot;],[&quot;Number&quot;,&quot;2&quot;]]</code></li>
</ul>
</li>
<li>Test 2
<ul>
<li>input: putdown <code>(* x y)</code></li>
<li>output: JSON <code>[&quot;Multiplication&quot;,[&quot;NumberVariable&quot;,&quot;x&quot;],[&quot;NumberVariable&quot;,&quot;y&quot;]]</code></li>
</ul>
</li>
<li>Test 3
<ul>
<li>input: putdown <code>(* 0 infinity)</code></li>
<li>output: JSON <code>[&quot;Multiplication&quot;,[&quot;Number&quot;,&quot;0&quot;],&quot;Infinity&quot;]</code></li>
</ul>
</li>
<li>Test 4
<ul>
<li>input: putdown <code>(* (^ x 2) 3)</code></li>
<li>output: JSON <code>[&quot;Multiplication&quot;,[&quot;Exponentiation&quot;,[&quot;NumberVariable&quot;,&quot;x&quot;],[&quot;Number&quot;,&quot;2&quot;]],[&quot;Number&quot;,&quot;3&quot;]]</code></li>
</ul>
</li>
<li>Test 5
<ul>
<li>input: putdown <code>(* 1 (^ e x))</code></li>
<li>output: JSON <code>[&quot;Multiplication&quot;,[&quot;Number&quot;,&quot;1&quot;],[&quot;Exponentiation&quot;,[&quot;NumberVariable&quot;,&quot;e&quot;],[&quot;NumberVariable&quot;,&quot;x&quot;]]]</code></li>
</ul>
</li>
<li>Test 6
<ul>
<li>input: putdown <code>(* (% 10) (^ 2 100))</code></li>
<li>output: JSON <code>[&quot;Multiplication&quot;,[&quot;Percentage&quot;,[&quot;Number&quot;,&quot;10&quot;]],[&quot;Exponentiation&quot;,[&quot;Number&quot;,&quot;2&quot;],[&quot;Number&quot;,&quot;100&quot;]]]</code></li>
</ul>
</li>
</ul>
<h3>can convert negations of atomics or factors to JSON</h3>
<ul>
<li>Test 1
<ul>
<li>input: putdown <code>(* (- 1) 2)</code></li>
<li>output: JSON <code>[&quot;Multiplication&quot;,[&quot;NumberNegation&quot;,[&quot;Number&quot;,&quot;1&quot;]],[&quot;Number&quot;,&quot;2&quot;]]</code></li>
</ul>
</li>
<li>Test 2
<ul>
<li>input: putdown <code>(* x (- y))</code></li>
<li>output: JSON <code>[&quot;Multiplication&quot;,[&quot;NumberVariable&quot;,&quot;x&quot;],[&quot;NumberNegation&quot;,[&quot;NumberVariable&quot;,&quot;y&quot;]]]</code></li>
</ul>
</li>
<li>Test 3
<ul>
<li>input: putdown <code>(* (- (^ x 2)) (- 3))</code></li>
<li>output: JSON <code>[&quot;Multiplication&quot;,[&quot;NumberNegation&quot;,[&quot;Exponentiation&quot;,[&quot;NumberVariable&quot;,&quot;x&quot;],[&quot;Number&quot;,&quot;2&quot;]]],[&quot;NumberNegation&quot;,[&quot;Number&quot;,&quot;3&quot;]]]</code></li>
</ul>
</li>
<li>Test 4
<ul>
<li>input: putdown <code>(- (- (- (- 1000))))</code></li>
<li>output: JSON <code>[&quot;NumberNegation&quot;,[&quot;NumberNegation&quot;,[&quot;NumberNegation&quot;,[&quot;NumberNegation&quot;,[&quot;Number&quot;,&quot;1000&quot;]]]]]</code></li>
</ul>
</li>
</ul>
<h3>can convert additions and subtractions to JSON</h3>
<ul>
<li>Test 1
<ul>
<li>input: putdown <code>(+ x y)</code></li>
<li>output: JSON <code>[&quot;Addition&quot;,[&quot;NumberVariable&quot;,&quot;x&quot;],[&quot;NumberVariable&quot;,&quot;y&quot;]]</code></li>
</ul>
</li>
<li>Test 2
<ul>
<li>input: putdown <code>(- 1 (- 3))</code></li>
<li>output: JSON <code>[&quot;Subtraction&quot;,[&quot;Number&quot;,&quot;1&quot;],[&quot;NumberNegation&quot;,[&quot;Number&quot;,&quot;3&quot;]]]</code></li>
</ul>
</li>
<li>Test 3
<ul>
<li>input: putdown <code>(+ (^ A B) (- C pi))</code></li>
<li>output: JSON <code>[&quot;Addition&quot;,[&quot;Exponentiation&quot;,[&quot;NumberVariable&quot;,&quot;A&quot;],[&quot;NumberVariable&quot;,&quot;B&quot;]],[&quot;Subtraction&quot;,[&quot;NumberVariable&quot;,&quot;C&quot;],&quot;Pi&quot;]]</code></li>
</ul>
</li>
</ul>
<h3>can convert Number exprs that normally require groupers to JSON</h3>
<ul>
<li>Test 1
<ul>
<li>input: putdown <code>(- (* 1 2))</code></li>
<li>output: JSON <code>[&quot;NumberNegation&quot;,[&quot;Multiplication&quot;,[&quot;Number&quot;,&quot;1&quot;],[&quot;Number&quot;,&quot;2&quot;]]]</code></li>
</ul>
</li>
<li>Test 2
<ul>
<li>input: putdown <code>(! (^ x 2))</code></li>
<li>output: JSON <code>[&quot;Factorial&quot;,[&quot;Exponentiation&quot;,[&quot;NumberVariable&quot;,&quot;x&quot;],[&quot;Number&quot;,&quot;2&quot;]]]</code></li>
</ul>
</li>
<li>Test 3
<ul>
<li>input: putdown <code>(^ (- x) (* 2 (- 3)))</code></li>
<li>output: JSON <code>[&quot;Exponentiation&quot;,[&quot;NumberNegation&quot;,[&quot;NumberVariable&quot;,&quot;x&quot;]],[&quot;Multiplication&quot;,[&quot;Number&quot;,&quot;2&quot;],[&quot;NumberNegation&quot;,[&quot;Number&quot;,&quot;3&quot;]]]]</code></li>
</ul>
</li>
<li>Test 4
<ul>
<li>input: putdown <code>(^ (- 3) (+ 1 2))</code></li>
<li>output: JSON <code>[&quot;Exponentiation&quot;,[&quot;NumberNegation&quot;,[&quot;Number&quot;,&quot;3&quot;]],[&quot;Addition&quot;,[&quot;Number&quot;,&quot;1&quot;],[&quot;Number&quot;,&quot;2&quot;]]]</code></li>
</ul>
</li>
</ul>
<h3>can convert relations of numeric expressions to JSON</h3>
<ul>
<li>Test 1
<ul>
<li>input: putdown <code>(&gt; 1 2)</code></li>
<li>output: JSON <code>[&quot;GreaterThan&quot;,[&quot;Number&quot;,&quot;1&quot;],[&quot;Number&quot;,&quot;2&quot;]]</code></li>
</ul>
</li>
<li>Test 2
<ul>
<li>input: putdown <code>(&lt; (- 1 2) (+ 1 2))</code></li>
<li>output: JSON <code>[&quot;LessThan&quot;,[&quot;Subtraction&quot;,[&quot;Number&quot;,&quot;1&quot;],[&quot;Number&quot;,&quot;2&quot;]],[&quot;Addition&quot;,[&quot;Number&quot;,&quot;1&quot;],[&quot;Number&quot;,&quot;2&quot;]]]</code></li>
</ul>
</li>
<li>Test 3
<ul>
<li>input: putdown <code>(not (= 1 2))</code></li>
<li>output: JSON <code>[&quot;LogicalNegation&quot;,[&quot;Equals&quot;,[&quot;Number&quot;,&quot;1&quot;],[&quot;Number&quot;,&quot;2&quot;]]]</code></li>
</ul>
</li>
<li>Test 4
<ul>
<li>input: putdown <code>(and (&gt;= 2 1) (&lt;= 2 3))</code></li>
<li>output: JSON <code>[&quot;Conjunction&quot;,[&quot;GreaterThanOrEqual&quot;,[&quot;Number&quot;,&quot;2&quot;],[&quot;Number&quot;,&quot;1&quot;]],[&quot;LessThanOrEqual&quot;,[&quot;Number&quot;,&quot;2&quot;],[&quot;Number&quot;,&quot;3&quot;]]]</code></li>
</ul>
</li>
<li>Test 5
<ul>
<li>input: putdown <code>(relationholds | 7 14)</code></li>
<li>output: JSON <code>[&quot;BinaryRelationHolds&quot;,&quot;Divides&quot;,[&quot;Number&quot;,&quot;7&quot;],[&quot;Number&quot;,&quot;14&quot;]]</code></li>
</ul>
</li>
<li>Test 6
<ul>
<li>input: putdown <code>(relationholds | (apply A k) (! n))</code></li>
<li>output: JSON <code>[&quot;BinaryRelationHolds&quot;,&quot;Divides&quot;,[&quot;NumberFunctionApplication&quot;,[&quot;FunctionVariable&quot;,&quot;A&quot;],[&quot;NumberVariable&quot;,&quot;k&quot;]],[&quot;Factorial&quot;,[&quot;NumberVariable&quot;,&quot;n&quot;]]]</code></li>
</ul>
</li>
<li>Test 7
<ul>
<li>input: putdown <code>(relationholds ~ (- 1 k) (+ 1 k))</code></li>
<li>output: JSON <code>[&quot;BinaryRelationHolds&quot;,&quot;GenericBinaryRelation&quot;,[&quot;Subtraction&quot;,[&quot;Number&quot;,&quot;1&quot;],[&quot;NumberVariable&quot;,&quot;k&quot;]],[&quot;Addition&quot;,[&quot;Number&quot;,&quot;1&quot;],[&quot;NumberVariable&quot;,&quot;k&quot;]]]</code></li>
</ul>
</li>
<li>Test 8
<ul>
<li>input: putdown <code>(relationholds ~~ 0.99 1.01)</code></li>
<li>output: JSON <code>[&quot;BinaryRelationHolds&quot;,&quot;ApproximatelyEqual&quot;,[&quot;Number&quot;,&quot;0.99&quot;],[&quot;Number&quot;,&quot;1.01&quot;]]</code></li>
</ul>
</li>
</ul>
<h3>does not undo the canonical form for inequality</h3>
<ul>
<li>Test 1
<ul>
<li>input: putdown <code>(not (= x y))</code></li>
<li>output: JSON <code>[&quot;LogicalNegation&quot;,[&quot;EqualFunctions&quot;,[&quot;FunctionVariable&quot;,&quot;x&quot;],[&quot;FunctionVariable&quot;,&quot;y&quot;]]]</code></li>
</ul>
</li>
</ul>
<h3>can convert propositional logic atomics to JSON</h3>
<ul>
<li>Test 1
<ul>
<li>input: putdown <code>true</code></li>
<li>output: JSON <code>&quot;LogicalTrue&quot;</code></li>
</ul>
</li>
<li>Test 2
<ul>
<li>input: putdown <code>false</code></li>
<li>output: JSON <code>&quot;LogicalFalse&quot;</code></li>
</ul>
</li>
<li>Test 3
<ul>
<li>input: putdown <code>contradiction</code></li>
<li>output: JSON <code>&quot;Contradiction&quot;</code></li>
</ul>
</li>
</ul>
<h3>can convert propositional logic conjuncts to JSON</h3>
<ul>
<li>Test 1
<ul>
<li>input: putdown <code>(and true false)</code></li>
<li>output: JSON <code>[&quot;Conjunction&quot;,&quot;LogicalTrue&quot;,&quot;LogicalFalse&quot;]</code></li>
</ul>
</li>
<li>Test 2
<ul>
<li>input: putdown <code>(and (not P) (not true))</code></li>
<li>output: JSON <code>[&quot;Conjunction&quot;,[&quot;LogicalNegation&quot;,[&quot;LogicVariable&quot;,&quot;P&quot;]],[&quot;LogicalNegation&quot;,&quot;LogicalTrue&quot;]]</code></li>
</ul>
</li>
<li>Test 3
<ul>
<li>input: putdown <code>(and (and a b) c)</code></li>
<li>output: JSON <code>[&quot;Conjunction&quot;,[&quot;Conjunction&quot;,[&quot;LogicVariable&quot;,&quot;a&quot;],[&quot;LogicVariable&quot;,&quot;b&quot;]],[&quot;LogicVariable&quot;,&quot;c&quot;]]</code></li>
</ul>
</li>
</ul>
<h3>can convert propositional logic disjuncts to JSON</h3>
<ul>
<li>Test 1
<ul>
<li>input: putdown <code>(or true (not A))</code></li>
<li>output: JSON <code>[&quot;Disjunction&quot;,&quot;LogicalTrue&quot;,[&quot;LogicalNegation&quot;,[&quot;LogicVariable&quot;,&quot;A&quot;]]]</code></li>
</ul>
</li>
<li>Test 2
<ul>
<li>input: putdown <code>(or (and P Q) (and Q P))</code></li>
<li>output: JSON <code>[&quot;Disjunction&quot;,[&quot;Conjunction&quot;,[&quot;LogicVariable&quot;,&quot;P&quot;],[&quot;LogicVariable&quot;,&quot;Q&quot;]],[&quot;Conjunction&quot;,[&quot;LogicVariable&quot;,&quot;Q&quot;],[&quot;LogicVariable&quot;,&quot;P&quot;]]]</code></li>
</ul>
</li>
</ul>
<h3>can convert propositional logic conditionals to JSON</h3>
<ul>
<li>Test 1
<ul>
<li>input: putdown <code>(implies A (and Q (not P)))</code></li>
<li>output: JSON <code>[&quot;Implication&quot;,[&quot;LogicVariable&quot;,&quot;A&quot;],[&quot;Conjunction&quot;,[&quot;LogicVariable&quot;,&quot;Q&quot;],[&quot;LogicalNegation&quot;,[&quot;LogicVariable&quot;,&quot;P&quot;]]]]</code></li>
</ul>
</li>
<li>Test 2
<ul>
<li>input: putdown <code>(implies (implies (or P Q) (and Q P)) T)</code></li>
<li>output: JSON <code>[&quot;Implication&quot;,[&quot;Implication&quot;,[&quot;Disjunction&quot;,[&quot;LogicVariable&quot;,&quot;P&quot;],[&quot;LogicVariable&quot;,&quot;Q&quot;]],[&quot;Conjunction&quot;,[&quot;LogicVariable&quot;,&quot;Q&quot;],[&quot;LogicVariable&quot;,&quot;P&quot;]]],[&quot;LogicVariable&quot;,&quot;T&quot;]]</code></li>
</ul>
</li>
</ul>
<h3>can convert propositional logic biconditionals to JSON</h3>
<ul>
<li>Test 1
<ul>
<li>input: putdown <code>(iff A (and Q (not P)))</code></li>
<li>output: JSON <code>[&quot;LogicalEquivalence&quot;,[&quot;LogicVariable&quot;,&quot;A&quot;],[&quot;Conjunction&quot;,[&quot;LogicVariable&quot;,&quot;Q&quot;],[&quot;LogicalNegation&quot;,[&quot;LogicVariable&quot;,&quot;P&quot;]]]]</code></li>
</ul>
</li>
<li>Test 2
<ul>
<li>input: putdown <code>(implies (iff (or P Q) (and Q P)) T)</code></li>
<li>output: JSON <code>[&quot;Implication&quot;,[&quot;LogicalEquivalence&quot;,[&quot;Disjunction&quot;,[&quot;LogicVariable&quot;,&quot;P&quot;],[&quot;LogicVariable&quot;,&quot;Q&quot;]],[&quot;Conjunction&quot;,[&quot;LogicVariable&quot;,&quot;Q&quot;],[&quot;LogicVariable&quot;,&quot;P&quot;]]],[&quot;LogicVariable&quot;,&quot;T&quot;]]</code></li>
</ul>
</li>
</ul>
<h3>can convert propositional expressions with groupers to JSON</h3>
<ul>
<li>Test 1
<ul>
<li>input: putdown <code>(or P (and (iff Q Q) P))</code></li>
<li>output: JSON <code>[&quot;Disjunction&quot;,[&quot;LogicVariable&quot;,&quot;P&quot;],[&quot;Conjunction&quot;,[&quot;LogicalEquivalence&quot;,[&quot;LogicVariable&quot;,&quot;Q&quot;],[&quot;LogicVariable&quot;,&quot;Q&quot;]],[&quot;LogicVariable&quot;,&quot;P&quot;]]]</code></li>
</ul>
</li>
<li>Test 2
<ul>
<li>input: putdown <code>(not (iff true false))</code></li>
<li>output: JSON <code>[&quot;LogicalNegation&quot;,[&quot;LogicalEquivalence&quot;,&quot;LogicalTrue&quot;,&quot;LogicalFalse&quot;]]</code></li>
</ul>
</li>
</ul>
<h3>can convert simple predicate logic expressions to JSON</h3>
<ul>
<li>Test 1
<ul>
<li>input: putdown <code>(forall (x , P))</code></li>
<li>output: JSON <code>[&quot;UniversalQuantifier&quot;,[&quot;NumberVariable&quot;,&quot;x&quot;],[&quot;LogicVariable&quot;,&quot;P&quot;]]</code></li>
</ul>
</li>
<li>Test 2
<ul>
<li>input: putdown <code>(exists (t , (not Q)))</code></li>
<li>output: JSON <code>[&quot;ExistentialQuantifier&quot;,[&quot;NumberVariable&quot;,&quot;t&quot;],[&quot;LogicalNegation&quot;,[&quot;LogicVariable&quot;,&quot;Q&quot;]]]</code></li>
</ul>
</li>
<li>Test 3
<ul>
<li>input: putdown <code>(exists! (k , (implies m n)))</code></li>
<li>output: JSON <code>[&quot;UniqueExistentialQuantifier&quot;,[&quot;NumberVariable&quot;,&quot;k&quot;],[&quot;Implication&quot;,[&quot;LogicVariable&quot;,&quot;m&quot;],[&quot;LogicVariable&quot;,&quot;n&quot;]]]</code></li>
</ul>
</li>
</ul>
<h3>can convert finite and empty sets to JSON</h3>
<ul>
<li>Test 1
<ul>
<li>input: putdown <code>emptyset</code></li>
<li>output: JSON <code>&quot;EmptySet&quot;</code></li>
</ul>
</li>
<li>Test 2
<ul>
<li>input: putdown <code>(finiteset (elts 1))</code></li>
<li>output: JSON <code>[&quot;FiniteSet&quot;,[&quot;OneElementSequence&quot;,[&quot;Number&quot;,&quot;1&quot;]]]</code></li>
</ul>
</li>
<li>Test 3
<ul>
<li>input: putdown <code>(finiteset (elts 1 (elts 2)))</code></li>
<li>output: JSON <code>[&quot;FiniteSet&quot;,[&quot;ElementThenSequence&quot;,[&quot;Number&quot;,&quot;1&quot;],[&quot;OneElementSequence&quot;,[&quot;Number&quot;,&quot;2&quot;]]]]</code></li>
</ul>
</li>
<li>Test 4
<ul>
<li>input: putdown <code>(finiteset (elts 1 (elts 2 (elts 3))))</code></li>
<li>output: JSON <code>[&quot;FiniteSet&quot;,[&quot;ElementThenSequence&quot;,[&quot;Number&quot;,&quot;1&quot;],[&quot;ElementThenSequence&quot;,[&quot;Number&quot;,&quot;2&quot;],[&quot;OneElementSequence&quot;,[&quot;Number&quot;,&quot;3&quot;]]]]]</code></li>
</ul>
</li>
<li>Test 5
<ul>
<li>input: putdown <code>(finiteset (elts emptyset (elts emptyset)))</code></li>
<li>output: JSON <code>[&quot;FiniteSet&quot;,[&quot;ElementThenSequence&quot;,&quot;EmptySet&quot;,[&quot;OneElementSequence&quot;,&quot;EmptySet&quot;]]]</code></li>
</ul>
</li>
<li>Test 6
<ul>
<li>input: putdown <code>(finiteset (elts (finiteset (elts emptyset))))</code></li>
<li>output: JSON <code>[&quot;FiniteSet&quot;,[&quot;OneElementSequence&quot;,[&quot;FiniteSet&quot;,[&quot;OneElementSequence&quot;,&quot;EmptySet&quot;]]]]</code></li>
</ul>
</li>
<li>Test 7
<ul>
<li>input: putdown <code>(finiteset (elts 3 (elts x)))</code></li>
<li>output: JSON <code>[&quot;FiniteSet&quot;,[&quot;ElementThenSequence&quot;,[&quot;Number&quot;,&quot;3&quot;],[&quot;OneElementSequence&quot;,[&quot;NumberVariable&quot;,&quot;x&quot;]]]]</code></li>
</ul>
</li>
<li>Test 8
<ul>
<li>input: putdown <code>(finiteset (elts (union A B) (elts (intersection A B))))</code></li>
<li>output: JSON <code>[&quot;FiniteSet&quot;,[&quot;ElementThenSequence&quot;,[&quot;SetUnion&quot;,[&quot;SetVariable&quot;,&quot;A&quot;],[&quot;SetVariable&quot;,&quot;B&quot;]],[&quot;OneElementSequence&quot;,[&quot;SetIntersection&quot;,[&quot;SetVariable&quot;,&quot;A&quot;],[&quot;SetVariable&quot;,&quot;B&quot;]]]]]</code></li>
</ul>
</li>
<li>Test 9
<ul>
<li>input: putdown <code>(finiteset (elts 1 (elts 2 (elts emptyset (elts K (elts P))))))</code></li>
<li>output: JSON <code>[&quot;FiniteSet&quot;,[&quot;ElementThenSequence&quot;,[&quot;Number&quot;,&quot;1&quot;],[&quot;ElementThenSequence&quot;,[&quot;Number&quot;,&quot;2&quot;],[&quot;ElementThenSequence&quot;,&quot;EmptySet&quot;,[&quot;ElementThenSequence&quot;,[&quot;NumberVariable&quot;,&quot;K&quot;],[&quot;OneElementSequence&quot;,[&quot;NumberVariable&quot;,&quot;P&quot;]]]]]]]</code></li>
</ul>
</li>
</ul>
<h3>can convert tuples and vectors to JSON</h3>
<ul>
<li>Test 1
<ul>
<li>input: putdown <code>(tuple (elts 5 (elts 6)))</code></li>
<li>output: JSON <code>[&quot;Tuple&quot;,[&quot;ElementThenSequence&quot;,[&quot;Number&quot;,&quot;5&quot;],[&quot;OneElementSequence&quot;,[&quot;Number&quot;,&quot;6&quot;]]]]</code></li>
</ul>
</li>
<li>Test 2
<ul>
<li>input: putdown <code>(tuple (elts 5 (elts (union A B) (elts k))))</code></li>
<li>output: JSON <code>[&quot;Tuple&quot;,[&quot;ElementThenSequence&quot;,[&quot;Number&quot;,&quot;5&quot;],[&quot;ElementThenSequence&quot;,[&quot;SetUnion&quot;,[&quot;SetVariable&quot;,&quot;A&quot;],[&quot;SetVariable&quot;,&quot;B&quot;]],[&quot;OneElementSequence&quot;,[&quot;NumberVariable&quot;,&quot;k&quot;]]]]]</code></li>
</ul>
</li>
<li>Test 3
<ul>
<li>input: putdown <code>(vector (elts 5 (elts 6)))</code></li>
<li>output: JSON <code>[&quot;Vector&quot;,[&quot;NumberThenSequence&quot;,[&quot;Number&quot;,&quot;5&quot;],[&quot;OneNumberSequence&quot;,[&quot;Number&quot;,&quot;6&quot;]]]]</code></li>
</ul>
</li>
<li>Test 4
<ul>
<li>input: putdown <code>(vector (elts 5 (elts (- 7) (elts k))))</code></li>
<li>output: JSON <code>[&quot;Vector&quot;,[&quot;NumberThenSequence&quot;,[&quot;Number&quot;,&quot;5&quot;],[&quot;NumberThenSequence&quot;,[&quot;NumberNegation&quot;,[&quot;Number&quot;,&quot;7&quot;]],[&quot;OneNumberSequence&quot;,[&quot;NumberVariable&quot;,&quot;k&quot;]]]]]</code></li>
</ul>
</li>
<li>Test 5
<ul>
<li>input: putdown <code>(tuple)</code></li>
<li>output: JSON <code>null</code></li>
</ul>
</li>
<li>Test 6
<ul>
<li>input: putdown <code>(tuple (elts))</code></li>
<li>output: JSON <code>null</code></li>
</ul>
</li>
<li>Test 7
<ul>
<li>input: putdown <code>(tuple (elts 3))</code></li>
<li>output: JSON <code>null</code></li>
</ul>
</li>
<li>Test 8
<ul>
<li>input: putdown <code>(vector)</code></li>
<li>output: JSON <code>null</code></li>
</ul>
</li>
<li>Test 9
<ul>
<li>input: putdown <code>(vector (elts))</code></li>
<li>output: JSON <code>null</code></li>
</ul>
</li>
<li>Test 10
<ul>
<li>input: putdown <code>(vector (elts 3))</code></li>
<li>output: JSON <code>null</code></li>
</ul>
</li>
<li>Test 11
<ul>
<li>input: putdown <code>(tuple (elts (tuple (elts 1 (elts 2))) (elts 6)))</code></li>
<li>output: JSON <code>[&quot;Tuple&quot;,[&quot;ElementThenSequence&quot;,[&quot;Tuple&quot;,[&quot;ElementThenSequence&quot;,[&quot;Number&quot;,&quot;1&quot;],[&quot;OneElementSequence&quot;,[&quot;Number&quot;,&quot;2&quot;]]]],[&quot;OneElementSequence&quot;,[&quot;Number&quot;,&quot;6&quot;]]]]</code></li>
</ul>
</li>
<li>Test 12
<ul>
<li>input: putdown <code>(vector (elts (tuple (elts 1 (elts 2))) (elts 6)))</code></li>
<li>output: JSON <code>null</code></li>
</ul>
</li>
<li>Test 13
<ul>
<li>input: putdown <code>(vector (elts (vector (elts 1 (elts 2))) (elts 6)))</code></li>
<li>output: JSON <code>null</code></li>
</ul>
</li>
<li>Test 14
<ul>
<li>input: putdown <code>(vector (elts (union A B) (elts 6)))</code></li>
<li>output: JSON <code>null</code></li>
</ul>
</li>
</ul>
<h3>can convert simple set memberships and subsets to JSON</h3>
<ul>
<li>Test 1
<ul>
<li>input: putdown <code>(in b B)</code></li>
<li>output: JSON <code>[&quot;NounIsElement&quot;,[&quot;NumberVariable&quot;,&quot;b&quot;],[&quot;SetVariable&quot;,&quot;B&quot;]]</code></li>
</ul>
</li>
<li>Test 2
<ul>
<li>input: putdown <code>(in 2 (finiteset (elts 1 (elts 2))))</code></li>
<li>output: JSON <code>[&quot;NounIsElement&quot;,[&quot;Number&quot;,&quot;2&quot;],[&quot;FiniteSet&quot;,[&quot;ElementThenSequence&quot;,[&quot;Number&quot;,&quot;1&quot;],[&quot;OneElementSequence&quot;,[&quot;Number&quot;,&quot;2&quot;]]]]]</code></li>
</ul>
</li>
<li>Test 3
<ul>
<li>input: putdown <code>(in X (union a b))</code></li>
<li>output: JSON <code>[&quot;NounIsElement&quot;,[&quot;NumberVariable&quot;,&quot;X&quot;],[&quot;SetUnion&quot;,[&quot;SetVariable&quot;,&quot;a&quot;],[&quot;SetVariable&quot;,&quot;b&quot;]]]</code></li>
</ul>
</li>
<li>Test 4
<ul>
<li>input: putdown <code>(in (union A B) (union X Y))</code></li>
<li>output: JSON <code>[&quot;NounIsElement&quot;,[&quot;SetUnion&quot;,[&quot;SetVariable&quot;,&quot;A&quot;],[&quot;SetVariable&quot;,&quot;B&quot;]],[&quot;SetUnion&quot;,[&quot;SetVariable&quot;,&quot;X&quot;],[&quot;SetVariable&quot;,&quot;Y&quot;]]]</code></li>
</ul>
</li>
<li>Test 5
<ul>
<li>input: putdown <code>(subset A (complement B))</code></li>
<li>output: JSON <code>[&quot;Subset&quot;,[&quot;SetVariable&quot;,&quot;A&quot;],[&quot;SetComplement&quot;,[&quot;SetVariable&quot;,&quot;B&quot;]]]</code></li>
</ul>
</li>
<li>Test 6
<ul>
<li>input: putdown <code>(subseteq (intersection u v) (union u v))</code></li>
<li>output: JSON <code>[&quot;SubsetOrEqual&quot;,[&quot;SetIntersection&quot;,[&quot;SetVariable&quot;,&quot;u&quot;],[&quot;SetVariable&quot;,&quot;v&quot;]],[&quot;SetUnion&quot;,[&quot;SetVariable&quot;,&quot;u&quot;],[&quot;SetVariable&quot;,&quot;v&quot;]]]</code></li>
</ul>
</li>
<li>Test 7
<ul>
<li>input: putdown <code>(subseteq (finiteset (elts 1)) (union (finiteset (elts 1)) (finiteset (elts 2))))</code></li>
<li>output: JSON <code>[&quot;SubsetOrEqual&quot;,[&quot;FiniteSet&quot;,[&quot;OneElementSequence&quot;,[&quot;Number&quot;,&quot;1&quot;]]],[&quot;SetUnion&quot;,[&quot;FiniteSet&quot;,[&quot;OneElementSequence&quot;,[&quot;Number&quot;,&quot;1&quot;]]],[&quot;FiniteSet&quot;,[&quot;OneElementSequence&quot;,[&quot;Number&quot;,&quot;2&quot;]]]]]</code></li>
</ul>
</li>
<li>Test 8
<ul>
<li>input: putdown <code>(in p (cartesianproduct U V))</code></li>
<li>output: JSON <code>[&quot;NounIsElement&quot;,[&quot;NumberVariable&quot;,&quot;p&quot;],[&quot;SetCartesianProduct&quot;,[&quot;SetVariable&quot;,&quot;U&quot;],[&quot;SetVariable&quot;,&quot;V&quot;]]]</code></li>
</ul>
</li>
<li>Test 9
<ul>
<li>input: putdown <code>(in q (union (complement U) (cartesianproduct V W)))</code></li>
<li>output: JSON <code>[&quot;NounIsElement&quot;,[&quot;NumberVariable&quot;,&quot;q&quot;],[&quot;SetUnion&quot;,[&quot;SetComplement&quot;,[&quot;SetVariable&quot;,&quot;U&quot;]],[&quot;SetCartesianProduct&quot;,[&quot;SetVariable&quot;,&quot;V&quot;],[&quot;SetVariable&quot;,&quot;W&quot;]]]]</code></li>
</ul>
</li>
<li>Test 10
<ul>
<li>input: putdown <code>(in (tuple (elts a (elts b))) (cartesianproduct A B))</code></li>
<li>output: JSON <code>[&quot;NounIsElement&quot;,[&quot;Tuple&quot;,[&quot;ElementThenSequence&quot;,[&quot;NumberVariable&quot;,&quot;a&quot;],[&quot;OneElementSequence&quot;,[&quot;NumberVariable&quot;,&quot;b&quot;]]]],[&quot;SetCartesianProduct&quot;,[&quot;SetVariable&quot;,&quot;A&quot;],[&quot;SetVariable&quot;,&quot;B&quot;]]]</code></li>
</ul>
</li>
<li>Test 11
<ul>
<li>input: putdown <code>(in (vector (elts a (elts b))) (cartesianproduct A B))</code></li>
<li>output: JSON <code>[&quot;NounIsElement&quot;,[&quot;Vector&quot;,[&quot;NumberThenSequence&quot;,[&quot;NumberVariable&quot;,&quot;a&quot;],[&quot;OneNumberSequence&quot;,[&quot;NumberVariable&quot;,&quot;b&quot;]]]],[&quot;SetCartesianProduct&quot;,[&quot;SetVariable&quot;,&quot;A&quot;],[&quot;SetVariable&quot;,&quot;B&quot;]]]</code></li>
</ul>
</li>
</ul>
<h3>does not undo the canonical form for &quot;notin&quot; notation</h3>
<ul>
<li>Test 1
<ul>
<li>input: putdown <code>(not (in a A))</code></li>
<li>output: JSON <code>[&quot;LogicalNegation&quot;,[&quot;NounIsElement&quot;,[&quot;NumberVariable&quot;,&quot;a&quot;],[&quot;SetVariable&quot;,&quot;A&quot;]]]</code></li>
</ul>
</li>
<li>Test 2
<ul>
<li>input: putdown <code>(not (in emptyset emptyset))</code></li>
<li>output: JSON <code>[&quot;LogicalNegation&quot;,[&quot;NounIsElement&quot;,&quot;EmptySet&quot;,&quot;EmptySet&quot;]]</code></li>
</ul>
</li>
<li>Test 3
<ul>
<li>input: putdown <code>(not (in (- 3 5) (intersection K P)))</code></li>
<li>output: JSON <code>[&quot;LogicalNegation&quot;,[&quot;NounIsElement&quot;,[&quot;Subtraction&quot;,[&quot;Number&quot;,&quot;3&quot;],[&quot;Number&quot;,&quot;5&quot;]],[&quot;SetIntersection&quot;,[&quot;SetVariable&quot;,&quot;K&quot;],[&quot;SetVariable&quot;,&quot;P&quot;]]]]</code></li>
</ul>
</li>
</ul>
<h3>can parse to JSON sentences built from various relations</h3>
<ul>
<li>Test 1
<ul>
<li>input: putdown <code>(or P (in b B))</code></li>
<li>output: JSON <code>[&quot;Disjunction&quot;,[&quot;LogicVariable&quot;,&quot;P&quot;],[&quot;NounIsElement&quot;,[&quot;NumberVariable&quot;,&quot;b&quot;],[&quot;SetVariable&quot;,&quot;B&quot;]]]</code></li>
</ul>
</li>
<li>Test 2
<ul>
<li>input: putdown <code>(forall (x , (in x X)))</code></li>
<li>output: JSON <code>[&quot;UniversalQuantifier&quot;,[&quot;NumberVariable&quot;,&quot;x&quot;],[&quot;NounIsElement&quot;,[&quot;NumberVariable&quot;,&quot;x&quot;],[&quot;SetVariable&quot;,&quot;X&quot;]]]</code></li>
</ul>
</li>
<li>Test 3
<ul>
<li>input: putdown <code>(and (subseteq A B) (subseteq B A))</code></li>
<li>output: JSON <code>[&quot;Conjunction&quot;,[&quot;SubsetOrEqual&quot;,[&quot;SetVariable&quot;,&quot;A&quot;],[&quot;SetVariable&quot;,&quot;B&quot;]],[&quot;SubsetOrEqual&quot;,[&quot;SetVariable&quot;,&quot;B&quot;],[&quot;SetVariable&quot;,&quot;A&quot;]]]</code></li>
</ul>
</li>
<li>Test 4
<ul>
<li>input: putdown <code>(= R (cartesianproduct A B))</code></li>
<li>output: JSON <code>[&quot;Equals&quot;,[&quot;NumberVariable&quot;,&quot;R&quot;],[&quot;SetCartesianProduct&quot;,[&quot;SetVariable&quot;,&quot;A&quot;],[&quot;SetVariable&quot;,&quot;B&quot;]]]</code></li>
</ul>
</li>
<li>Test 5
<ul>
<li>input: putdown <code>(forall (n , (relationholds | n (! n))))</code></li>
<li>output: JSON <code>[&quot;UniversalQuantifier&quot;,[&quot;NumberVariable&quot;,&quot;n&quot;],[&quot;BinaryRelationHolds&quot;,&quot;Divides&quot;,[&quot;NumberVariable&quot;,&quot;n&quot;],[&quot;Factorial&quot;,[&quot;NumberVariable&quot;,&quot;n&quot;]]]]</code></li>
</ul>
</li>
<li>Test 6
<ul>
<li>input: putdown <code>(implies (relationholds ~ a b) (relationholds ~ b a))</code></li>
<li>output: JSON <code>[&quot;Implication&quot;,[&quot;BinaryRelationHolds&quot;,&quot;GenericBinaryRelation&quot;,[&quot;NumberVariable&quot;,&quot;a&quot;],[&quot;NumberVariable&quot;,&quot;b&quot;]],[&quot;BinaryRelationHolds&quot;,&quot;GenericBinaryRelation&quot;,[&quot;NumberVariable&quot;,&quot;b&quot;],[&quot;NumberVariable&quot;,&quot;a&quot;]]]</code></li>
</ul>
</li>
</ul>
<h3>can parse notation related to functions</h3>
<ul>
<li>Test 1
<ul>
<li>input: putdown <code>(function f A B)</code></li>
<li>output: JSON <code>[&quot;FunctionSignature&quot;,[&quot;FunctionVariable&quot;,&quot;f&quot;],[&quot;SetVariable&quot;,&quot;A&quot;],[&quot;SetVariable&quot;,&quot;B&quot;]]</code></li>
</ul>
</li>
<li>Test 2
<ul>
<li>input: putdown <code>(not (function F (union X Y) Z))</code></li>
<li>output: JSON <code>[&quot;LogicalNegation&quot;,[&quot;FunctionSignature&quot;,[&quot;FunctionVariable&quot;,&quot;F&quot;],[&quot;SetUnion&quot;,[&quot;SetVariable&quot;,&quot;X&quot;],[&quot;SetVariable&quot;,&quot;Y&quot;]],[&quot;SetVariable&quot;,&quot;Z&quot;]]]</code></li>
</ul>
</li>
<li>Test 3
<ul>
<li>input: putdown <code>(function (compose f g) A C)</code></li>
<li>output: JSON <code>[&quot;FunctionSignature&quot;,[&quot;FunctionComposition&quot;,[&quot;FunctionVariable&quot;,&quot;f&quot;],[&quot;FunctionVariable&quot;,&quot;g&quot;]],[&quot;SetVariable&quot;,&quot;A&quot;],[&quot;SetVariable&quot;,&quot;C&quot;]]</code></li>
</ul>
</li>
<li>Test 4
<ul>
<li>input: putdown <code>(apply f x)</code></li>
<li>output: JSON <code>[&quot;NumberFunctionApplication&quot;,[&quot;FunctionVariable&quot;,&quot;f&quot;],[&quot;NumberVariable&quot;,&quot;x&quot;]]</code></li>
</ul>
</li>
<li>Test 5
<ul>
<li>input: putdown <code>(apply (inverse f) (apply (inverse g) 10))</code></li>
<li>output: JSON <code>[&quot;NumberFunctionApplication&quot;,[&quot;FunctionInverse&quot;,[&quot;FunctionVariable&quot;,&quot;f&quot;]],[&quot;NumberFunctionApplication&quot;,[&quot;FunctionInverse&quot;,[&quot;FunctionVariable&quot;,&quot;g&quot;]],[&quot;Number&quot;,&quot;10&quot;]]]</code></li>
</ul>
</li>
<li>Test 6
<ul>
<li>input: putdown <code>(apply E (complement L))</code></li>
<li>output: JSON <code>[&quot;NumberFunctionApplication&quot;,[&quot;FunctionVariable&quot;,&quot;E&quot;],[&quot;SetComplement&quot;,[&quot;SetVariable&quot;,&quot;L&quot;]]]</code></li>
</ul>
</li>
<li>Test 7
<ul>
<li>input: putdown <code>(intersection emptyset (apply f 2))</code></li>
<li>output: JSON <code>[&quot;SetIntersection&quot;,&quot;EmptySet&quot;,[&quot;SetFunctionApplication&quot;,[&quot;FunctionVariable&quot;,&quot;f&quot;],[&quot;Number&quot;,&quot;2&quot;]]]</code></li>
</ul>
</li>
<li>Test 8
<ul>
<li>input: putdown <code>(and (apply P e) (apply Q (+ 3 b)))</code></li>
<li>output: JSON <code>[&quot;Conjunction&quot;,[&quot;PropositionFunctionApplication&quot;,[&quot;FunctionVariable&quot;,&quot;P&quot;],[&quot;NumberVariable&quot;,&quot;e&quot;]],[&quot;PropositionFunctionApplication&quot;,[&quot;FunctionVariable&quot;,&quot;Q&quot;],[&quot;Addition&quot;,[&quot;Number&quot;,&quot;3&quot;],[&quot;NumberVariable&quot;,&quot;b&quot;]]]]</code></li>
</ul>
</li>
<li>Test 9
<ul>
<li>input: putdown <code>(= (apply f x) 3)</code></li>
<li>output: JSON <code>[&quot;Equals&quot;,[&quot;NumberFunctionApplication&quot;,[&quot;FunctionVariable&quot;,&quot;f&quot;],[&quot;NumberVariable&quot;,&quot;x&quot;]],[&quot;Number&quot;,&quot;3&quot;]]</code></li>
</ul>
</li>
<li>Test 10
<ul>
<li>input: putdown <code>(= F (compose G (inverse H)))</code></li>
<li>output: JSON <code>[&quot;EqualFunctions&quot;,[&quot;FunctionVariable&quot;,&quot;F&quot;],[&quot;FunctionComposition&quot;,[&quot;FunctionVariable&quot;,&quot;G&quot;],[&quot;FunctionInverse&quot;,[&quot;FunctionVariable&quot;,&quot;H&quot;]]]]</code></li>
</ul>
</li>
</ul>
<h3>can parse trigonometric functions correctly</h3>
<ul>
<li>Test 1
<ul>
<li>input: putdown <code>(apply sin x)</code></li>
<li>output: JSON <code>[&quot;PrefixFunctionApplication&quot;,&quot;SineFunction&quot;,[&quot;NumberVariable&quot;,&quot;x&quot;]]</code></li>
</ul>
</li>
<li>Test 2
<ul>
<li>input: putdown <code>(apply cos (* pi x))</code></li>
<li>output: JSON <code>[&quot;PrefixFunctionApplication&quot;,&quot;CosineFunction&quot;,[&quot;Multiplication&quot;,&quot;Pi&quot;,[&quot;NumberVariable&quot;,&quot;x&quot;]]]</code></li>
</ul>
</li>
<li>Test 3
<ul>
<li>input: putdown <code>(apply tan t)</code></li>
<li>output: JSON <code>[&quot;PrefixFunctionApplication&quot;,&quot;TangentFunction&quot;,[&quot;NumberVariable&quot;,&quot;t&quot;]]</code></li>
</ul>
</li>
<li>Test 4
<ul>
<li>input: putdown <code>(/ 1 (apply cot pi))</code></li>
<li>output: JSON <code>[&quot;Division&quot;,[&quot;Number&quot;,&quot;1&quot;],[&quot;PrefixFunctionApplication&quot;,&quot;CotangentFunction&quot;,&quot;Pi&quot;]]</code></li>
</ul>
</li>
<li>Test 5
<ul>
<li>input: putdown <code>(= (apply sec y) (apply csc y))</code></li>
<li>output: JSON <code>[&quot;Equals&quot;,[&quot;PrefixFunctionApplication&quot;,&quot;SecantFunction&quot;,[&quot;NumberVariable&quot;,&quot;y&quot;]],[&quot;PrefixFunctionApplication&quot;,&quot;CosecantFunction&quot;,[&quot;NumberVariable&quot;,&quot;y&quot;]]]</code></li>
</ul>
</li>
</ul>
<h3>can parse logarithms correctly</h3>
<ul>
<li>Test 1
<ul>
<li>input: putdown <code>(apply log n)</code></li>
<li>output: JSON <code>[&quot;PrefixFunctionApplication&quot;,&quot;Logarithm&quot;,[&quot;NumberVariable&quot;,&quot;n&quot;]]</code></li>
</ul>
</li>
<li>Test 2
<ul>
<li>input: putdown <code>(+ 1 (apply ln x))</code></li>
<li>output: JSON <code>[&quot;Addition&quot;,[&quot;Number&quot;,&quot;1&quot;],[&quot;PrefixFunctionApplication&quot;,&quot;NaturalLogarithm&quot;,[&quot;NumberVariable&quot;,&quot;x&quot;]]]</code></li>
</ul>
</li>
<li>Test 3
<ul>
<li>input: putdown <code>(apply (logbase 2) 1024)</code></li>
<li>output: JSON <code>[&quot;PrefixFunctionApplication&quot;,[&quot;LogarithmWithBase&quot;,[&quot;Number&quot;,&quot;2&quot;]],[&quot;Number&quot;,&quot;1024&quot;]]</code></li>
</ul>
</li>
<li>Test 4
<ul>
<li>input: putdown <code>(/ (apply log n) (apply log (apply log n)))</code></li>
<li>output: JSON <code>[&quot;Division&quot;,[&quot;PrefixFunctionApplication&quot;,&quot;Logarithm&quot;,[&quot;NumberVariable&quot;,&quot;n&quot;]],[&quot;PrefixFunctionApplication&quot;,&quot;Logarithm&quot;,[&quot;PrefixFunctionApplication&quot;,&quot;Logarithm&quot;,[&quot;NumberVariable&quot;,&quot;n&quot;]]]]</code></li>
</ul>
</li>
</ul>
<h3>can parse equivalence classes and treat them as sets</h3>
<ul>
<li>Test 1
<ul>
<li>input: putdown <code>(equivclass 1 ~~)</code></li>
<li>output: JSON <code>[&quot;EquivalenceClass&quot;,[&quot;Number&quot;,&quot;1&quot;],&quot;ApproximatelyEqual&quot;]</code></li>
</ul>
</li>
<li>Test 2
<ul>
<li>input: putdown <code>(equivclass (+ x 2) ~)</code></li>
<li>output: JSON <code>[&quot;EquivalenceClass&quot;,[&quot;Addition&quot;,[&quot;NumberVariable&quot;,&quot;x&quot;],[&quot;Number&quot;,&quot;2&quot;]],&quot;GenericBinaryRelation&quot;]</code></li>
</ul>
</li>
<li>Test 3
<ul>
<li>input: putdown <code>(union (equivclass 1 ~~) (equivclass 2 ~~))</code></li>
<li>output: JSON <code>[&quot;SetUnion&quot;,[&quot;EquivalenceClass&quot;,[&quot;Number&quot;,&quot;1&quot;],&quot;ApproximatelyEqual&quot;],[&quot;EquivalenceClass&quot;,[&quot;Number&quot;,&quot;2&quot;],&quot;ApproximatelyEqual&quot;]]</code></li>
</ul>
</li>
<li>Test 4
<ul>
<li>input: putdown <code>(in 7 (equivclass 7 ~))</code></li>
<li>output: JSON <code>[&quot;NounIsElement&quot;,[&quot;Number&quot;,&quot;7&quot;],[&quot;EquivalenceClass&quot;,[&quot;Number&quot;,&quot;7&quot;],&quot;GenericBinaryRelation&quot;]]</code></li>
</ul>
</li>
</ul>
<h3>can parse equivalence and classes mod a Number</h3>
<ul>
<li>Test 1
<ul>
<li>input: putdown <code>(=mod 5 11 3)</code></li>
<li>output: JSON <code>[&quot;EquivalentModulo&quot;,[&quot;Number&quot;,&quot;5&quot;],[&quot;Number&quot;,&quot;11&quot;],[&quot;Number&quot;,&quot;3&quot;]]</code></li>
</ul>
</li>
<li>Test 2
<ul>
<li>input: putdown <code>(=mod k m n)</code></li>
<li>output: JSON <code>[&quot;EquivalentModulo&quot;,[&quot;NumberVariable&quot;,&quot;k&quot;],[&quot;NumberVariable&quot;,&quot;m&quot;],[&quot;NumberVariable&quot;,&quot;n&quot;]]</code></li>
</ul>
</li>
<li>Test 3
<ul>
<li>input: putdown <code>(subset emptyset (modclass (- 1) 10))</code></li>
<li>output: JSON <code>[&quot;Subset&quot;,&quot;EmptySet&quot;,[&quot;EquivalenceClassModulo&quot;,[&quot;NumberNegation&quot;,[&quot;Number&quot;,&quot;1&quot;]],[&quot;Number&quot;,&quot;10&quot;]]]</code></li>
</ul>
</li>
</ul>
<h3>can parse type sentences and combinations of them</h3>
<ul>
<li>Test 1
<ul>
<li>input: putdown <code>(hastype x settype)</code></li>
<li>output: JSON <code>[&quot;HasType&quot;,[&quot;NumberVariable&quot;,&quot;x&quot;],&quot;SetType&quot;]</code></li>
</ul>
</li>
<li>Test 2
<ul>
<li>input: putdown <code>(hastype n numbertype)</code></li>
<li>output: JSON <code>[&quot;HasType&quot;,[&quot;NumberVariable&quot;,&quot;n&quot;],&quot;NumberType&quot;]</code></li>
</ul>
</li>
<li>Test 3
<ul>
<li>input: putdown <code>(hastype S partialordertype)</code></li>
<li>output: JSON <code>[&quot;HasType&quot;,[&quot;NumberVariable&quot;,&quot;S&quot;],&quot;PartialOrderType&quot;]</code></li>
</ul>
</li>
<li>Test 4
<ul>
<li>input: putdown <code>(and (hastype 1 numbertype) (hastype 10 numbertype))</code></li>
<li>output: JSON <code>[&quot;Conjunction&quot;,[&quot;HasType&quot;,[&quot;Number&quot;,&quot;1&quot;],&quot;NumberType&quot;],[&quot;HasType&quot;,[&quot;Number&quot;,&quot;10&quot;],&quot;NumberType&quot;]]</code></li>
</ul>
</li>
<li>Test 5
<ul>
<li>input: putdown <code>(implies (hastype R equivalencerelationtype) (hastype R relationtype))</code></li>
<li>output: JSON <code>[&quot;Implication&quot;,[&quot;HasType&quot;,[&quot;NumberVariable&quot;,&quot;R&quot;],&quot;EquivalenceRelationType&quot;],[&quot;HasType&quot;,[&quot;NumberVariable&quot;,&quot;R&quot;],&quot;RelationType&quot;]]</code></li>
</ul>
</li>
</ul>
<h3>can parse notation for expression function application</h3>
<ul>
<li>Test 1
<ul>
<li>input: putdown <code>(efa f x)</code></li>
<li>output: JSON <code>[&quot;NumberEFA&quot;,[&quot;FunctionVariable&quot;,&quot;f&quot;],[&quot;NumberVariable&quot;,&quot;x&quot;]]</code></li>
</ul>
</li>
<li>Test 2
<ul>
<li>input: putdown <code>(apply F (efa k 10))</code></li>
<li>output: JSON <code>[&quot;NumberFunctionApplication&quot;,[&quot;FunctionVariable&quot;,&quot;F&quot;],[&quot;NumberEFA&quot;,[&quot;FunctionVariable&quot;,&quot;k&quot;],[&quot;Number&quot;,&quot;10&quot;]]]</code></li>
</ul>
</li>
<li>Test 3
<ul>
<li>input: putdown <code>(efa E (complement L))</code></li>
<li>output: JSON <code>[&quot;NumberEFA&quot;,[&quot;FunctionVariable&quot;,&quot;E&quot;],[&quot;SetComplement&quot;,[&quot;SetVariable&quot;,&quot;L&quot;]]]</code></li>
</ul>
</li>
<li>Test 4
<ul>
<li>input: putdown <code>(intersection emptyset (efa f 2))</code></li>
<li>output: JSON <code>[&quot;SetIntersection&quot;,&quot;EmptySet&quot;,[&quot;SetEFA&quot;,[&quot;FunctionVariable&quot;,&quot;f&quot;],[&quot;Number&quot;,&quot;2&quot;]]]</code></li>
</ul>
</li>
<li>Test 5
<ul>
<li>input: putdown <code>(and (efa P x) (efa Q y))</code></li>
<li>output: JSON <code>[&quot;Conjunction&quot;,[&quot;PropositionEFA&quot;,[&quot;FunctionVariable&quot;,&quot;P&quot;],[&quot;NumberVariable&quot;,&quot;x&quot;]],[&quot;PropositionEFA&quot;,[&quot;FunctionVariable&quot;,&quot;Q&quot;],[&quot;NumberVariable&quot;,&quot;y&quot;]]]</code></li>
</ul>
</li>
</ul>
<h3>can parse notation for assumptions</h3>
<ul>
<li>Test 1
<ul>
<li>input: putdown <code>:X</code></li>
<li>output: JSON <code>[&quot;Given_Variant1&quot;,[&quot;LogicVariable&quot;,&quot;X&quot;]]</code></li>
</ul>
</li>
<li>Test 2
<ul>
<li>input: putdown <code>:(= k 1000)</code></li>
<li>output: JSON <code>[&quot;Given_Variant1&quot;,[&quot;Equals&quot;,[&quot;NumberVariable&quot;,&quot;k&quot;],[&quot;Number&quot;,&quot;1000&quot;]]]</code></li>
</ul>
</li>
<li>Test 3
<ul>
<li>input: putdown <code>:true</code></li>
<li>output: JSON <code>[&quot;Given_Variant1&quot;,&quot;LogicalTrue&quot;]</code></li>
</ul>
</li>
<li>Test 4
<ul>
<li>input: putdown <code>:50</code></li>
<li>output: JSON <code>null</code></li>
</ul>
</li>
<li>Test 5
<ul>
<li>input: putdown <code>:(tuple (elts 5 (elts 6)))</code></li>
<li>output: JSON <code>null</code></li>
</ul>
</li>
<li>Test 6
<ul>
<li>input: putdown <code>:(compose f g)</code></li>
<li>output: JSON <code>null</code></li>
</ul>
</li>
<li>Test 7
<ul>
<li>input: putdown <code>:emptyset</code></li>
<li>output: JSON <code>null</code></li>
</ul>
</li>
<li>Test 8
<ul>
<li>input: putdown <code>:infinity</code></li>
<li>output: JSON <code>null</code></li>
</ul>
</li>
</ul>
<h3>can parse notation for Let-style declarations</h3>
<ul>
<li>Test 1
<ul>
<li>input: putdown <code>:[x]</code></li>
<li>output: JSON <code>[&quot;Let_Variant1&quot;,[&quot;NumberVariable&quot;,&quot;x&quot;]]</code></li>
</ul>
</li>
<li>Test 2
<ul>
<li>input: putdown <code>:[T]</code></li>
<li>output: JSON <code>[&quot;Let_Variant1&quot;,[&quot;NumberVariable&quot;,&quot;T&quot;]]</code></li>
</ul>
</li>
<li>Test 3
<ul>
<li>input: putdown <code>:[x , (&gt; x 0)]</code></li>
<li>output: JSON <code>[&quot;LetBeSuchThat_Variant1&quot;,[&quot;NumberVariable&quot;,&quot;x&quot;],[&quot;GreaterThan&quot;,[&quot;NumberVariable&quot;,&quot;x&quot;],[&quot;Number&quot;,&quot;0&quot;]]]</code></li>
</ul>
</li>
<li>Test 4
<ul>
<li>input: putdown <code>:[T , (or (= T 5) (in T S))]</code></li>
<li>output: JSON <code>[&quot;LetBeSuchThat_Variant1&quot;,[&quot;NumberVariable&quot;,&quot;T&quot;],[&quot;Disjunction&quot;,[&quot;Equals&quot;,[&quot;NumberVariable&quot;,&quot;T&quot;],[&quot;Number&quot;,&quot;5&quot;]],[&quot;NounIsElement&quot;,[&quot;NumberVariable&quot;,&quot;T&quot;],[&quot;SetVariable&quot;,&quot;S&quot;]]]]</code></li>
</ul>
</li>
<li>Test 5
<ul>
<li>input: putdown <code>:[(&gt; x 5)]</code></li>
<li>output: JSON <code>null</code></li>
</ul>
</li>
<li>Test 6
<ul>
<li>input: putdown <code>:[(= 1 1)]</code></li>
<li>output: JSON <code>null</code></li>
</ul>
</li>
<li>Test 7
<ul>
<li>input: putdown <code>:[emptyset]</code></li>
<li>output: JSON <code>null</code></li>
</ul>
</li>
<li>Test 8
<ul>
<li>input: putdown <code>:[x , 1]</code></li>
<li>output: JSON <code>null</code></li>
</ul>
</li>
<li>Test 9
<ul>
<li>input: putdown <code>:[x , (or 1 2)]</code></li>
<li>output: JSON <code>null</code></li>
</ul>
</li>
<li>Test 10
<ul>
<li>input: putdown <code>:[x , [y]]</code></li>
<li>output: JSON <code>null</code></li>
</ul>
</li>
<li>Test 11
<ul>
<li>input: putdown <code>:[x , :B]</code></li>
<li>output: JSON <code>null</code></li>
</ul>
</li>
</ul>
<h3>can parse notation for For Some-style declarations</h3>
<ul>
<li>Test 1
<ul>
<li>input: putdown <code>[x , (&gt; x 0)]</code></li>
<li>output: JSON <code>[&quot;ForSome_Variant1&quot;,[&quot;NumberVariable&quot;,&quot;x&quot;],[&quot;GreaterThan&quot;,[&quot;NumberVariable&quot;,&quot;x&quot;],[&quot;Number&quot;,&quot;0&quot;]]]</code></li>
</ul>
</li>
<li>Test 2
<ul>
<li>input: putdown <code>[T , (or (= T 5) (in T S))]</code></li>
<li>output: JSON <code>[&quot;ForSome_Variant1&quot;,[&quot;NumberVariable&quot;,&quot;T&quot;],[&quot;Disjunction&quot;,[&quot;Equals&quot;,[&quot;NumberVariable&quot;,&quot;T&quot;],[&quot;Number&quot;,&quot;5&quot;]],[&quot;NounIsElement&quot;,[&quot;NumberVariable&quot;,&quot;T&quot;],[&quot;SetVariable&quot;,&quot;S&quot;]]]]</code></li>
</ul>
</li>
<li>Test 3
<ul>
<li>input: putdown <code>[x]</code></li>
<li>output: JSON <code>null</code></li>
</ul>
</li>
<li>Test 4
<ul>
<li>input: putdown <code>[T]</code></li>
<li>output: JSON <code>null</code></li>
</ul>
</li>
<li>Test 5
<ul>
<li>input: putdown <code>[(&gt; x 5)]</code></li>
<li>output: JSON <code>null</code></li>
</ul>
</li>
<li>Test 6
<ul>
<li>input: putdown <code>[(= 1 1)]</code></li>
<li>output: JSON <code>null</code></li>
</ul>
</li>
<li>Test 7
<ul>
<li>input: putdown <code>[emptyset]</code></li>
<li>output: JSON <code>null</code></li>
</ul>
</li>
<li>Test 8
<ul>
<li>input: putdown <code>[x , 1]</code></li>
<li>output: JSON <code>null</code></li>
</ul>
</li>
<li>Test 9
<ul>
<li>input: putdown <code>[x , (or 1 2)]</code></li>
<li>output: JSON <code>null</code></li>
</ul>
</li>
<li>Test 10
<ul>
<li>input: putdown <code>[x , [y]]</code></li>
<li>output: JSON <code>null</code></li>
</ul>
</li>
<li>Test 11
<ul>
<li>input: putdown <code>[x , :B]</code></li>
<li>output: JSON <code>null</code></li>
</ul>
</li>
</ul>
<h2><a name="Rendering-JSON-into-putdown">Rendering JSON into putdown</a></h2>
<h3>can convert JSON numbers to putdown</h3>
<ul>
<li>Test 1
<ul>
<li>input: JSON <code>[&quot;Number&quot;,&quot;0&quot;]</code></li>
<li>output: putdown <code>0</code></li>
</ul>
</li>
<li>Test 2
<ul>
<li>input: JSON <code>[&quot;Number&quot;,&quot;453789&quot;]</code></li>
<li>output: putdown <code>453789</code></li>
</ul>
</li>
<li>Test 3
<ul>
<li>input: JSON <code>[&quot;Number&quot;,&quot;99999999999999999999999999999999999999999&quot;]</code></li>
<li>output: putdown <code>99999999999999999999999999999999999999999</code></li>
</ul>
</li>
<li>Test 4
<ul>
<li>input: JSON <code>[&quot;NumberNegation&quot;,[&quot;Number&quot;,&quot;453789&quot;]]</code></li>
<li>output: putdown <code>(- 453789)</code></li>
</ul>
</li>
<li>Test 5
<ul>
<li>input: JSON <code>[&quot;NumberNegation&quot;,[&quot;Number&quot;,&quot;99999999999999999999999999999999999999999&quot;]]</code></li>
<li>output: putdown <code>(- 99999999999999999999999999999999999999999)</code></li>
</ul>
</li>
<li>Test 6
<ul>
<li>input: JSON <code>[&quot;Number&quot;,&quot;0.0&quot;]</code></li>
<li>output: putdown <code>0.0</code></li>
</ul>
</li>
<li>Test 7
<ul>
<li>input: JSON <code>[&quot;Number&quot;,&quot;29835.6875940&quot;]</code></li>
<li>output: putdown <code>29835.6875940</code></li>
</ul>
</li>
<li>Test 8
<ul>
<li>input: JSON <code>[&quot;Number&quot;,&quot;653280458689.&quot;]</code></li>
<li>output: putdown <code>653280458689.</code></li>
</ul>
</li>
<li>Test 9
<ul>
<li>input: JSON <code>[&quot;Number&quot;,&quot;.000006327589&quot;]</code></li>
<li>output: putdown <code>.000006327589</code></li>
</ul>
</li>
<li>Test 10
<ul>
<li>input: JSON <code>[&quot;NumberNegation&quot;,[&quot;Number&quot;,&quot;29835.6875940&quot;]]</code></li>
<li>output: putdown <code>(- 29835.6875940)</code></li>
</ul>
</li>
<li>Test 11
<ul>
<li>input: JSON <code>[&quot;NumberNegation&quot;,[&quot;Number&quot;,&quot;653280458689.&quot;]]</code></li>
<li>output: putdown <code>(- 653280458689.)</code></li>
</ul>
</li>
<li>Test 12
<ul>
<li>input: JSON <code>[&quot;NumberNegation&quot;,[&quot;Number&quot;,&quot;.000006327589&quot;]]</code></li>
<li>output: putdown <code>(- .000006327589)</code></li>
</ul>
</li>
</ul>
<h3>can convert any size variable name from JSON to putdown</h3>
<ul>
<li>Test 1
<ul>
<li>input: JSON <code>[&quot;NumberVariable&quot;,&quot;x&quot;]</code></li>
<li>output: putdown <code>x</code></li>
</ul>
</li>
<li>Test 2
<ul>
<li>input: JSON <code>[&quot;NumberVariable&quot;,&quot;E&quot;]</code></li>
<li>output: putdown <code>E</code></li>
</ul>
</li>
<li>Test 3
<ul>
<li>input: JSON <code>[&quot;NumberVariable&quot;,&quot;q&quot;]</code></li>
<li>output: putdown <code>q</code></li>
</ul>
</li>
<li>Test 4
<ul>
<li>input: JSON <code>[&quot;NumberVariable&quot;,&quot;foo&quot;]</code></li>
<li>output: putdown <code>foo</code></li>
</ul>
</li>
<li>Test 5
<ul>
<li>input: JSON <code>[&quot;NumberVariable&quot;,&quot;bar&quot;]</code></li>
<li>output: putdown <code>bar</code></li>
</ul>
</li>
<li>Test 6
<ul>
<li>input: JSON <code>[&quot;NumberVariable&quot;,&quot;to&quot;]</code></li>
<li>output: putdown <code>to</code></li>
</ul>
</li>
</ul>
<h3>can convert numeric constants from JSON to putdown</h3>
<ul>
<li>Test 1
<ul>
<li>input: JSON <code>&quot;Infinity&quot;</code></li>
<li>output: putdown <code>infinity</code></li>
</ul>
</li>
<li>Test 2
<ul>
<li>input: JSON <code>&quot;Pi&quot;</code></li>
<li>output: putdown <code>pi</code></li>
</ul>
</li>
<li>Test 3
<ul>
<li>input: JSON <code>&quot;EulersNumber&quot;</code></li>
<li>output: putdown <code>eulersnumber</code></li>
</ul>
</li>
</ul>
<h3>can convert exponentiation of atomics to putdown</h3>
<ul>
<li>Test 1
<ul>
<li>input: JSON <code>[&quot;Exponentiation&quot;,[&quot;Number&quot;,&quot;1&quot;],[&quot;Number&quot;,&quot;2&quot;]]</code></li>
<li>output: putdown <code>(^ 1 2)</code></li>
</ul>
</li>
<li>Test 2
<ul>
<li>input: JSON <code>[&quot;Exponentiation&quot;,[&quot;NumberVariable&quot;,&quot;e&quot;],[&quot;NumberVariable&quot;,&quot;x&quot;]]</code></li>
<li>output: putdown <code>(^ e x)</code></li>
</ul>
</li>
<li>Test 3
<ul>
<li>input: JSON <code>[&quot;Exponentiation&quot;,[&quot;Number&quot;,&quot;1&quot;],&quot;Infinity&quot;]</code></li>
<li>output: putdown <code>(^ 1 infinity)</code></li>
</ul>
</li>
</ul>
<h3>can convert atomic percentages and factorials to putdown</h3>
<ul>
<li>Test 1
<ul>
<li>input: JSON <code>[&quot;Percentage&quot;,[&quot;Number&quot;,&quot;10&quot;]]</code></li>
<li>output: putdown <code>(% 10)</code></li>
</ul>
</li>
<li>Test 2
<ul>
<li>input: JSON <code>[&quot;Percentage&quot;,[&quot;NumberVariable&quot;,&quot;t&quot;]]</code></li>
<li>output: putdown <code>(% t)</code></li>
</ul>
</li>
<li>Test 3
<ul>
<li>input: JSON <code>[&quot;Factorial&quot;,[&quot;Number&quot;,&quot;100&quot;]]</code></li>
<li>output: putdown <code>(! 100)</code></li>
</ul>
</li>
<li>Test 4
<ul>
<li>input: JSON <code>[&quot;Factorial&quot;,[&quot;NumberVariable&quot;,&quot;J&quot;]]</code></li>
<li>output: putdown <code>(! J)</code></li>
</ul>
</li>
</ul>
<h3>can convert division of atomics or factors to putdown</h3>
<ul>
<li>Test 1
<ul>
<li>input: JSON <code>[&quot;Division&quot;,[&quot;Number&quot;,&quot;1&quot;],[&quot;Number&quot;,&quot;2&quot;]]</code></li>
<li>output: putdown <code>(/ 1 2)</code></li>
</ul>
</li>
<li>Test 2
<ul>
<li>input: JSON <code>[&quot;Division&quot;,[&quot;NumberVariable&quot;,&quot;x&quot;],[&quot;NumberVariable&quot;,&quot;y&quot;]]</code></li>
<li>output: putdown <code>(/ x y)</code></li>
</ul>
</li>
<li>Test 3
<ul>
<li>input: JSON <code>[&quot;Division&quot;,[&quot;Number&quot;,&quot;0&quot;],&quot;Infinity&quot;]</code></li>
<li>output: putdown <code>(/ 0 infinity)</code></li>
</ul>
</li>
<li>Test 4
<ul>
<li>input: JSON <code>[&quot;Division&quot;,[&quot;Exponentiation&quot;,[&quot;NumberVariable&quot;,&quot;x&quot;],[&quot;Number&quot;,&quot;2&quot;]],[&quot;Number&quot;,&quot;3&quot;]]</code></li>
<li>output: putdown <code>(/ (^ x 2) 3)</code></li>
</ul>
</li>
<li>Test 5
<ul>
<li>input: JSON <code>[&quot;Division&quot;,[&quot;Number&quot;,&quot;1&quot;],[&quot;Exponentiation&quot;,[&quot;NumberVariable&quot;,&quot;e&quot;],[&quot;NumberVariable&quot;,&quot;x&quot;]]]</code></li>
<li>output: putdown <code>(/ 1 (^ e x))</code></li>
</ul>
</li>
<li>Test 6
<ul>
<li>input: JSON <code>[&quot;Division&quot;,[&quot;Percentage&quot;,[&quot;Number&quot;,&quot;10&quot;]],[&quot;Exponentiation&quot;,[&quot;Number&quot;,&quot;2&quot;],[&quot;Number&quot;,&quot;100&quot;]]]</code></li>
<li>output: putdown <code>(/ (% 10) (^ 2 100))</code></li>
</ul>
</li>
</ul>
<h3>can convert multiplication of atomics or factors to putdown</h3>
<ul>
<li>Test 1
<ul>
<li>input: JSON <code>[&quot;Multiplication&quot;,[&quot;Number&quot;,&quot;1&quot;],[&quot;Number&quot;,&quot;2&quot;]]</code></li>
<li>output: putdown <code>(* 1 2)</code></li>
</ul>
</li>
<li>Test 2
<ul>
<li>input: JSON <code>[&quot;Multiplication&quot;,[&quot;NumberVariable&quot;,&quot;x&quot;],[&quot;NumberVariable&quot;,&quot;y&quot;]]</code></li>
<li>output: putdown <code>(* x y)</code></li>
</ul>
</li>
<li>Test 3
<ul>
<li>input: JSON <code>[&quot;Multiplication&quot;,[&quot;Number&quot;,&quot;0&quot;],&quot;Infinity&quot;]</code></li>
<li>output: putdown <code>(* 0 infinity)</code></li>
</ul>
</li>
<li>Test 4
<ul>
<li>input: JSON <code>[&quot;Multiplication&quot;,[&quot;Exponentiation&quot;,[&quot;NumberVariable&quot;,&quot;x&quot;],[&quot;Number&quot;,&quot;2&quot;]],[&quot;Number&quot;,&quot;3&quot;]]</code></li>
<li>output: putdown <code>(* (^ x 2) 3)</code></li>
</ul>
</li>
<li>Test 5
<ul>
<li>input: JSON <code>[&quot;Multiplication&quot;,[&quot;Number&quot;,&quot;1&quot;],[&quot;Exponentiation&quot;,[&quot;NumberVariable&quot;,&quot;e&quot;],[&quot;NumberVariable&quot;,&quot;x&quot;]]]</code></li>
<li>output: putdown <code>(* 1 (^ e x))</code></li>
</ul>
</li>
<li>Test 6
<ul>
<li>input: JSON <code>[&quot;Multiplication&quot;,[&quot;Percentage&quot;,[&quot;Number&quot;,&quot;10&quot;]],[&quot;Exponentiation&quot;,[&quot;Number&quot;,&quot;2&quot;],[&quot;Number&quot;,&quot;100&quot;]]]</code></li>
<li>output: putdown <code>(* (% 10) (^ 2 100))</code></li>
</ul>
</li>
</ul>
<h3>can convert negations of atomics or factors to putdown</h3>
<ul>
<li>Test 1
<ul>
<li>input: JSON <code>[&quot;Multiplication&quot;,[&quot;NumberNegation&quot;,[&quot;Number&quot;,&quot;1&quot;]],[&quot;Number&quot;,&quot;2&quot;]]</code></li>
<li>output: putdown <code>(* (- 1) 2)</code></li>
</ul>
</li>
<li>Test 2
<ul>
<li>input: JSON <code>[&quot;Multiplication&quot;,[&quot;NumberVariable&quot;,&quot;x&quot;],[&quot;NumberNegation&quot;,[&quot;NumberVariable&quot;,&quot;y&quot;]]]</code></li>
<li>output: putdown <code>(* x (- y))</code></li>
</ul>
</li>
<li>Test 3
<ul>
<li>input: JSON <code>[&quot;Multiplication&quot;,[&quot;NumberNegation&quot;,[&quot;Exponentiation&quot;,[&quot;NumberVariable&quot;,&quot;x&quot;],[&quot;Number&quot;,&quot;2&quot;]]],[&quot;NumberNegation&quot;,[&quot;Number&quot;,&quot;3&quot;]]]</code></li>
<li>output: putdown <code>(* (- (^ x 2)) (- 3))</code></li>
</ul>
</li>
<li>Test 4
<ul>
<li>input: JSON <code>[&quot;NumberNegation&quot;,[&quot;NumberNegation&quot;,[&quot;NumberNegation&quot;,[&quot;NumberNegation&quot;,[&quot;Number&quot;,&quot;1000&quot;]]]]]</code></li>
<li>output: putdown <code>(- (- (- (- 1000))))</code></li>
</ul>
</li>
</ul>
<h3>can convert additions and subtractions to putdown</h3>
<ul>
<li>Test 1
<ul>
<li>input: JSON <code>[&quot;Addition&quot;,[&quot;NumberVariable&quot;,&quot;x&quot;],[&quot;NumberVariable&quot;,&quot;y&quot;]]</code></li>
<li>output: putdown <code>(+ x y)</code></li>
</ul>
</li>
<li>Test 2
<ul>
<li>input: JSON <code>[&quot;Subtraction&quot;,[&quot;Number&quot;,&quot;1&quot;],[&quot;NumberNegation&quot;,[&quot;Number&quot;,&quot;3&quot;]]]</code></li>
<li>output: putdown <code>(- 1 (- 3))</code></li>
</ul>
</li>
<li>Test 3
<ul>
<li>input: JSON <code>[&quot;Addition&quot;,[&quot;Exponentiation&quot;,[&quot;NumberVariable&quot;,&quot;A&quot;],[&quot;NumberVariable&quot;,&quot;B&quot;]],[&quot;Subtraction&quot;,[&quot;NumberVariable&quot;,&quot;C&quot;],&quot;Pi&quot;]]</code></li>
<li>output: putdown <code>(+ (^ A B) (- C pi))</code></li>
</ul>
</li>
</ul>
<h3>can convert number expressions with groupers to putdown</h3>
<ul>
<li>Test 1
<ul>
<li>input: JSON <code>[&quot;NumberNegation&quot;,[&quot;Multiplication&quot;,[&quot;Number&quot;,&quot;1&quot;],[&quot;Number&quot;,&quot;2&quot;]]]</code></li>
<li>output: putdown <code>(- (* 1 2))</code></li>
</ul>
</li>
<li>Test 2
<ul>
<li>input: JSON <code>[&quot;Factorial&quot;,[&quot;Exponentiation&quot;,[&quot;NumberVariable&quot;,&quot;x&quot;],[&quot;Number&quot;,&quot;2&quot;]]]</code></li>
<li>output: putdown <code>(! (^ x 2))</code></li>
</ul>
</li>
<li>Test 3
<ul>
<li>input: JSON <code>[&quot;Exponentiation&quot;,[&quot;NumberNegation&quot;,[&quot;NumberVariable&quot;,&quot;x&quot;]],[&quot;Multiplication&quot;,[&quot;Number&quot;,&quot;2&quot;],[&quot;NumberNegation&quot;,[&quot;Number&quot;,&quot;3&quot;]]]]</code></li>
<li>output: putdown <code>(^ (- x) (* 2 (- 3)))</code></li>
</ul>
</li>
<li>Test 4
<ul>
<li>input: JSON <code>[&quot;Exponentiation&quot;,[&quot;NumberNegation&quot;,[&quot;Number&quot;,&quot;3&quot;]],[&quot;Addition&quot;,[&quot;Number&quot;,&quot;1&quot;],[&quot;Number&quot;,&quot;2&quot;]]]</code></li>
<li>output: putdown <code>(^ (- 3) (+ 1 2))</code></li>
</ul>
</li>
</ul>
<h3>can convert relations of numeric expressions to putdown</h3>
<ul>
<li>Test 1
<ul>
<li>input: JSON <code>[&quot;GreaterThan&quot;,[&quot;Number&quot;,&quot;1&quot;],[&quot;Number&quot;,&quot;2&quot;]]</code></li>
<li>output: putdown <code>(&gt; 1 2)</code></li>
</ul>
</li>
<li>Test 2
<ul>
<li>input: JSON <code>[&quot;LessThan&quot;,[&quot;Subtraction&quot;,[&quot;Number&quot;,&quot;1&quot;],[&quot;Number&quot;,&quot;2&quot;]],[&quot;Addition&quot;,[&quot;Number&quot;,&quot;1&quot;],[&quot;Number&quot;,&quot;2&quot;]]]</code></li>
<li>output: putdown <code>(&lt; (- 1 2) (+ 1 2))</code></li>
</ul>
</li>
<li>Test 3
<ul>
<li>input: JSON <code>[&quot;LogicalNegation&quot;,[&quot;Equals&quot;,[&quot;Number&quot;,&quot;1&quot;],[&quot;Number&quot;,&quot;2&quot;]]]</code></li>
<li>output: putdown <code>(not (= 1 2))</code></li>
</ul>
</li>
<li>Test 4
<ul>
<li>input: JSON <code>[&quot;Conjunction&quot;,[&quot;GreaterThanOrEqual&quot;,[&quot;Number&quot;,&quot;2&quot;],[&quot;Number&quot;,&quot;1&quot;]],[&quot;LessThanOrEqual&quot;,[&quot;Number&quot;,&quot;2&quot;],[&quot;Number&quot;,&quot;3&quot;]]]</code></li>
<li>output: putdown <code>(and (&gt;= 2 1) (&lt;= 2 3))</code></li>
</ul>
</li>
<li>Test 5
<ul>
<li>input: JSON <code>[&quot;BinaryRelationHolds&quot;,&quot;Divides&quot;,[&quot;Number&quot;,&quot;7&quot;],[&quot;Number&quot;,&quot;14&quot;]]</code></li>
<li>output: putdown <code>(relationholds | 7 14)</code></li>
</ul>
</li>
<li>Test 6
<ul>
<li>input: JSON <code>[&quot;BinaryRelationHolds&quot;,&quot;Divides&quot;,[&quot;NumberFunctionApplication&quot;,[&quot;FunctionVariable&quot;,&quot;A&quot;],[&quot;NumberVariable&quot;,&quot;k&quot;]],[&quot;Factorial&quot;,[&quot;NumberVariable&quot;,&quot;n&quot;]]]</code></li>
<li>output: putdown <code>(relationholds | (apply A k) (! n))</code></li>
</ul>
</li>
<li>Test 7
<ul>
<li>input: JSON <code>[&quot;BinaryRelationHolds&quot;,&quot;GenericBinaryRelation&quot;,[&quot;Subtraction&quot;,[&quot;Number&quot;,&quot;1&quot;],[&quot;NumberVariable&quot;,&quot;k&quot;]],[&quot;Addition&quot;,[&quot;Number&quot;,&quot;1&quot;],[&quot;NumberVariable&quot;,&quot;k&quot;]]]</code></li>
<li>output: putdown <code>(relationholds ~ (- 1 k) (+ 1 k))</code></li>
</ul>
</li>
<li>Test 8
<ul>
<li>input: JSON <code>[&quot;BinaryRelationHolds&quot;,&quot;ApproximatelyEqual&quot;,[&quot;Number&quot;,&quot;0.99&quot;],[&quot;Number&quot;,&quot;1.01&quot;]]</code></li>
<li>output: putdown <code>(relationholds ~~ 0.99 1.01)</code></li>
</ul>
</li>
</ul>
<h3>creates the canonical form for inequality</h3>
<ul>
<li>Test 1
<ul>
<li>input: JSON <code>[&quot;NotEqual&quot;,[&quot;FunctionVariable&quot;,&quot;f&quot;],[&quot;FunctionVariable&quot;,&quot;g&quot;]]</code></li>
<li>output: putdown <code>(not (= f g))</code></li>
</ul>
</li>
</ul>
<h3>can convert propositional logic atomics to putdown</h3>
<ul>
<li>Test 1
<ul>
<li>input: JSON <code>&quot;LogicalTrue&quot;</code></li>
<li>output: putdown <code>true</code></li>
</ul>
</li>
<li>Test 2
<ul>
<li>input: JSON <code>&quot;LogicalFalse&quot;</code></li>
<li>output: putdown <code>false</code></li>
</ul>
</li>
<li>Test 3
<ul>
<li>input: JSON <code>&quot;Contradiction&quot;</code></li>
<li>output: putdown <code>contradiction</code></li>
</ul>
</li>
<li>Test 4
<ul>
<li>input: JSON <code>[&quot;LogicVariable&quot;,&quot;P&quot;]</code></li>
<li>output: putdown <code>P</code></li>
</ul>
</li>
<li>Test 5
<ul>
<li>input: JSON <code>[&quot;LogicVariable&quot;,&quot;a&quot;]</code></li>
<li>output: putdown <code>a</code></li>
</ul>
</li>
<li>Test 6
<ul>
<li>input: JSON <code>[&quot;LogicVariable&quot;,&quot;somethingLarge&quot;]</code></li>
<li>output: putdown <code>somethingLarge</code></li>
</ul>
</li>
</ul>
<h3>can convert propositional logic conjuncts to putdown</h3>
<ul>
<li>Test 1
<ul>
<li>input: JSON <code>[&quot;Conjunction&quot;,&quot;LogicalTrue&quot;,&quot;LogicalFalse&quot;]</code></li>
<li>output: putdown <code>(and true false)</code></li>
</ul>
</li>
<li>Test 2
<ul>
<li>input: JSON <code>[&quot;Conjunction&quot;,[&quot;LogicalNegation&quot;,[&quot;LogicVariable&quot;,&quot;P&quot;]],[&quot;LogicalNegation&quot;,&quot;LogicalTrue&quot;]]</code></li>
<li>output: putdown <code>(and (not P) (not true))</code></li>
</ul>
</li>
<li>Test 3
<ul>
<li>input: JSON <code>[&quot;Conjunction&quot;,[&quot;Conjunction&quot;,[&quot;LogicVariable&quot;,&quot;a&quot;],[&quot;LogicVariable&quot;,&quot;b&quot;]],[&quot;LogicVariable&quot;,&quot;c&quot;]]</code></li>
<li>output: putdown <code>(and (and a b) c)</code></li>
</ul>
</li>
</ul>
<h3>can convert propositional logic disjuncts to putdown</h3>
<ul>
<li>Test 1
<ul>
<li>input: JSON <code>[&quot;Disjunction&quot;,&quot;LogicalTrue&quot;,[&quot;LogicalNegation&quot;,[&quot;LogicVariable&quot;,&quot;A&quot;]]]</code></li>
<li>output: putdown <code>(or true (not A))</code></li>
</ul>
</li>
<li>Test 2
<ul>
<li>input: JSON <code>[&quot;Disjunction&quot;,[&quot;Conjunction&quot;,[&quot;LogicVariable&quot;,&quot;P&quot;],[&quot;LogicVariable&quot;,&quot;Q&quot;]],[&quot;Conjunction&quot;,[&quot;LogicVariable&quot;,&quot;Q&quot;],[&quot;LogicVariable&quot;,&quot;P&quot;]]]</code></li>
<li>output: putdown <code>(or (and P Q) (and Q P))</code></li>
</ul>
</li>
</ul>
<h3>can convert propositional logic conditionals to putdown</h3>
<ul>
<li>Test 1
<ul>
<li>input: JSON <code>[&quot;Implication&quot;,[&quot;LogicVariable&quot;,&quot;A&quot;],[&quot;Conjunction&quot;,[&quot;LogicVariable&quot;,&quot;Q&quot;],[&quot;LogicalNegation&quot;,[&quot;LogicVariable&quot;,&quot;P&quot;]]]]</code></li>
<li>output: putdown <code>(implies A (and Q (not P)))</code></li>
</ul>
</li>
<li>Test 2
<ul>
<li>input: JSON <code>[&quot;Implication&quot;,[&quot;Implication&quot;,[&quot;Disjunction&quot;,[&quot;LogicVariable&quot;,&quot;P&quot;],[&quot;LogicVariable&quot;,&quot;Q&quot;]],[&quot;Conjunction&quot;,[&quot;LogicVariable&quot;,&quot;Q&quot;],[&quot;LogicVariable&quot;,&quot;P&quot;]]],[&quot;LogicVariable&quot;,&quot;T&quot;]]</code></li>
<li>output: putdown <code>(implies (implies (or P Q) (and Q P)) T)</code></li>
</ul>
</li>
</ul>
<h3>can convert propositional logic biconditionals to putdown</h3>
<ul>
<li>Test 1
<ul>
<li>input: JSON <code>[&quot;LogicalEquivalence&quot;,[&quot;LogicVariable&quot;,&quot;A&quot;],[&quot;Conjunction&quot;,[&quot;LogicVariable&quot;,&quot;Q&quot;],[&quot;LogicalNegation&quot;,[&quot;LogicVariable&quot;,&quot;P&quot;]]]]</code></li>
<li>output: putdown <code>(iff A (and Q (not P)))</code></li>
</ul>
</li>
<li>Test 2
<ul>
<li>input: JSON <code>[&quot;Implication&quot;,[&quot;LogicalEquivalence&quot;,[&quot;Disjunction&quot;,[&quot;LogicVariable&quot;,&quot;P&quot;],[&quot;LogicVariable&quot;,&quot;Q&quot;]],[&quot;Conjunction&quot;,[&quot;LogicVariable&quot;,&quot;Q&quot;],[&quot;LogicVariable&quot;,&quot;P&quot;]]],[&quot;LogicVariable&quot;,&quot;T&quot;]]</code></li>
<li>output: putdown <code>(implies (iff (or P Q) (and Q P)) T)</code></li>
</ul>
</li>
</ul>
<h3>can convert propositional expressions with groupers to putdown</h3>
<ul>
<li>Test 1
<ul>
<li>input: JSON <code>[&quot;Disjunction&quot;,[&quot;LogicVariable&quot;,&quot;P&quot;],[&quot;Conjunction&quot;,[&quot;LogicalEquivalence&quot;,[&quot;LogicVariable&quot;,&quot;Q&quot;],[&quot;LogicVariable&quot;,&quot;Q&quot;]],[&quot;LogicVariable&quot;,&quot;P&quot;]]]</code></li>
<li>output: putdown <code>(or P (and (iff Q Q) P))</code></li>
</ul>
</li>
<li>Test 2
<ul>
<li>input: JSON <code>[&quot;LogicalNegation&quot;,[&quot;LogicalEquivalence&quot;,&quot;LogicalTrue&quot;,&quot;LogicalFalse&quot;]]</code></li>
<li>output: putdown <code>(not (iff true false))</code></li>
</ul>
</li>
</ul>
<h3>can convert simple predicate logic expressions to putdown</h3>
<ul>
<li>Test 1
<ul>
<li>input: JSON <code>[&quot;UniversalQuantifier&quot;,[&quot;NumberVariable&quot;,&quot;x&quot;],[&quot;LogicVariable&quot;,&quot;P&quot;]]</code></li>
<li>output: putdown <code>(forall (x , P))</code></li>
</ul>
</li>
<li>Test 2
<ul>
<li>input: JSON <code>[&quot;ExistentialQuantifier&quot;,[&quot;NumberVariable&quot;,&quot;t&quot;],[&quot;LogicalNegation&quot;,[&quot;LogicVariable&quot;,&quot;Q&quot;]]]</code></li>
<li>output: putdown <code>(exists (t , (not Q)))</code></li>
</ul>
</li>
<li>Test 3
<ul>
<li>input: JSON <code>[&quot;UniqueExistentialQuantifier&quot;,[&quot;NumberVariable&quot;,&quot;k&quot;],[&quot;Implication&quot;,[&quot;LogicVariable&quot;,&quot;m&quot;],[&quot;LogicVariable&quot;,&quot;n&quot;]]]</code></li>
<li>output: putdown <code>(exists! (k , (implies m n)))</code></li>
</ul>
</li>
</ul>
<h3>can convert finite and empty sets to putdown</h3>
<ul>
<li>Test 1
<ul>
<li>input: JSON <code>&quot;EmptySet&quot;</code></li>
<li>output: putdown <code>emptyset</code></li>
</ul>
</li>
<li>Test 2
<ul>
<li>input: JSON <code>[&quot;FiniteSet&quot;,[&quot;OneElementSequence&quot;,[&quot;Number&quot;,&quot;1&quot;]]]</code></li>
<li>output: putdown <code>(finiteset (elts 1))</code></li>
</ul>
</li>
<li>Test 3
<ul>
<li>input: JSON <code>[&quot;FiniteSet&quot;,[&quot;ElementThenSequence&quot;,[&quot;Number&quot;,&quot;1&quot;],[&quot;OneElementSequence&quot;,[&quot;Number&quot;,&quot;2&quot;]]]]</code></li>
<li>output: putdown <code>(finiteset (elts 1 (elts 2)))</code></li>
</ul>
</li>
<li>Test 4
<ul>
<li>input: JSON <code>[&quot;FiniteSet&quot;,[&quot;ElementThenSequence&quot;,[&quot;Number&quot;,&quot;1&quot;],[&quot;ElementThenSequence&quot;,[&quot;Number&quot;,&quot;2&quot;],[&quot;OneElementSequence&quot;,[&quot;Number&quot;,&quot;3&quot;]]]]]</code></li>
<li>output: putdown <code>(finiteset (elts 1 (elts 2 (elts 3))))</code></li>
</ul>
</li>
<li>Test 5
<ul>
<li>input: JSON <code>[&quot;FiniteSet&quot;,[&quot;ElementThenSequence&quot;,&quot;EmptySet&quot;,[&quot;OneElementSequence&quot;,&quot;EmptySet&quot;]]]</code></li>
<li>output: putdown <code>(finiteset (elts emptyset (elts emptyset)))</code></li>
</ul>
</li>
<li>Test 6
<ul>
<li>input: JSON <code>[&quot;FiniteSet&quot;,[&quot;OneElementSequence&quot;,[&quot;FiniteSet&quot;,[&quot;OneElementSequence&quot;,&quot;EmptySet&quot;]]]]</code></li>
<li>output: putdown <code>(finiteset (elts (finiteset (elts emptyset))))</code></li>
</ul>
</li>
<li>Test 7
<ul>
<li>input: JSON <code>[&quot;FiniteSet&quot;,[&quot;ElementThenSequence&quot;,[&quot;Number&quot;,&quot;3&quot;],[&quot;OneElementSequence&quot;,[&quot;NumberVariable&quot;,&quot;x&quot;]]]]</code></li>
<li>output: putdown <code>(finiteset (elts 3 (elts x)))</code></li>
</ul>
</li>
<li>Test 8
<ul>
<li>input: JSON <code>[&quot;FiniteSet&quot;,[&quot;ElementThenSequence&quot;,[&quot;SetUnion&quot;,[&quot;SetVariable&quot;,&quot;A&quot;],[&quot;SetVariable&quot;,&quot;B&quot;]],[&quot;OneElementSequence&quot;,[&quot;SetIntersection&quot;,[&quot;SetVariable&quot;,&quot;A&quot;],[&quot;SetVariable&quot;,&quot;B&quot;]]]]]</code></li>
<li>output: putdown <code>(finiteset (elts (union A B) (elts (intersection A B))))</code></li>
</ul>
</li>
<li>Test 9
<ul>
<li>input: JSON <code>[&quot;FiniteSet&quot;,[&quot;ElementThenSequence&quot;,[&quot;Number&quot;,&quot;1&quot;],[&quot;ElementThenSequence&quot;,[&quot;Number&quot;,&quot;2&quot;],[&quot;ElementThenSequence&quot;,&quot;EmptySet&quot;,[&quot;ElementThenSequence&quot;,[&quot;NumberVariable&quot;,&quot;K&quot;],[&quot;OneElementSequence&quot;,[&quot;NumberVariable&quot;,&quot;P&quot;]]]]]]]</code></li>
<li>output: putdown <code>(finiteset (elts 1 (elts 2 (elts emptyset (elts K (elts P))))))</code></li>
</ul>
</li>
</ul>
<h3>can convert tuples and vectors to putdown</h3>
<ul>
<li>Test 1
<ul>
<li>input: JSON <code>[&quot;Tuple&quot;,[&quot;ElementThenSequence&quot;,[&quot;Number&quot;,&quot;5&quot;],[&quot;OneElementSequence&quot;,[&quot;Number&quot;,&quot;6&quot;]]]]</code></li>
<li>output: putdown <code>(tuple (elts 5 (elts 6)))</code></li>
</ul>
</li>
<li>Test 2
<ul>
<li>input: JSON <code>[&quot;Tuple&quot;,[&quot;ElementThenSequence&quot;,[&quot;Number&quot;,&quot;5&quot;],[&quot;ElementThenSequence&quot;,[&quot;SetUnion&quot;,[&quot;SetVariable&quot;,&quot;A&quot;],[&quot;SetVariable&quot;,&quot;B&quot;]],[&quot;OneElementSequence&quot;,[&quot;NumberVariable&quot;,&quot;k&quot;]]]]]</code></li>
<li>output: putdown <code>(tuple (elts 5 (elts (union A B) (elts k))))</code></li>
</ul>
</li>
<li>Test 3
<ul>
<li>input: JSON <code>[&quot;Vector&quot;,[&quot;NumberThenSequence&quot;,[&quot;Number&quot;,&quot;5&quot;],[&quot;OneNumberSequence&quot;,[&quot;Number&quot;,&quot;6&quot;]]]]</code></li>
<li>output: putdown <code>(vector (elts 5 (elts 6)))</code></li>
</ul>
</li>
<li>Test 4
<ul>
<li>input: JSON <code>[&quot;Vector&quot;,[&quot;NumberThenSequence&quot;,[&quot;Number&quot;,&quot;5&quot;],[&quot;NumberThenSequence&quot;,[&quot;NumberNegation&quot;,[&quot;Number&quot;,&quot;7&quot;]],[&quot;OneNumberSequence&quot;,[&quot;NumberVariable&quot;,&quot;k&quot;]]]]]</code></li>
<li>output: putdown <code>(vector (elts 5 (elts (- 7) (elts k))))</code></li>
</ul>
</li>
<li>Test 5
<ul>
<li>input: JSON <code>[&quot;Tuple&quot;,[&quot;ElementThenSequence&quot;,[&quot;Tuple&quot;,[&quot;ElementThenSequence&quot;,[&quot;Number&quot;,&quot;1&quot;],[&quot;OneElementSequence&quot;,[&quot;Number&quot;,&quot;2&quot;]]]],[&quot;OneElementSequence&quot;,[&quot;Number&quot;,&quot;6&quot;]]]]</code></li>
<li>output: putdown <code>(tuple (elts (tuple (elts 1 (elts 2))) (elts 6)))</code></li>
</ul>
</li>
</ul>
<h3>can convert simple set memberships and subsets to putdown</h3>
<ul>
<li>Test 1
<ul>
<li>input: JSON <code>[&quot;NounIsElement&quot;,[&quot;NumberVariable&quot;,&quot;b&quot;],[&quot;SetVariable&quot;,&quot;B&quot;]]</code></li>
<li>output: putdown <code>(in b B)</code></li>
</ul>
</li>
<li>Test 2
<ul>
<li>input: JSON <code>[&quot;NounIsElement&quot;,[&quot;Number&quot;,&quot;2&quot;],[&quot;FiniteSet&quot;,[&quot;ElementThenSequence&quot;,[&quot;Number&quot;,&quot;1&quot;],[&quot;OneElementSequence&quot;,[&quot;Number&quot;,&quot;2&quot;]]]]]</code></li>
<li>output: putdown <code>(in 2 (finiteset (elts 1 (elts 2))))</code></li>
</ul>
</li>
<li>Test 3
<ul>
<li>input: JSON <code>[&quot;NounIsElement&quot;,[&quot;NumberVariable&quot;,&quot;X&quot;],[&quot;SetUnion&quot;,[&quot;SetVariable&quot;,&quot;a&quot;],[&quot;SetVariable&quot;,&quot;b&quot;]]]</code></li>
<li>output: putdown <code>(in X (union a b))</code></li>
</ul>
</li>
<li>Test 4
<ul>
<li>input: JSON <code>[&quot;NounIsElement&quot;,[&quot;SetUnion&quot;,[&quot;SetVariable&quot;,&quot;A&quot;],[&quot;SetVariable&quot;,&quot;B&quot;]],[&quot;SetUnion&quot;,[&quot;SetVariable&quot;,&quot;X&quot;],[&quot;SetVariable&quot;,&quot;Y&quot;]]]</code></li>
<li>output: putdown <code>(in (union A B) (union X Y))</code></li>
</ul>
</li>
<li>Test 5
<ul>
<li>input: JSON <code>[&quot;Subset&quot;,[&quot;SetVariable&quot;,&quot;A&quot;],[&quot;SetComplement&quot;,[&quot;SetVariable&quot;,&quot;B&quot;]]]</code></li>
<li>output: putdown <code>(subset A (complement B))</code></li>
</ul>
</li>
<li>Test 6
<ul>
<li>input: JSON <code>[&quot;SubsetOrEqual&quot;,[&quot;SetIntersection&quot;,[&quot;SetVariable&quot;,&quot;u&quot;],[&quot;SetVariable&quot;,&quot;v&quot;]],[&quot;SetUnion&quot;,[&quot;SetVariable&quot;,&quot;u&quot;],[&quot;SetVariable&quot;,&quot;v&quot;]]]</code></li>
<li>output: putdown <code>(subseteq (intersection u v) (union u v))</code></li>
</ul>
</li>
<li>Test 7
<ul>
<li>input: JSON <code>[&quot;SubsetOrEqual&quot;,[&quot;FiniteSet&quot;,[&quot;OneElementSequence&quot;,[&quot;Number&quot;,&quot;1&quot;]]],[&quot;SetUnion&quot;,[&quot;FiniteSet&quot;,[&quot;OneElementSequence&quot;,[&quot;Number&quot;,&quot;1&quot;]]],[&quot;FiniteSet&quot;,[&quot;OneElementSequence&quot;,[&quot;Number&quot;,&quot;2&quot;]]]]]</code></li>
<li>output: putdown <code>(subseteq (finiteset (elts 1)) (union (finiteset (elts 1)) (finiteset (elts 2))))</code></li>
</ul>
</li>
<li>Test 8
<ul>
<li>input: JSON <code>[&quot;NounIsElement&quot;,[&quot;NumberVariable&quot;,&quot;p&quot;],[&quot;SetCartesianProduct&quot;,[&quot;SetVariable&quot;,&quot;U&quot;],[&quot;SetVariable&quot;,&quot;V&quot;]]]</code></li>
<li>output: putdown <code>(in p (cartesianproduct U V))</code></li>
</ul>
</li>
<li>Test 9
<ul>
<li>input: JSON <code>[&quot;NounIsElement&quot;,[&quot;NumberVariable&quot;,&quot;q&quot;],[&quot;SetUnion&quot;,[&quot;SetComplement&quot;,[&quot;SetVariable&quot;,&quot;U&quot;]],[&quot;SetCartesianProduct&quot;,[&quot;SetVariable&quot;,&quot;V&quot;],[&quot;SetVariable&quot;,&quot;W&quot;]]]]</code></li>
<li>output: putdown <code>(in q (union (complement U) (cartesianproduct V W)))</code></li>
</ul>
</li>
<li>Test 10
<ul>
<li>input: JSON <code>[&quot;NounIsElement&quot;,[&quot;Tuple&quot;,[&quot;ElementThenSequence&quot;,[&quot;NumberVariable&quot;,&quot;a&quot;],[&quot;OneElementSequence&quot;,[&quot;NumberVariable&quot;,&quot;b&quot;]]]],[&quot;SetCartesianProduct&quot;,[&quot;SetVariable&quot;,&quot;A&quot;],[&quot;SetVariable&quot;,&quot;B&quot;]]]</code></li>
<li>output: putdown <code>(in (tuple (elts a (elts b))) (cartesianproduct A B))</code></li>
</ul>
</li>
<li>Test 11
<ul>
<li>input: JSON <code>[&quot;NounIsElement&quot;,[&quot;Vector&quot;,[&quot;NumberThenSequence&quot;,[&quot;NumberVariable&quot;,&quot;a&quot;],[&quot;OneNumberSequence&quot;,[&quot;NumberVariable&quot;,&quot;b&quot;]]]],[&quot;SetCartesianProduct&quot;,[&quot;SetVariable&quot;,&quot;A&quot;],[&quot;SetVariable&quot;,&quot;B&quot;]]]</code></li>
<li>output: putdown <code>(in (vector (elts a (elts b))) (cartesianproduct A B))</code></li>
</ul>
</li>
</ul>
<h3>creates the canonical form for &quot;notin&quot; notation</h3>
<ul>
<li>Test 1
<ul>
<li>input: JSON <code>[&quot;NounIsNotElement&quot;,[&quot;NumberVariable&quot;,&quot;a&quot;],[&quot;SetVariable&quot;,&quot;A&quot;]]</code></li>
<li>output: putdown <code>(not (in a A))</code></li>
</ul>
</li>
<li>Test 2
<ul>
<li>input: JSON <code>[&quot;LogicalNegation&quot;,[&quot;NounIsElement&quot;,&quot;EmptySet&quot;,&quot;EmptySet&quot;]]</code></li>
<li>output: putdown <code>(not (in emptyset emptyset))</code></li>
</ul>
</li>
<li>Test 3
<ul>
<li>input: JSON <code>[&quot;NounIsNotElement&quot;,[&quot;Subtraction&quot;,[&quot;Number&quot;,&quot;3&quot;],[&quot;Number&quot;,&quot;5&quot;]],[&quot;SetIntersection&quot;,[&quot;SetVariable&quot;,&quot;K&quot;],[&quot;SetVariable&quot;,&quot;P&quot;]]]</code></li>
<li>output: putdown <code>(not (in (- 3 5) (intersection K P)))</code></li>
</ul>
</li>
</ul>
<h3>can convert to putdown sentences built from various relations</h3>
<ul>
<li>Test 1
<ul>
<li>input: JSON <code>[&quot;Disjunction&quot;,[&quot;LogicVariable&quot;,&quot;P&quot;],[&quot;NounIsElement&quot;,[&quot;NumberVariable&quot;,&quot;b&quot;],[&quot;SetVariable&quot;,&quot;B&quot;]]]</code></li>
<li>output: putdown <code>(or P (in b B))</code></li>
</ul>
</li>
<li>Test 2
<ul>
<li>input: JSON <code>[&quot;UniversalQuantifier&quot;,[&quot;NumberVariable&quot;,&quot;x&quot;],[&quot;NounIsElement&quot;,[&quot;NumberVariable&quot;,&quot;x&quot;],[&quot;SetVariable&quot;,&quot;X&quot;]]]</code></li>
<li>output: putdown <code>(forall (x , (in x X)))</code></li>
</ul>
</li>
<li>Test 3
<ul>
<li>input: JSON <code>[&quot;Conjunction&quot;,[&quot;SubsetOrEqual&quot;,[&quot;SetVariable&quot;,&quot;A&quot;],[&quot;SetVariable&quot;,&quot;B&quot;]],[&quot;SubsetOrEqual&quot;,[&quot;SetVariable&quot;,&quot;B&quot;],[&quot;SetVariable&quot;,&quot;A&quot;]]]</code></li>
<li>output: putdown <code>(and (subseteq A B) (subseteq B A))</code></li>
</ul>
</li>
<li>Test 4
<ul>
<li>input: JSON <code>[&quot;Equals&quot;,[&quot;NumberVariable&quot;,&quot;R&quot;],[&quot;SetCartesianProduct&quot;,[&quot;SetVariable&quot;,&quot;A&quot;],[&quot;SetVariable&quot;,&quot;B&quot;]]]</code></li>
<li>output: putdown <code>(= R (cartesianproduct A B))</code></li>
</ul>
</li>
<li>Test 5
<ul>
<li>input: JSON <code>[&quot;UniversalQuantifier&quot;,[&quot;NumberVariable&quot;,&quot;n&quot;],[&quot;BinaryRelationHolds&quot;,&quot;Divides&quot;,[&quot;NumberVariable&quot;,&quot;n&quot;],[&quot;Factorial&quot;,[&quot;NumberVariable&quot;,&quot;n&quot;]]]]</code></li>
<li>output: putdown <code>(forall (n , (relationholds | n (! n))))</code></li>
</ul>
</li>
<li>Test 6
<ul>
<li>input: JSON <code>[&quot;Implication&quot;,[&quot;BinaryRelationHolds&quot;,&quot;GenericBinaryRelation&quot;,[&quot;NumberVariable&quot;,&quot;a&quot;],[&quot;NumberVariable&quot;,&quot;b&quot;]],[&quot;BinaryRelationHolds&quot;,&quot;GenericBinaryRelation&quot;,[&quot;NumberVariable&quot;,&quot;b&quot;],[&quot;NumberVariable&quot;,&quot;a&quot;]]]</code></li>
<li>output: putdown <code>(implies (relationholds ~ a b) (relationholds ~ b a))</code></li>
</ul>
</li>
</ul>
<h3>can create putdown notation related to functions</h3>
<ul>
<li>Test 1
<ul>
<li>input: JSON <code>[&quot;FunctionSignature&quot;,[&quot;FunctionVariable&quot;,&quot;f&quot;],[&quot;SetVariable&quot;,&quot;A&quot;],[&quot;SetVariable&quot;,&quot;B&quot;]]</code></li>
<li>output: putdown <code>(function f A B)</code></li>
</ul>
</li>
<li>Test 2
<ul>
<li>input: JSON <code>[&quot;LogicalNegation&quot;,[&quot;FunctionSignature&quot;,[&quot;FunctionVariable&quot;,&quot;F&quot;],[&quot;SetUnion&quot;,[&quot;SetVariable&quot;,&quot;X&quot;],[&quot;SetVariable&quot;,&quot;Y&quot;]],[&quot;SetVariable&quot;,&quot;Z&quot;]]]</code></li>
<li>output: putdown <code>(not (function F (union X Y) Z))</code></li>
</ul>
</li>
<li>Test 3
<ul>
<li>input: JSON <code>[&quot;FunctionSignature&quot;,[&quot;FunctionComposition&quot;,[&quot;FunctionVariable&quot;,&quot;f&quot;],[&quot;FunctionVariable&quot;,&quot;g&quot;]],[&quot;SetVariable&quot;,&quot;A&quot;],[&quot;SetVariable&quot;,&quot;C&quot;]]</code></li>
<li>output: putdown <code>(function (compose f g) A C)</code></li>
</ul>
</li>
<li>Test 4
<ul>
<li>input: JSON <code>[&quot;NumberFunctionApplication&quot;,[&quot;FunctionVariable&quot;,&quot;f&quot;],[&quot;NumberVariable&quot;,&quot;x&quot;]]</code></li>
<li>output: putdown <code>(apply f x)</code></li>
</ul>
</li>
<li>Test 5
<ul>
<li>input: JSON <code>[&quot;NumberFunctionApplication&quot;,[&quot;FunctionInverse&quot;,[&quot;FunctionVariable&quot;,&quot;f&quot;]],[&quot;NumberFunctionApplication&quot;,[&quot;FunctionInverse&quot;,[&quot;FunctionVariable&quot;,&quot;g&quot;]],[&quot;Number&quot;,&quot;10&quot;]]]</code></li>
<li>output: putdown <code>(apply (inverse f) (apply (inverse g) 10))</code></li>
</ul>
</li>
<li>Test 6
<ul>
<li>input: JSON <code>[&quot;NumberFunctionApplication&quot;,[&quot;FunctionVariable&quot;,&quot;E&quot;],[&quot;SetComplement&quot;,[&quot;SetVariable&quot;,&quot;L&quot;]]]</code></li>
<li>output: putdown <code>(apply E (complement L))</code></li>
</ul>
</li>
<li>Test 7
<ul>
<li>input: JSON <code>[&quot;SetIntersection&quot;,&quot;EmptySet&quot;,[&quot;SetFunctionApplication&quot;,[&quot;FunctionVariable&quot;,&quot;f&quot;],[&quot;Number&quot;,&quot;2&quot;]]]</code></li>
<li>output: putdown <code>(intersection emptyset (apply f 2))</code></li>
</ul>
</li>
<li>Test 8
<ul>
<li>input: JSON <code>[&quot;Conjunction&quot;,[&quot;PropositionFunctionApplication&quot;,[&quot;FunctionVariable&quot;,&quot;P&quot;],[&quot;NumberVariable&quot;,&quot;e&quot;]],[&quot;PropositionFunctionApplication&quot;,[&quot;FunctionVariable&quot;,&quot;Q&quot;],[&quot;Addition&quot;,[&quot;Number&quot;,&quot;3&quot;],[&quot;NumberVariable&quot;,&quot;b&quot;]]]]</code></li>
<li>output: putdown <code>(and (apply P e) (apply Q (+ 3 b)))</code></li>
</ul>
</li>
<li>Test 9
<ul>
<li>input: JSON <code>[&quot;EqualFunctions&quot;,[&quot;FunctionVariable&quot;,&quot;F&quot;],[&quot;FunctionComposition&quot;,[&quot;FunctionVariable&quot;,&quot;G&quot;],[&quot;FunctionInverse&quot;,[&quot;FunctionVariable&quot;,&quot;H&quot;]]]]</code></li>
<li>output: putdown <code>(= F (compose G (inverse H)))</code></li>
</ul>
</li>
</ul>
<h3>can express trigonometric functions correctly</h3>
<ul>
<li>Test 1
<ul>
<li>input: JSON <code>[&quot;NumberFunctionApplication&quot;,&quot;SineFunction&quot;,[&quot;NumberVariable&quot;,&quot;x&quot;]]</code></li>
<li>output: putdown <code>(apply sin x)</code></li>
</ul>
</li>
<li>Test 2
<ul>
<li>input: JSON <code>[&quot;NumberFunctionApplication&quot;,&quot;CosineFunction&quot;,[&quot;Multiplication&quot;,&quot;Pi&quot;,[&quot;NumberVariable&quot;,&quot;x&quot;]]]</code></li>
<li>output: putdown <code>(apply cos (* pi x))</code></li>
</ul>
</li>
<li>Test 3
<ul>
<li>input: JSON <code>[&quot;NumberFunctionApplication&quot;,&quot;TangentFunction&quot;,[&quot;NumberVariable&quot;,&quot;t&quot;]]</code></li>
<li>output: putdown <code>(apply tan t)</code></li>
</ul>
</li>
<li>Test 4
<ul>
<li>input: JSON <code>[&quot;Division&quot;,[&quot;Number&quot;,&quot;1&quot;],[&quot;NumberFunctionApplication&quot;,&quot;CotangentFunction&quot;,&quot;Pi&quot;]]</code></li>
<li>output: putdown <code>(/ 1 (apply cot pi))</code></li>
</ul>
</li>
<li>Test 5
<ul>
<li>input: JSON <code>[&quot;Equals&quot;,[&quot;NumberFunctionApplication&quot;,&quot;SecantFunction&quot;,[&quot;NumberVariable&quot;,&quot;y&quot;]],[&quot;NumberFunctionApplication&quot;,&quot;CosecantFunction&quot;,[&quot;NumberVariable&quot;,&quot;y&quot;]]]</code></li>
<li>output: putdown <code>(= (apply sec y) (apply csc y))</code></li>
</ul>
</li>
</ul>
<h3>can express logarithms correctly</h3>
<ul>
<li>Test 1
<ul>
<li>input: JSON <code>[&quot;PrefixFunctionApplication&quot;,&quot;Logarithm&quot;,[&quot;NumberVariable&quot;,&quot;n&quot;]]</code></li>
<li>output: putdown <code>(apply log n)</code></li>
</ul>
</li>
<li>Test 2
<ul>
<li>input: JSON <code>[&quot;Addition&quot;,[&quot;Number&quot;,&quot;1&quot;],[&quot;PrefixFunctionApplication&quot;,&quot;NaturalLogarithm&quot;,[&quot;NumberVariable&quot;,&quot;x&quot;]]]</code></li>
<li>output: putdown <code>(+ 1 (apply ln x))</code></li>
</ul>
</li>
<li>Test 3
<ul>
<li>input: JSON <code>[&quot;PrefixFunctionApplication&quot;,[&quot;LogarithmWithBase&quot;,[&quot;Number&quot;,&quot;2&quot;]],[&quot;Number&quot;,&quot;1024&quot;]]</code></li>
<li>output: putdown <code>(apply (logbase 2) 1024)</code></li>
</ul>
</li>
<li>Test 4
<ul>
<li>input: JSON <code>[&quot;Division&quot;,[&quot;PrefixFunctionApplication&quot;,&quot;Logarithm&quot;,[&quot;NumberVariable&quot;,&quot;n&quot;]],[&quot;PrefixFunctionApplication&quot;,&quot;Logarithm&quot;,[&quot;PrefixFunctionApplication&quot;,&quot;Logarithm&quot;,[&quot;NumberVariable&quot;,&quot;n&quot;]]]]</code></li>
<li>output: putdown <code>(/ (apply log n) (apply log (apply log n)))</code></li>
</ul>
</li>
</ul>
<h3>can express equivalence classes and expressions that use them</h3>
<ul>
<li>Test 1
<ul>
<li>input: JSON <code>[&quot;EquivalenceClass&quot;,[&quot;Number&quot;,&quot;1&quot;],&quot;ApproximatelyEqual&quot;]</code></li>
<li>output: putdown <code>(equivclass 1 ~~)</code></li>
</ul>
</li>
<li>Test 2
<ul>
<li>input: JSON <code>[&quot;EquivalenceClass&quot;,[&quot;Addition&quot;,[&quot;NumberVariable&quot;,&quot;x&quot;],[&quot;Number&quot;,&quot;2&quot;]],&quot;GenericBinaryRelation&quot;]</code></li>
<li>output: putdown <code>(equivclass (+ x 2) ~)</code></li>
</ul>
</li>
<li>Test 3
<ul>
<li>input: JSON <code>[&quot;SetUnion&quot;,[&quot;EquivalenceClass&quot;,[&quot;Number&quot;,&quot;1&quot;],&quot;ApproximatelyEqual&quot;],[&quot;EquivalenceClass&quot;,[&quot;Number&quot;,&quot;2&quot;],&quot;ApproximatelyEqual&quot;]]</code></li>
<li>output: putdown <code>(union (equivclass 1 ~~) (equivclass 2 ~~))</code></li>
</ul>
</li>
<li>Test 4
<ul>
<li>input: JSON <code>[&quot;NounIsElement&quot;,[&quot;Number&quot;,&quot;7&quot;],[&quot;EquivalenceClass&quot;,[&quot;Number&quot;,&quot;7&quot;],&quot;GenericBinaryRelation&quot;]]</code></li>
<li>output: putdown <code>(in 7 (equivclass 7 ~))</code></li>
</ul>
</li>
<li>Test 5
<ul>
<li>input: JSON <code>[&quot;EquivalenceClass&quot;,[&quot;FunctionVariable&quot;,&quot;P&quot;],&quot;GenericBinaryRelation&quot;]</code></li>
<li>output: putdown <code>(equivclass P ~)</code></li>
</ul>
</li>
</ul>
<h3>can express equivalence and classes mod a number</h3>
<ul>
<li>Test 1
<ul>
<li>input: JSON <code>[&quot;EquivalentModulo&quot;,[&quot;Number&quot;,&quot;5&quot;],[&quot;Number&quot;,&quot;11&quot;],[&quot;Number&quot;,&quot;3&quot;]]</code></li>
<li>output: putdown <code>(=mod 5 11 3)</code></li>
</ul>
</li>
<li>Test 2
<ul>
<li>input: JSON <code>[&quot;EquivalentModulo&quot;,[&quot;NumberVariable&quot;,&quot;k&quot;],[&quot;NumberVariable&quot;,&quot;m&quot;],[&quot;NumberVariable&quot;,&quot;n&quot;]]</code></li>
<li>output: putdown <code>(=mod k m n)</code></li>
</ul>
</li>
<li>Test 3
<ul>
<li>input: JSON <code>[&quot;Subset&quot;,&quot;EmptySet&quot;,[&quot;EquivalenceClassModulo&quot;,[&quot;NumberNegation&quot;,[&quot;Number&quot;,&quot;1&quot;]],[&quot;Number&quot;,&quot;10&quot;]]]</code></li>
<li>output: putdown <code>(subset emptyset (modclass (- 1) 10))</code></li>
</ul>
</li>
</ul>
<h3>can construct type sentences and combinations of them</h3>
<ul>
<li>Test 1
<ul>
<li>input: JSON <code>[&quot;HasType&quot;,[&quot;NumberVariable&quot;,&quot;x&quot;],&quot;SetType&quot;]</code></li>
<li>output: putdown <code>(hastype x settype)</code></li>
</ul>
</li>
<li>Test 2
<ul>
<li>input: JSON <code>[&quot;HasType&quot;,[&quot;NumberVariable&quot;,&quot;n&quot;],&quot;NumberType&quot;]</code></li>
<li>output: putdown <code>(hastype n numbertype)</code></li>
</ul>
</li>
<li>Test 3
<ul>
<li>input: JSON <code>[&quot;HasType&quot;,[&quot;NumberVariable&quot;,&quot;S&quot;],&quot;PartialOrderType&quot;]</code></li>
<li>output: putdown <code>(hastype S partialordertype)</code></li>
</ul>
</li>
<li>Test 4
<ul>
<li>input: JSON <code>[&quot;Conjunction&quot;,[&quot;HasType&quot;,[&quot;Number&quot;,&quot;1&quot;],&quot;NumberType&quot;],[&quot;HasType&quot;,[&quot;Number&quot;,&quot;10&quot;],&quot;NumberType&quot;]]</code></li>
<li>output: putdown <code>(and (hastype 1 numbertype) (hastype 10 numbertype))</code></li>
</ul>
</li>
<li>Test 5
<ul>
<li>input: JSON <code>[&quot;Implication&quot;,[&quot;HasType&quot;,[&quot;NumberVariable&quot;,&quot;R&quot;],&quot;EquivalenceRelationType&quot;],[&quot;HasType&quot;,[&quot;NumberVariable&quot;,&quot;R&quot;],&quot;RelationType&quot;]]</code></li>
<li>output: putdown <code>(implies (hastype R equivalencerelationtype) (hastype R relationtype))</code></li>
</ul>
</li>
</ul>
<h3>can create notation for expression function application</h3>
<ul>
<li>Test 1
<ul>
<li>input: JSON <code>[&quot;NumberEFA&quot;,[&quot;FunctionVariable&quot;,&quot;f&quot;],[&quot;NumberVariable&quot;,&quot;x&quot;]]</code></li>
<li>output: putdown <code>(efa f x)</code></li>
</ul>
</li>
<li>Test 2
<ul>
<li>input: JSON <code>[&quot;NumberFunctionApplication&quot;,[&quot;FunctionVariable&quot;,&quot;F&quot;],[&quot;NumberEFA&quot;,[&quot;FunctionVariable&quot;,&quot;k&quot;],[&quot;Number&quot;,&quot;10&quot;]]]</code></li>
<li>output: putdown <code>(apply F (efa k 10))</code></li>
</ul>
</li>
<li>Test 3
<ul>
<li>input: JSON <code>[&quot;NumberEFA&quot;,[&quot;FunctionVariable&quot;,&quot;E&quot;],[&quot;SetComplement&quot;,[&quot;SetVariable&quot;,&quot;L&quot;]]]</code></li>
<li>output: putdown <code>(efa E (complement L))</code></li>
</ul>
</li>
<li>Test 4
<ul>
<li>input: JSON <code>[&quot;SetIntersection&quot;,&quot;EmptySet&quot;,[&quot;SetEFA&quot;,[&quot;FunctionVariable&quot;,&quot;f&quot;],[&quot;Number&quot;,&quot;2&quot;]]]</code></li>
<li>output: putdown <code>(intersection emptyset (efa f 2))</code></li>
</ul>
</li>
<li>Test 5
<ul>
<li>input: JSON <code>[&quot;Conjunction&quot;,[&quot;PropositionEFA&quot;,[&quot;FunctionVariable&quot;,&quot;P&quot;],[&quot;NumberVariable&quot;,&quot;x&quot;]],[&quot;PropositionEFA&quot;,[&quot;FunctionVariable&quot;,&quot;Q&quot;],[&quot;NumberVariable&quot;,&quot;y&quot;]]]</code></li>
<li>output: putdown <code>(and (efa P x) (efa Q y))</code></li>
</ul>
</li>
</ul>
<h3>can create notation for assumptions</h3>
<ul>
<li>Test 1
<ul>
<li>input: JSON <code>[&quot;Given_Variant1&quot;,[&quot;LogicVariable&quot;,&quot;X&quot;]]</code></li>
<li>output: putdown <code>:X</code></li>
</ul>
</li>
<li>Test 2
<ul>
<li>input: JSON <code>[&quot;Given_Variant2&quot;,[&quot;LogicVariable&quot;,&quot;X&quot;]]</code></li>
<li>output: putdown <code>:X</code></li>
</ul>
</li>
<li>Test 3
<ul>
<li>input: JSON <code>[&quot;Given_Variant3&quot;,[&quot;LogicVariable&quot;,&quot;X&quot;]]</code></li>
<li>output: putdown <code>:X</code></li>
</ul>
</li>
<li>Test 4
<ul>
<li>input: JSON <code>[&quot;Given_Variant4&quot;,[&quot;LogicVariable&quot;,&quot;X&quot;]]</code></li>
<li>output: putdown <code>:X</code></li>
</ul>
</li>
<li>Test 5
<ul>
<li>input: JSON <code>[&quot;Given_Variant1&quot;,[&quot;Equals&quot;,[&quot;NumberVariable&quot;,&quot;k&quot;],[&quot;Number&quot;,&quot;1000&quot;]]]</code></li>
<li>output: putdown <code>:(= k 1000)</code></li>
</ul>
</li>
<li>Test 6
<ul>
<li>input: JSON <code>[&quot;Given_Variant2&quot;,[&quot;Equals&quot;,[&quot;NumberVariable&quot;,&quot;k&quot;],[&quot;Number&quot;,&quot;1000&quot;]]]</code></li>
<li>output: putdown <code>:(= k 1000)</code></li>
</ul>
</li>
<li>Test 7
<ul>
<li>input: JSON <code>[&quot;Given_Variant3&quot;,[&quot;Equals&quot;,[&quot;NumberVariable&quot;,&quot;k&quot;],[&quot;Number&quot;,&quot;1000&quot;]]]</code></li>
<li>output: putdown <code>:(= k 1000)</code></li>
</ul>
</li>
<li>Test 8
<ul>
<li>input: JSON <code>[&quot;Given_Variant4&quot;,[&quot;Equals&quot;,[&quot;NumberVariable&quot;,&quot;k&quot;],[&quot;Number&quot;,&quot;1000&quot;]]]</code></li>
<li>output: putdown <code>:(= k 1000)</code></li>
</ul>
</li>
<li>Test 9
<ul>
<li>input: JSON <code>[&quot;Given_Variant1&quot;,&quot;LogicalTrue&quot;]</code></li>
<li>output: putdown <code>:true</code></li>
</ul>
</li>
<li>Test 10
<ul>
<li>input: JSON <code>[&quot;Given_Variant2&quot;,&quot;LogicalTrue&quot;]</code></li>
<li>output: putdown <code>:true</code></li>
</ul>
</li>
<li>Test 11
<ul>
<li>input: JSON <code>[&quot;Given_Variant3&quot;,&quot;LogicalTrue&quot;]</code></li>
<li>output: putdown <code>:true</code></li>
</ul>
</li>
<li>Test 12
<ul>
<li>input: JSON <code>[&quot;Given_Variant4&quot;,&quot;LogicalTrue&quot;]</code></li>
<li>output: putdown <code>:true</code></li>
</ul>
</li>
</ul>
<h3>can create notation for Let-style declarations</h3>
<ul>
<li>Test 1
<ul>
<li>input: JSON <code>[&quot;Let_Variant1&quot;,[&quot;NumberVariable&quot;,&quot;x&quot;]]</code></li>
<li>output: putdown <code>:[x]</code></li>
</ul>
</li>
<li>Test 2
<ul>
<li>input: JSON <code>[&quot;Let_Variant1&quot;,[&quot;NumberVariable&quot;,&quot;T&quot;]]</code></li>
<li>output: putdown <code>:[T]</code></li>
</ul>
</li>
<li>Test 3
<ul>
<li>input: JSON <code>[&quot;LetBeSuchThat_Variant1&quot;,[&quot;NumberVariable&quot;,&quot;x&quot;],[&quot;GreaterThan&quot;,[&quot;NumberVariable&quot;,&quot;x&quot;],[&quot;Number&quot;,&quot;0&quot;]]]</code></li>
<li>output: putdown <code>:[x , (&gt; x 0)]</code></li>
</ul>
</li>
<li>Test 4
<ul>
<li>input: JSON <code>[&quot;LetBeSuchThat_Variant1&quot;,[&quot;NumberVariable&quot;,&quot;T&quot;],[&quot;Disjunction&quot;,[&quot;Equals&quot;,[&quot;NumberVariable&quot;,&quot;T&quot;],[&quot;Number&quot;,&quot;5&quot;]],[&quot;NounIsElement&quot;,[&quot;NumberVariable&quot;,&quot;T&quot;],[&quot;SetVariable&quot;,&quot;S&quot;]]]]</code></li>
<li>output: putdown <code>:[T , (or (= T 5) (in T S))]</code></li>
</ul>
</li>
</ul>
<h3>can create notation for For Some-style declarations</h3>
<ul>
<li>Test 1
<ul>
<li>input: JSON <code>[&quot;ForSome_Variant1&quot;,[&quot;NumberVariable&quot;,&quot;x&quot;],[&quot;GreaterThan&quot;,[&quot;NumberVariable&quot;,&quot;x&quot;],[&quot;Number&quot;,&quot;0&quot;]]]</code></li>
<li>output: putdown <code>[x , (&gt; x 0)]</code></li>
</ul>
</li>
<li>Test 2
<ul>
<li>input: JSON <code>[&quot;ForSome_Variant2&quot;,[&quot;NumberVariable&quot;,&quot;x&quot;],[&quot;GreaterThan&quot;,[&quot;NumberVariable&quot;,&quot;x&quot;],[&quot;Number&quot;,&quot;0&quot;]]]</code></li>
<li>output: putdown <code>[x , (&gt; x 0)]</code></li>
</ul>
</li>
<li>Test 3
<ul>
<li>input: JSON <code>[&quot;ForSome_Variant3&quot;,[&quot;NumberVariable&quot;,&quot;x&quot;],[&quot;GreaterThan&quot;,[&quot;NumberVariable&quot;,&quot;x&quot;],[&quot;Number&quot;,&quot;0&quot;]]]</code></li>
<li>output: putdown <code>[x , (&gt; x 0)]</code></li>
</ul>
</li>
<li>Test 4
<ul>
<li>input: JSON <code>[&quot;ForSome_Variant4&quot;,[&quot;NumberVariable&quot;,&quot;x&quot;],[&quot;GreaterThan&quot;,[&quot;NumberVariable&quot;,&quot;x&quot;],[&quot;Number&quot;,&quot;0&quot;]]]</code></li>
<li>output: putdown <code>[x , (&gt; x 0)]</code></li>
</ul>
</li>
<li>Test 5
<ul>
<li>input: JSON <code>[&quot;ForSome_Variant1&quot;,[&quot;NumberVariable&quot;,&quot;T&quot;],[&quot;Disjunction&quot;,[&quot;Equals&quot;,[&quot;NumberVariable&quot;,&quot;T&quot;],[&quot;Number&quot;,&quot;5&quot;]],[&quot;NounIsElement&quot;,[&quot;NumberVariable&quot;,&quot;T&quot;],[&quot;SetVariable&quot;,&quot;S&quot;]]]]</code></li>
<li>output: putdown <code>[T , (or (= T 5) (in T S))]</code></li>
</ul>
</li>
<li>Test 6
<ul>
<li>input: JSON <code>[&quot;ForSome_Variant2&quot;,[&quot;NumberVariable&quot;,&quot;T&quot;],[&quot;Disjunction&quot;,[&quot;Equals&quot;,[&quot;NumberVariable&quot;,&quot;T&quot;],[&quot;Number&quot;,&quot;5&quot;]],[&quot;NounIsElement&quot;,[&quot;NumberVariable&quot;,&quot;T&quot;],[&quot;SetVariable&quot;,&quot;S&quot;]]]]</code></li>
<li>output: putdown <code>[T , (or (= T 5) (in T S))]</code></li>
</ul>
</li>
<li>Test 7
<ul>
<li>input: JSON <code>[&quot;ForSome_Variant3&quot;,[&quot;NumberVariable&quot;,&quot;T&quot;],[&quot;Disjunction&quot;,[&quot;Equals&quot;,[&quot;NumberVariable&quot;,&quot;T&quot;],[&quot;Number&quot;,&quot;5&quot;]],[&quot;NounIsElement&quot;,[&quot;NumberVariable&quot;,&quot;T&quot;],[&quot;SetVariable&quot;,&quot;S&quot;]]]]</code></li>
<li>output: putdown <code>[T , (or (= T 5) (in T S))]</code></li>
</ul>
</li>
<li>Test 8
<ul>
<li>input: JSON <code>[&quot;ForSome_Variant4&quot;,[&quot;NumberVariable&quot;,&quot;T&quot;],[&quot;Disjunction&quot;,[&quot;Equals&quot;,[&quot;NumberVariable&quot;,&quot;T&quot;],[&quot;Number&quot;,&quot;5&quot;]],[&quot;NounIsElement&quot;,[&quot;NumberVariable&quot;,&quot;T&quot;],[&quot;SetVariable&quot;,&quot;S&quot;]]]]</code></li>
<li>output: putdown <code>[T , (or (= T 5) (in T S))]</code></li>
</ul>
</li>
</ul>
<h2><a name="Parsing-LaTeX">Parsing LaTeX</a></h2>
<h3>can parse many kinds of numbers to JSON</h3>
<ul>
<li>Test 1
<ul>
<li>input: LaTeX <code>0</code>, typeset $0$</li>
<li>output: JSON <code>[&quot;Number&quot;,&quot;0&quot;]</code></li>
</ul>
</li>
<li>Test 2
<ul>
<li>input: LaTeX <code>453789</code>, typeset $453789$</li>
<li>output: JSON <code>[&quot;Number&quot;,&quot;453789&quot;]</code></li>
</ul>
</li>
<li>Test 3
<ul>
<li>input: LaTeX <code>99999999999999999999999999999999999999999</code>, typeset $99999999999999999999999999999999999999999$</li>
<li>output: JSON <code>[&quot;Number&quot;,&quot;99999999999999999999999999999999999999999&quot;]</code></li>
</ul>
</li>
<li>Test 4
<ul>
<li>input: LaTeX <code>-453789</code>, typeset $-453789$</li>
<li>output: JSON <code>[&quot;NumberNegation&quot;,[&quot;Number&quot;,&quot;453789&quot;]]</code></li>
</ul>
</li>
<li>Test 5
<ul>
<li>input: LaTeX <code>-99999999999999999999999999999999999999999</code>, typeset $-99999999999999999999999999999999999999999$</li>
<li>output: JSON <code>[&quot;NumberNegation&quot;,[&quot;Number&quot;,&quot;99999999999999999999999999999999999999999&quot;]]</code></li>
</ul>
</li>
<li>Test 6
<ul>
<li>input: LaTeX <code>0.0</code>, typeset $0.0$</li>
<li>output: JSON <code>[&quot;Number&quot;,&quot;0.0&quot;]</code></li>
</ul>
</li>
<li>Test 7
<ul>
<li>input: LaTeX <code>29835.6875940</code>, typeset $29835.6875940$</li>
<li>output: JSON <code>[&quot;Number&quot;,&quot;29835.6875940&quot;]</code></li>
</ul>
</li>
<li>Test 8
<ul>
<li>input: LaTeX <code>653280458689.</code>, typeset $653280458689.$</li>
<li>output: JSON <code>[&quot;Number&quot;,&quot;653280458689.&quot;]</code></li>
</ul>
</li>
<li>Test 9
<ul>
<li>input: LaTeX <code>.000006327589</code>, typeset $.000006327589$</li>
<li>output: JSON <code>[&quot;Number&quot;,&quot;.000006327589&quot;]</code></li>
</ul>
</li>
<li>Test 10
<ul>
<li>input: LaTeX <code>-29835.6875940</code>, typeset $-29835.6875940$</li>
<li>output: JSON <code>[&quot;NumberNegation&quot;,[&quot;Number&quot;,&quot;29835.6875940&quot;]]</code></li>
</ul>
</li>
<li>Test 11
<ul>
<li>input: LaTeX <code>-653280458689.</code>, typeset $-653280458689.$</li>
<li>output: JSON <code>[&quot;NumberNegation&quot;,[&quot;Number&quot;,&quot;653280458689.&quot;]]</code></li>
</ul>
</li>
<li>Test 12
<ul>
<li>input: LaTeX <code>-.000006327589</code>, typeset $-.000006327589$</li>
<li>output: JSON <code>[&quot;NumberNegation&quot;,[&quot;Number&quot;,&quot;.000006327589&quot;]]</code></li>
</ul>
</li>
</ul>
<h3>can parse one-letter variable names to JSON</h3>
<ul>
<li>Test 1
<ul>
<li>input: LaTeX <code>x</code>, typeset $x$</li>
<li>output: JSON <code>[&quot;FunctionVariable&quot;,&quot;x&quot;]</code></li>
</ul>
</li>
<li>Test 2
<ul>
<li>input: LaTeX <code>E</code>, typeset $E$</li>
<li>output: JSON <code>[&quot;FunctionVariable&quot;,&quot;E&quot;]</code></li>
</ul>
</li>
<li>Test 3
<ul>
<li>input: LaTeX <code>q</code>, typeset $q$</li>
<li>output: JSON <code>[&quot;FunctionVariable&quot;,&quot;q&quot;]</code></li>
</ul>
</li>
<li>Test 4
<ul>
<li>input: LaTeX <code>foo</code>, typeset $foo$</li>
<li>output: JSON <code>null</code></li>
</ul>
</li>
<li>Test 5
<ul>
<li>input: LaTeX <code>bar</code>, typeset $bar$</li>
<li>output: JSON <code>null</code></li>
</ul>
</li>
<li>Test 6
<ul>
<li>input: LaTeX <code>to</code>, typeset $to$</li>
<li>output: JSON <code>null</code></li>
</ul>
</li>
</ul>
<h3>can parse LaTeX numeric constants to JSON</h3>
<ul>
<li>Test 1
<ul>
<li>input: LaTeX <code>\infty</code>, typeset $\infty$</li>
<li>output: JSON <code>&quot;Infinity&quot;</code></li>
</ul>
</li>
<li>Test 2
<ul>
<li>input: LaTeX <code>\pi</code>, typeset $\pi$</li>
<li>output: JSON <code>&quot;Pi&quot;</code></li>
</ul>
</li>
<li>Test 3
<ul>
<li>input: LaTeX <code>e</code>, typeset $e$</li>
<li>output: JSON <code>[&quot;FunctionVariable&quot;,&quot;e&quot;]</code></li>
</ul>
</li>
</ul>
<h3>can parse exponentiation of atomics to JSON</h3>
<ul>
<li>Test 1
<ul>
<li>input: LaTeX <code>1^2</code>, typeset $1^2$</li>
<li>output: JSON <code>[&quot;Exponentiation&quot;,[&quot;Number&quot;,&quot;1&quot;],[&quot;Number&quot;,&quot;2&quot;]]</code></li>
</ul>
</li>
<li>Test 2
<ul>
<li>input: LaTeX <code>e^x</code>, typeset $e^x$</li>
<li>output: JSON <code>[&quot;Exponentiation&quot;,&quot;EulersNumber&quot;,[&quot;NumberVariable&quot;,&quot;x&quot;]]</code></li>
</ul>
</li>
<li>Test 3
<ul>
<li>input: LaTeX <code>1^\infty</code>, typeset $1^\infty$</li>
<li>output: JSON <code>[&quot;Exponentiation&quot;,[&quot;Number&quot;,&quot;1&quot;],&quot;Infinity&quot;]</code></li>
</ul>
</li>
</ul>
<h3>can parse atomic percentages and factorials to JSON</h3>
<ul>
<li>Test 1
<ul>
<li>input: LaTeX <code>10\%</code>, typeset $10\%$</li>
<li>output: JSON <code>[&quot;Percentage&quot;,[&quot;Number&quot;,&quot;10&quot;]]</code></li>
</ul>
</li>
<li>Test 2
<ul>
<li>input: LaTeX <code>t\%</code>, typeset $t\%$</li>
<li>output: JSON <code>[&quot;Percentage&quot;,[&quot;NumberVariable&quot;,&quot;t&quot;]]</code></li>
</ul>
</li>
<li>Test 3
<ul>
<li>input: LaTeX <code>77!</code>, typeset $77!$</li>
<li>output: JSON <code>[&quot;Factorial&quot;,[&quot;Number&quot;,&quot;77&quot;]]</code></li>
</ul>
</li>
<li>Test 4
<ul>
<li>input: LaTeX <code>y!</code>, typeset $y!$</li>
<li>output: JSON <code>[&quot;Factorial&quot;,[&quot;NumberVariable&quot;,&quot;y&quot;]]</code></li>
</ul>
</li>
</ul>
<h3>can parse division of atomics or factors to JSON</h3>
<ul>
<li>Test 1
<ul>
<li>input: LaTeX <code>1\div2</code>, typeset $1\div2$</li>
<li>output: JSON <code>[&quot;Division&quot;,[&quot;Number&quot;,&quot;1&quot;],[&quot;Number&quot;,&quot;2&quot;]]</code></li>
</ul>
</li>
<li>Test 2
<ul>
<li>input: LaTeX <code>x\div y</code>, typeset $x\div y$</li>
<li>output: JSON <code>[&quot;Division&quot;,[&quot;NumberVariable&quot;,&quot;x&quot;],[&quot;NumberVariable&quot;,&quot;y&quot;]]</code></li>
</ul>
</li>
<li>Test 3
<ul>
<li>input: LaTeX <code>0\div\infty</code>, typeset $0\div\infty$</li>
<li>output: JSON <code>[&quot;Division&quot;,[&quot;Number&quot;,&quot;0&quot;],&quot;Infinity&quot;]</code></li>
</ul>
</li>
<li>Test 4
<ul>
<li>input: LaTeX <code>x^2\div3</code>, typeset $x^2\div3$</li>
<li>output: JSON <code>[&quot;Division&quot;,[&quot;Exponentiation&quot;,[&quot;NumberVariable&quot;,&quot;x&quot;],[&quot;Number&quot;,&quot;2&quot;]],[&quot;Number&quot;,&quot;3&quot;]]</code></li>
</ul>
</li>
<li>Test 5
<ul>
<li>input: LaTeX <code>1\div e^x</code>, typeset $1\div e^x$</li>
<li>output: JSON <code>[&quot;Division&quot;,[&quot;Number&quot;,&quot;1&quot;],[&quot;Exponentiation&quot;,&quot;EulersNumber&quot;,[&quot;NumberVariable&quot;,&quot;x&quot;]]]</code></li>
</ul>
</li>
<li>Test 6
<ul>
<li>input: LaTeX <code>10\%\div2^{100}</code>, typeset $10\%\div2^{100}$</li>
<li>output: JSON <code>[&quot;Division&quot;,[&quot;Percentage&quot;,[&quot;Number&quot;,&quot;10&quot;]],[&quot;Exponentiation&quot;,[&quot;Number&quot;,&quot;2&quot;],[&quot;Number&quot;,&quot;100&quot;]]]</code></li>
</ul>
</li>
</ul>
<h3>can parse multiplication of atomics or factors to JSON</h3>
<ul>
<li>Test 1
<ul>
<li>input: LaTeX <code>1\times2</code>, typeset $1\times2$</li>
<li>output: JSON <code>[&quot;Multiplication&quot;,[&quot;Number&quot;,&quot;1&quot;],[&quot;Number&quot;,&quot;2&quot;]]</code></li>
</ul>
</li>
<li>Test 2
<ul>
<li>input: LaTeX <code>x\cdot y</code>, typeset $x\cdot y$</li>
<li>output: JSON <code>[&quot;Multiplication&quot;,[&quot;NumberVariable&quot;,&quot;x&quot;],[&quot;NumberVariable&quot;,&quot;y&quot;]]</code></li>
</ul>
</li>
<li>Test 3
<ul>
<li>input: LaTeX <code>0\times\infty</code>, typeset $0\times\infty$</li>
<li>output: JSON <code>[&quot;Multiplication&quot;,[&quot;Number&quot;,&quot;0&quot;],&quot;Infinity&quot;]</code></li>
</ul>
</li>
<li>Test 4
<ul>
<li>input: LaTeX <code>x^2\cdot3</code>, typeset $x^2\cdot3$</li>
<li>output: JSON <code>[&quot;Multiplication&quot;,[&quot;Exponentiation&quot;,[&quot;NumberVariable&quot;,&quot;x&quot;],[&quot;Number&quot;,&quot;2&quot;]],[&quot;Number&quot;,&quot;3&quot;]]</code></li>
</ul>
</li>
<li>Test 5
<ul>
<li>input: LaTeX <code>1\times e^x</code>, typeset $1\times e^x$</li>
<li>output: JSON <code>[&quot;Multiplication&quot;,[&quot;Number&quot;,&quot;1&quot;],[&quot;Exponentiation&quot;,&quot;EulersNumber&quot;,[&quot;NumberVariable&quot;,&quot;x&quot;]]]</code></li>
</ul>
</li>
<li>Test 6
<ul>
<li>input: LaTeX <code>10\%\cdot2^{100}</code>, typeset $10\%\cdot2^{100}$</li>
<li>output: JSON <code>[&quot;Multiplication&quot;,[&quot;Percentage&quot;,[&quot;Number&quot;,&quot;10&quot;]],[&quot;Exponentiation&quot;,[&quot;Number&quot;,&quot;2&quot;],[&quot;Number&quot;,&quot;100&quot;]]]</code></li>
</ul>
</li>
</ul>
<h3>can parse negations of atomics or factors to JSON</h3>
<ul>
<li>Test 1
<ul>
<li>input: LaTeX <code>-1\times2</code>, typeset $-1\times2$</li>
<li>output: JSON <code>[&quot;Multiplication&quot;,[&quot;NumberNegation&quot;,[&quot;Number&quot;,&quot;1&quot;]],[&quot;Number&quot;,&quot;2&quot;]]</code></li>
</ul>
</li>
<li>Test 2
<ul>
<li>input: LaTeX <code>x\cdot{-y}</code>, typeset $x\cdot{-y}$</li>
<li>output: JSON <code>[&quot;Multiplication&quot;,[&quot;NumberVariable&quot;,&quot;x&quot;],[&quot;NumberNegation&quot;,[&quot;NumberVariable&quot;,&quot;y&quot;]]]</code></li>
</ul>
</li>
<li>Test 3
<ul>
<li>input: LaTeX <code>{-x^2}\cdot{-3}</code>, typeset ${-x^2}\cdot{-3}$</li>
<li>output: JSON <code>[&quot;Multiplication&quot;,[&quot;NumberNegation&quot;,[&quot;Exponentiation&quot;,[&quot;NumberVariable&quot;,&quot;x&quot;],[&quot;Number&quot;,&quot;2&quot;]]],[&quot;NumberNegation&quot;,[&quot;Number&quot;,&quot;3&quot;]]]</code></li>
</ul>
</li>
<li>Test 4
<ul>
<li>input: LaTeX <code>(-x^2)\cdot(-3)</code>, typeset $(-x^2)\cdot(-3)$</li>
<li>output: JSON <code>[&quot;Multiplication&quot;,[&quot;NumberNegation&quot;,[&quot;Exponentiation&quot;,[&quot;NumberVariable&quot;,&quot;x&quot;],[&quot;Number&quot;,&quot;2&quot;]]],[&quot;NumberNegation&quot;,[&quot;Number&quot;,&quot;3&quot;]]]</code></li>
</ul>
</li>
<li>Test 5
<ul>
<li>input: LaTeX <code>----1000</code>, typeset $----1000$</li>
<li>output: JSON <code>[&quot;NumberNegation&quot;,[&quot;NumberNegation&quot;,[&quot;NumberNegation&quot;,[&quot;NumberNegation&quot;,[&quot;Number&quot;,&quot;1000&quot;]]]]]</code></li>
</ul>
</li>
</ul>
<h3>can convert additions and subtractions to JSON</h3>
<ul>
<li>Test 1
<ul>
<li>input: LaTeX <code>x+y</code>, typeset $x+y$</li>
<li>output: JSON <code>[&quot;Addition&quot;,[&quot;NumberVariable&quot;,&quot;x&quot;],[&quot;NumberVariable&quot;,&quot;y&quot;]]</code></li>
</ul>
</li>
<li>Test 2
<ul>
<li>input: LaTeX <code>1--3</code>, typeset $1--3$</li>
<li>output: JSON <code>[&quot;Subtraction&quot;,[&quot;Number&quot;,&quot;1&quot;],[&quot;NumberNegation&quot;,[&quot;Number&quot;,&quot;3&quot;]]]</code></li>
</ul>
</li>
<li>Test 3
<ul>
<li>input: LaTeX <code>A^B+C-\pi</code>, typeset $A^B+C-\pi$</li>
<li>output: JSON <code>[&quot;Addition&quot;,[&quot;Exponentiation&quot;,[&quot;NumberVariable&quot;,&quot;A&quot;],[&quot;NumberVariable&quot;,&quot;B&quot;]],[&quot;Subtraction&quot;,[&quot;NumberVariable&quot;,&quot;C&quot;],&quot;Pi&quot;]]</code></li>
</ul>
</li>
</ul>
<h3>can parse number expressions with groupers to JSON</h3>
<ul>
<li>Test 1
<ul>
<li>input: LaTeX <code>-{1\times2}</code>, typeset $-{1\times2}$</li>
<li>output: JSON <code>[&quot;NumberNegation&quot;,[&quot;Multiplication&quot;,[&quot;Number&quot;,&quot;1&quot;],[&quot;Number&quot;,&quot;2&quot;]]]</code></li>
</ul>
</li>
<li>Test 2
<ul>
<li>input: LaTeX <code>-(1\times2)</code>, typeset $-(1\times2)$</li>
<li>output: JSON <code>[&quot;NumberNegation&quot;,[&quot;Multiplication&quot;,[&quot;Number&quot;,&quot;1&quot;],[&quot;Number&quot;,&quot;2&quot;]]]</code></li>
</ul>
</li>
<li>Test 3
<ul>
<li>input: LaTeX <code>(N-1)!</code>, typeset $(N-1)!$</li>
<li>output: JSON <code>[&quot;Factorial&quot;,[&quot;Subtraction&quot;,[&quot;NumberVariable&quot;,&quot;N&quot;],[&quot;Number&quot;,&quot;1&quot;]]]</code></li>
</ul>
</li>
<li>Test 4
<ul>
<li>input: LaTeX <code>\left(N-1\right)!</code>, typeset $\left(N-1\right)!$</li>
<li>output: JSON <code>[&quot;Factorial&quot;,[&quot;Subtraction&quot;,[&quot;NumberVariable&quot;,&quot;N&quot;],[&quot;Number&quot;,&quot;1&quot;]]]</code></li>
</ul>
</li>
<li>Test 5
<ul>
<li>input: LaTeX <code>\left(N-1)!</code>, typeset $\left(N-1)!$</li>
<li>output: JSON <code>null</code></li>
</ul>
</li>
<li>Test 6
<ul>
<li>input: LaTeX <code>(N-1\right)!</code>, typeset $(N-1\right)!$</li>
<li>output: JSON <code>null</code></li>
</ul>
</li>
<li>Test 7
<ul>
<li>input: LaTeX <code>{-x}^{2\cdot{-3}}</code>, typeset ${-x}^{2\cdot{-3}}$</li>
<li>output: JSON <code>[&quot;Exponentiation&quot;,[&quot;NumberNegation&quot;,[&quot;NumberVariable&quot;,&quot;x&quot;]],[&quot;Multiplication&quot;,[&quot;Number&quot;,&quot;2&quot;],[&quot;NumberNegation&quot;,[&quot;Number&quot;,&quot;3&quot;]]]]</code></li>
</ul>
</li>
<li>Test 8
<ul>
<li>input: LaTeX <code>(-x)^(2\cdot(-3))</code>, typeset $(-x)^(2\cdot(-3))$</li>
<li>output: JSON <code>[&quot;Exponentiation&quot;,[&quot;NumberNegation&quot;,[&quot;NumberVariable&quot;,&quot;x&quot;]],[&quot;Multiplication&quot;,[&quot;Number&quot;,&quot;2&quot;],[&quot;NumberNegation&quot;,[&quot;Number&quot;,&quot;3&quot;]]]]</code></li>
</ul>
</li>
<li>Test 9
<ul>
<li>input: LaTeX <code>(-x)^{2\cdot(-3)}</code>, typeset $(-x)^{2\cdot(-3)}$</li>
<li>output: JSON <code>[&quot;Exponentiation&quot;,[&quot;NumberNegation&quot;,[&quot;NumberVariable&quot;,&quot;x&quot;]],[&quot;Multiplication&quot;,[&quot;Number&quot;,&quot;2&quot;],[&quot;NumberNegation&quot;,[&quot;Number&quot;,&quot;3&quot;]]]]</code></li>
</ul>
</li>
<li>Test 10
<ul>
<li>input: LaTeX <code>A^B+(C-D)</code>, typeset $A^B+(C-D)$</li>
<li>output: JSON <code>[&quot;Addition&quot;,[&quot;Exponentiation&quot;,[&quot;NumberVariable&quot;,&quot;A&quot;],[&quot;NumberVariable&quot;,&quot;B&quot;]],[&quot;Subtraction&quot;,[&quot;NumberVariable&quot;,&quot;C&quot;],[&quot;NumberVariable&quot;,&quot;D&quot;]]]</code></li>
</ul>
</li>
<li>Test 11
<ul>
<li>input: LaTeX <code>A^B+\left(C-D\right)</code>, typeset $A^B+\left(C-D\right)$</li>
<li>output: JSON <code>[&quot;Addition&quot;,[&quot;Exponentiation&quot;,[&quot;NumberVariable&quot;,&quot;A&quot;],[&quot;NumberVariable&quot;,&quot;B&quot;]],[&quot;Subtraction&quot;,[&quot;NumberVariable&quot;,&quot;C&quot;],[&quot;NumberVariable&quot;,&quot;D&quot;]]]</code></li>
</ul>
</li>
<li>Test 12
<ul>
<li>input: LaTeX <code>k^{1-y}\cdot(2+k)</code>, typeset $k^{1-y}\cdot(2+k)$</li>
<li>output: JSON <code>[&quot;Multiplication&quot;,[&quot;Exponentiation&quot;,[&quot;NumberVariable&quot;,&quot;k&quot;],[&quot;Subtraction&quot;,[&quot;Number&quot;,&quot;1&quot;],[&quot;NumberVariable&quot;,&quot;y&quot;]]],[&quot;Addition&quot;,[&quot;Number&quot;,&quot;2&quot;],[&quot;NumberVariable&quot;,&quot;k&quot;]]]</code></li>
</ul>
</li>
</ul>
<h3>can parse relations of numeric expressions to JSON</h3>
<ul>
<li>Test 1
<ul>
<li>input: LaTeX <code>1&gt;2</code>, typeset $1&gt;2$</li>
<li>output: JSON <code>[&quot;GreaterThan&quot;,[&quot;Number&quot;,&quot;1&quot;],[&quot;Number&quot;,&quot;2&quot;]]</code></li>
</ul>
</li>
<li>Test 2
<ul>
<li>input: LaTeX <code>1\gt2</code>, typeset $1\gt2$</li>
<li>output: JSON <code>[&quot;GreaterThan&quot;,[&quot;Number&quot;,&quot;1&quot;],[&quot;Number&quot;,&quot;2&quot;]]</code></li>
</ul>
</li>
<li>Test 3
<ul>
<li>input: LaTeX <code>1-2&lt;1+2</code>, typeset $1-2&lt;1+2$</li>
<li>output: JSON <code>[&quot;LessThan&quot;,[&quot;Subtraction&quot;,[&quot;Number&quot;,&quot;1&quot;],[&quot;Number&quot;,&quot;2&quot;]],[&quot;Addition&quot;,[&quot;Number&quot;,&quot;1&quot;],[&quot;Number&quot;,&quot;2&quot;]]]</code></li>
</ul>
</li>
<li>Test 4
<ul>
<li>input: LaTeX <code>1-2\lt1+2</code>, typeset $1-2\lt1+2$</li>
<li>output: JSON <code>[&quot;LessThan&quot;,[&quot;Subtraction&quot;,[&quot;Number&quot;,&quot;1&quot;],[&quot;Number&quot;,&quot;2&quot;]],[&quot;Addition&quot;,[&quot;Number&quot;,&quot;1&quot;],[&quot;Number&quot;,&quot;2&quot;]]]</code></li>
</ul>
</li>
<li>Test 5
<ul>
<li>input: LaTeX <code>\neg 1=2</code>, typeset $\neg 1=2$</li>
<li>output: JSON <code>[&quot;LogicalNegation&quot;,[&quot;Equals&quot;,[&quot;Number&quot;,&quot;1&quot;],[&quot;Number&quot;,&quot;2&quot;]]]</code></li>
</ul>
</li>
<li>Test 6
<ul>
<li>input: LaTeX <code>2\ge1\wedge2\le3</code>, typeset $2\ge1\wedge2\le3$</li>
<li>output: JSON <code>[&quot;Conjunction&quot;,[&quot;GreaterThanOrEqual&quot;,[&quot;Number&quot;,&quot;2&quot;],[&quot;Number&quot;,&quot;1&quot;]],[&quot;LessThanOrEqual&quot;,[&quot;Number&quot;,&quot;2&quot;],[&quot;Number&quot;,&quot;3&quot;]]]</code></li>
</ul>
</li>
<li>Test 7
<ul>
<li>input: LaTeX <code>2\geq1\wedge2\leq3</code>, typeset $2\geq1\wedge2\leq3$</li>
<li>output: JSON <code>[&quot;Conjunction&quot;,[&quot;GreaterThanOrEqual&quot;,[&quot;Number&quot;,&quot;2&quot;],[&quot;Number&quot;,&quot;1&quot;]],[&quot;LessThanOrEqual&quot;,[&quot;Number&quot;,&quot;2&quot;],[&quot;Number&quot;,&quot;3&quot;]]]</code></li>
</ul>
</li>
<li>Test 8
<ul>
<li>input: LaTeX <code>7|14</code>, typeset $7|14$</li>
<li>output: JSON <code>[&quot;BinaryRelationHolds&quot;,&quot;Divides&quot;,[&quot;Number&quot;,&quot;7&quot;],[&quot;Number&quot;,&quot;14&quot;]]</code></li>
</ul>
</li>
<li>Test 9
<ul>
<li>input: LaTeX <code>7\vert14</code>, typeset $7\vert14$</li>
<li>output: JSON <code>[&quot;BinaryRelationHolds&quot;,&quot;Divides&quot;,[&quot;Number&quot;,&quot;7&quot;],[&quot;Number&quot;,&quot;14&quot;]]</code></li>
</ul>
</li>
<li>Test 10
<ul>
<li>input: LaTeX <code>A(k) | n!</code>, typeset $A(k) | n!$</li>
<li>output: JSON <code>[&quot;BinaryRelationHolds&quot;,&quot;Divides&quot;,[&quot;NumberFunctionApplication&quot;,[&quot;FunctionVariable&quot;,&quot;A&quot;],[&quot;NumberVariable&quot;,&quot;k&quot;]],[&quot;Factorial&quot;,[&quot;NumberVariable&quot;,&quot;n&quot;]]]</code></li>
</ul>
</li>
<li>Test 11
<ul>
<li>input: LaTeX <code>A(k) \vert n!</code>, typeset $A(k) \vert n!$</li>
<li>output: JSON <code>[&quot;BinaryRelationHolds&quot;,&quot;Divides&quot;,[&quot;NumberFunctionApplication&quot;,[&quot;FunctionVariable&quot;,&quot;A&quot;],[&quot;NumberVariable&quot;,&quot;k&quot;]],[&quot;Factorial&quot;,[&quot;NumberVariable&quot;,&quot;n&quot;]]]</code></li>
</ul>
</li>
<li>Test 12
<ul>
<li>input: LaTeX <code>1-k \sim 1+k</code>, typeset $1-k \sim 1+k$</li>
<li>output: JSON <code>[&quot;BinaryRelationHolds&quot;,&quot;GenericBinaryRelation&quot;,[&quot;Subtraction&quot;,[&quot;Number&quot;,&quot;1&quot;],[&quot;NumberVariable&quot;,&quot;k&quot;]],[&quot;Addition&quot;,[&quot;Number&quot;,&quot;1&quot;],[&quot;NumberVariable&quot;,&quot;k&quot;]]]</code></li>
</ul>
</li>
<li>Test 13
<ul>
<li>input: LaTeX <code>0.99\approx1.01</code>, typeset $0.99\approx1.01$</li>
<li>output: JSON <code>[&quot;BinaryRelationHolds&quot;,&quot;ApproximatelyEqual&quot;,[&quot;Number&quot;,&quot;0.99&quot;],[&quot;Number&quot;,&quot;1.01&quot;]]</code></li>
</ul>
</li>
</ul>
<h3>converts inequality to its placeholder concept</h3>
<ul>
<li>Test 1
<ul>
<li>input: LaTeX <code>1\ne2</code>, typeset $1\ne2$</li>
<li>output: JSON <code>[&quot;NotEqual&quot;,[&quot;Number&quot;,&quot;1&quot;],[&quot;Number&quot;,&quot;2&quot;]]</code></li>
</ul>
</li>
<li>Test 2
<ul>
<li>input: LaTeX <code>1\neq2</code>, typeset $1\neq2$</li>
<li>output: JSON <code>[&quot;NotEqual&quot;,[&quot;Number&quot;,&quot;1&quot;],[&quot;Number&quot;,&quot;2&quot;]]</code></li>
</ul>
</li>
</ul>
<h3>can parse propositional logic atomics to JSON</h3>
<ul>
<li>Test 1
<ul>
<li>input: LaTeX <code>\top</code>, typeset $\top$</li>
<li>output: JSON <code>&quot;LogicalTrue&quot;</code></li>
</ul>
</li>
<li>Test 2
<ul>
<li>input: LaTeX <code>\bot</code>, typeset $\bot$</li>
<li>output: JSON <code>&quot;LogicalFalse&quot;</code></li>
</ul>
</li>
<li>Test 3
<ul>
<li>input: LaTeX <code>\rightarrow\leftarrow</code>, typeset $\rightarrow\leftarrow$</li>
<li>output: JSON <code>&quot;Contradiction&quot;</code></li>
</ul>
</li>
</ul>
<h3>can parse propositional logic conjuncts to JSON</h3>
<ul>
<li>Test 1
<ul>
<li>input: LaTeX <code>\top\wedge\bot</code>, typeset $\top\wedge\bot$</li>
<li>output: JSON <code>[&quot;Conjunction&quot;,&quot;LogicalTrue&quot;,&quot;LogicalFalse&quot;]</code></li>
</ul>
</li>
<li>Test 2
<ul>
<li>input: LaTeX <code>\neg P\wedge\neg\top</code>, typeset $\neg P\wedge\neg\top$</li>
<li>output: JSON <code>[&quot;Conjunction&quot;,[&quot;LogicalNegation&quot;,[&quot;LogicVariable&quot;,&quot;P&quot;]],[&quot;LogicalNegation&quot;,&quot;LogicalTrue&quot;]]</code></li>
</ul>
</li>
<li>Test 3
<ul>
<li>input: LaTeX <code>a\wedge b\wedge c</code>, typeset $a\wedge b\wedge c$</li>
<li>output: JSON <code>[&quot;Conjunction&quot;,[&quot;LogicVariable&quot;,&quot;a&quot;],[&quot;Conjunction&quot;,[&quot;LogicVariable&quot;,&quot;b&quot;],[&quot;LogicVariable&quot;,&quot;c&quot;]]]</code></li>
</ul>
</li>
</ul>
<h3>can parse propositional logic disjuncts to JSON</h3>
<ul>
<li>Test 1
<ul>
<li>input: LaTeX <code>\top\vee \neg A</code>, typeset $\top\vee \neg A$</li>
<li>output: JSON <code>[&quot;Disjunction&quot;,&quot;LogicalTrue&quot;,[&quot;LogicalNegation&quot;,[&quot;LogicVariable&quot;,&quot;A&quot;]]]</code></li>
</ul>
</li>
<li>Test 2
<ul>
<li>input: LaTeX <code>P\wedge Q\vee Q\wedge P</code>, typeset $P\wedge Q\vee Q\wedge P$</li>
<li>output: JSON <code>[&quot;Disjunction&quot;,[&quot;Conjunction&quot;,[&quot;LogicVariable&quot;,&quot;P&quot;],[&quot;LogicVariable&quot;,&quot;Q&quot;]],[&quot;Conjunction&quot;,[&quot;LogicVariable&quot;,&quot;Q&quot;],[&quot;LogicVariable&quot;,&quot;P&quot;]]]</code></li>
</ul>
</li>
</ul>
<h3>can parse propositional logic conditionals to JSON</h3>
<ul>
<li>Test 1
<ul>
<li>input: LaTeX <code>A\Rightarrow Q\wedge\neg P</code>, typeset $A\Rightarrow Q\wedge\neg P$</li>
<li>output: JSON <code>[&quot;Implication&quot;,[&quot;LogicVariable&quot;,&quot;A&quot;],[&quot;Conjunction&quot;,[&quot;LogicVariable&quot;,&quot;Q&quot;],[&quot;LogicalNegation&quot;,[&quot;LogicVariable&quot;,&quot;P&quot;]]]]</code></li>
</ul>
</li>
<li>Test 2
<ul>
<li>input: LaTeX <code>P\vee Q\Rightarrow Q\wedge P\Rightarrow T</code>, typeset $P\vee Q\Rightarrow Q\wedge P\Rightarrow T$</li>
<li>output: JSON <code>[&quot;Implication&quot;,[&quot;Disjunction&quot;,[&quot;LogicVariable&quot;,&quot;P&quot;],[&quot;LogicVariable&quot;,&quot;Q&quot;]],[&quot;Implication&quot;,[&quot;Conjunction&quot;,[&quot;LogicVariable&quot;,&quot;Q&quot;],[&quot;LogicVariable&quot;,&quot;P&quot;]],[&quot;LogicVariable&quot;,&quot;T&quot;]]]</code></li>
</ul>
</li>
</ul>
<h3>can parse propositional logic biconditionals to JSON</h3>
<ul>
<li>Test 1
<ul>
<li>input: LaTeX <code>A\Leftrightarrow Q\wedge\neg P</code>, typeset $A\Leftrightarrow Q\wedge\neg P$</li>
<li>output: JSON <code>[&quot;LogicalEquivalence&quot;,[&quot;LogicVariable&quot;,&quot;A&quot;],[&quot;Conjunction&quot;,[&quot;LogicVariable&quot;,&quot;Q&quot;],[&quot;LogicalNegation&quot;,[&quot;LogicVariable&quot;,&quot;P&quot;]]]]</code></li>
</ul>
</li>
<li>Test 2
<ul>
<li>input: LaTeX <code>P\vee Q\Leftrightarrow Q\wedge P\Rightarrow T</code>, typeset $P\vee Q\Leftrightarrow Q\wedge P\Rightarrow T$</li>
<li>output: JSON <code>[&quot;Implication&quot;,[&quot;LogicalEquivalence&quot;,[&quot;Disjunction&quot;,[&quot;LogicVariable&quot;,&quot;P&quot;],[&quot;LogicVariable&quot;,&quot;Q&quot;]],[&quot;Conjunction&quot;,[&quot;LogicVariable&quot;,&quot;Q&quot;],[&quot;LogicVariable&quot;,&quot;P&quot;]]],[&quot;LogicVariable&quot;,&quot;T&quot;]]</code></li>
</ul>
</li>
</ul>
<h3>can parse propositional expressions with groupers to JSON</h3>
<ul>
<li>Test 1
<ul>
<li>input: LaTeX <code>P\lor {Q\Leftrightarrow Q}\land P</code>, typeset $P\lor {Q\Leftrightarrow Q}\land P$</li>
<li>output: JSON <code>[&quot;Disjunction&quot;,[&quot;LogicVariable&quot;,&quot;P&quot;],[&quot;Conjunction&quot;,[&quot;LogicalEquivalence&quot;,[&quot;LogicVariable&quot;,&quot;Q&quot;],[&quot;LogicVariable&quot;,&quot;Q&quot;]],[&quot;LogicVariable&quot;,&quot;P&quot;]]]</code></li>
</ul>
</li>
<li>Test 2
<ul>
<li>input: LaTeX <code>\lnot{\top\Leftrightarrow\bot}</code>, typeset $\lnot{\top\Leftrightarrow\bot}$</li>
<li>output: JSON <code>[&quot;LogicalNegation&quot;,[&quot;LogicalEquivalence&quot;,&quot;LogicalTrue&quot;,&quot;LogicalFalse&quot;]]</code></li>
</ul>
</li>
<li>Test 3
<ul>
<li>input: LaTeX <code>\lnot\left(\top\Leftrightarrow\bot\right)</code>, typeset $\lnot\left(\top\Leftrightarrow\bot\right)$</li>
<li>output: JSON <code>[&quot;LogicalNegation&quot;,[&quot;LogicalEquivalence&quot;,&quot;LogicalTrue&quot;,&quot;LogicalFalse&quot;]]</code></li>
</ul>
</li>
<li>Test 4
<ul>
<li>input: LaTeX <code>\lnot(\top\Leftrightarrow\bot)</code>, typeset $\lnot(\top\Leftrightarrow\bot)$</li>
<li>output: JSON <code>[&quot;LogicalNegation&quot;,[&quot;LogicalEquivalence&quot;,&quot;LogicalTrue&quot;,&quot;LogicalFalse&quot;]]</code></li>
</ul>
</li>
</ul>
<h3>can parse simple predicate logic expressions to JSON</h3>
<ul>
<li>Test 1
<ul>
<li>input: LaTeX <code>\forall x, P</code>, typeset $\forall x, P$</li>
<li>output: JSON <code>[&quot;UniversalQuantifier&quot;,[&quot;NumberVariable&quot;,&quot;x&quot;],[&quot;LogicVariable&quot;,&quot;P&quot;]]</code></li>
</ul>
</li>
<li>Test 2
<ul>
<li>input: LaTeX <code>\exists t,\neg Q</code>, typeset $\exists t,\neg Q$</li>
<li>output: JSON <code>[&quot;ExistentialQuantifier&quot;,[&quot;NumberVariable&quot;,&quot;t&quot;],[&quot;LogicalNegation&quot;,[&quot;LogicVariable&quot;,&quot;Q&quot;]]]</code></li>
</ul>
</li>
<li>Test 3
<ul>
<li>input: LaTeX <code>\exists! k,m\Rightarrow n</code>, typeset $\exists! k,m\Rightarrow n$</li>
<li>output: JSON <code>[&quot;UniqueExistentialQuantifier&quot;,[&quot;NumberVariable&quot;,&quot;k&quot;],[&quot;Implication&quot;,[&quot;LogicVariable&quot;,&quot;m&quot;],[&quot;LogicVariable&quot;,&quot;n&quot;]]]</code></li>
</ul>
</li>
</ul>
<h3>can convert finite and empty sets to JSON</h3>
<ul>
<li>Test 1
<ul>
<li>input: LaTeX <code>\emptyset</code>, typeset $\emptyset$</li>
<li>output: JSON <code>&quot;EmptySet&quot;</code></li>
</ul>
</li>
<li>Test 2
<ul>
<li>input: LaTeX <code>\{\}</code>, typeset ${}$</li>
<li>output: JSON <code>&quot;EmptySet&quot;</code></li>
</ul>
</li>
<li>Test 3
<ul>
<li>input: LaTeX <code>\{ \}</code>, typeset ${ }$</li>
<li>output: JSON <code>&quot;EmptySet&quot;</code></li>
</ul>
</li>
<li>Test 4
<ul>
<li>input: LaTeX <code>\{ 1 \}</code>, typeset ${ 1 }$</li>
<li>output: JSON <code>[&quot;FiniteSet&quot;,[&quot;OneElementSequence&quot;,[&quot;Number&quot;,&quot;1&quot;]]]</code></li>
</ul>
</li>
<li>Test 5
<ul>
<li>input: LaTeX <code>\left\{ 1 \right\}</code>, typeset $\left{ 1 \right}$</li>
<li>output: JSON <code>[&quot;FiniteSet&quot;,[&quot;OneElementSequence&quot;,[&quot;Number&quot;,&quot;1&quot;]]]</code></li>
</ul>
</li>
<li>Test 6
<ul>
<li>input: LaTeX <code>\{1,2\}</code>, typeset ${1,2}$</li>
<li>output: JSON <code>[&quot;FiniteSet&quot;,[&quot;ElementThenSequence&quot;,[&quot;Number&quot;,&quot;1&quot;],[&quot;OneElementSequence&quot;,[&quot;Number&quot;,&quot;2&quot;]]]]</code></li>
</ul>
</li>
<li>Test 7
<ul>
<li>input: LaTeX <code>\{1, 2,   3 \}</code>, typeset ${1, 2,   3 }$</li>
<li>output: JSON <code>[&quot;FiniteSet&quot;,[&quot;ElementThenSequence&quot;,[&quot;Number&quot;,&quot;1&quot;],[&quot;ElementThenSequence&quot;,[&quot;Number&quot;,&quot;2&quot;],[&quot;OneElementSequence&quot;,[&quot;Number&quot;,&quot;3&quot;]]]]]</code></li>
</ul>
</li>
<li>Test 8
<ul>
<li>input: LaTeX <code>\{\{\},\emptyset\}</code>, typeset ${{},\emptyset}$</li>
<li>output: JSON <code>[&quot;FiniteSet&quot;,[&quot;ElementThenSequence&quot;,&quot;EmptySet&quot;,[&quot;OneElementSequence&quot;,&quot;EmptySet&quot;]]]</code></li>
</ul>
</li>
<li>Test 9
<ul>
<li>input: LaTeX <code>\{\{\emptyset\}\}</code>, typeset ${{\emptyset}}$</li>
<li>output: JSON <code>[&quot;FiniteSet&quot;,[&quot;OneElementSequence&quot;,[&quot;FiniteSet&quot;,[&quot;OneElementSequence&quot;,&quot;EmptySet&quot;]]]]</code></li>
</ul>
</li>
<li>Test 10
<ul>
<li>input: LaTeX <code>\{ 3,x \}</code>, typeset ${ 3,x }$</li>
<li>output: JSON <code>[&quot;FiniteSet&quot;,[&quot;ElementThenSequence&quot;,[&quot;Number&quot;,&quot;3&quot;],[&quot;OneElementSequence&quot;,[&quot;NumberVariable&quot;,&quot;x&quot;]]]]</code></li>
</ul>
</li>
<li>Test 11
<ul>
<li>input: LaTeX <code>\left\{ 3,x \right\}</code>, typeset $\left{ 3,x \right}$</li>
<li>output: JSON <code>[&quot;FiniteSet&quot;,[&quot;ElementThenSequence&quot;,[&quot;Number&quot;,&quot;3&quot;],[&quot;OneElementSequence&quot;,[&quot;NumberVariable&quot;,&quot;x&quot;]]]]</code></li>
</ul>
</li>
<li>Test 12
<ul>
<li>input: LaTeX <code>\{ A\cup B, A\cap B \}</code>, typeset ${ A\cup B, A\cap B }$</li>
<li>output: JSON <code>[&quot;FiniteSet&quot;,[&quot;ElementThenSequence&quot;,[&quot;SetUnion&quot;,[&quot;SetVariable&quot;,&quot;A&quot;],[&quot;SetVariable&quot;,&quot;B&quot;]],[&quot;OneElementSequence&quot;,[&quot;SetIntersection&quot;,[&quot;SetVariable&quot;,&quot;A&quot;],[&quot;SetVariable&quot;,&quot;B&quot;]]]]]</code></li>
</ul>
</li>
<li>Test 13
<ul>
<li>input: LaTeX <code>\{ 1, 2, \emptyset, K, P \}</code>, typeset ${ 1, 2, \emptyset, K, P }$</li>
<li>output: JSON <code>[&quot;FiniteSet&quot;,[&quot;ElementThenSequence&quot;,[&quot;Number&quot;,&quot;1&quot;],[&quot;ElementThenSequence&quot;,[&quot;Number&quot;,&quot;2&quot;],[&quot;ElementThenSequence&quot;,&quot;EmptySet&quot;,[&quot;ElementThenSequence&quot;,[&quot;NumberVariable&quot;,&quot;K&quot;],[&quot;OneElementSequence&quot;,[&quot;NumberVariable&quot;,&quot;P&quot;]]]]]]]</code></li>
</ul>
</li>
</ul>
<h3>can convert tuples and vectors to JSON</h3>
<ul>
<li>Test 1
<ul>
<li>input: LaTeX <code>(5,6)</code>, typeset $(5,6)$</li>
<li>output: JSON <code>[&quot;Tuple&quot;,[&quot;ElementThenSequence&quot;,[&quot;Number&quot;,&quot;5&quot;],[&quot;OneElementSequence&quot;,[&quot;Number&quot;,&quot;6&quot;]]]]</code></li>
</ul>
</li>
<li>Test 2
<ul>
<li>input: LaTeX <code>(5,A\cup B,k)</code>, typeset $(5,A\cup B,k)$</li>
<li>output: JSON <code>[&quot;Tuple&quot;,[&quot;ElementThenSequence&quot;,[&quot;Number&quot;,&quot;5&quot;],[&quot;ElementThenSequence&quot;,[&quot;SetUnion&quot;,[&quot;SetVariable&quot;,&quot;A&quot;],[&quot;SetVariable&quot;,&quot;B&quot;]],[&quot;OneElementSequence&quot;,[&quot;NumberVariable&quot;,&quot;k&quot;]]]]]</code></li>
</ul>
</li>
<li>Test 3
<ul>
<li>input: LaTeX <code>\langle5,6\rangle</code>, typeset $\langle5,6\rangle$</li>
<li>output: JSON <code>[&quot;Vector&quot;,[&quot;NumberThenSequence&quot;,[&quot;Number&quot;,&quot;5&quot;],[&quot;OneNumberSequence&quot;,[&quot;Number&quot;,&quot;6&quot;]]]]</code></li>
</ul>
</li>
<li>Test 4
<ul>
<li>input: LaTeX <code>\langle5,-7,k\rangle</code>, typeset $\langle5,-7,k\rangle$</li>
<li>output: JSON <code>[&quot;Vector&quot;,[&quot;NumberThenSequence&quot;,[&quot;Number&quot;,&quot;5&quot;],[&quot;NumberThenSequence&quot;,[&quot;NumberNegation&quot;,[&quot;Number&quot;,&quot;7&quot;]],[&quot;OneNumberSequence&quot;,[&quot;NumberVariable&quot;,&quot;k&quot;]]]]]</code></li>
</ul>
</li>
<li>Test 5
<ul>
<li>input: LaTeX <code>()</code>, typeset $()$</li>
<li>output: JSON <code>null</code></li>
</ul>
</li>
<li>Test 6
<ul>
<li>input: LaTeX <code>(())</code>, typeset $(())$</li>
<li>output: JSON <code>null</code></li>
</ul>
</li>
<li>Test 7
<ul>
<li>input: LaTeX <code>(3)</code>, typeset $(3)$</li>
<li>output: JSON <code>[&quot;Number&quot;,&quot;3&quot;]</code></li>
</ul>
</li>
<li>Test 8
<ul>
<li>input: LaTeX <code>\langle\rangle</code>, typeset $\langle\rangle$</li>
<li>output: JSON <code>null</code></li>
</ul>
</li>
<li>Test 9
<ul>
<li>input: LaTeX <code>\langle3\rangle</code>, typeset $\langle3\rangle$</li>
<li>output: JSON <code>null</code></li>
</ul>
</li>
<li>Test 10
<ul>
<li>input: LaTeX <code>((1,2),6)</code>, typeset $((1,2),6)$</li>
<li>output: JSON <code>[&quot;Tuple&quot;,[&quot;ElementThenSequence&quot;,[&quot;Tuple&quot;,[&quot;ElementThenSequence&quot;,[&quot;Number&quot;,&quot;1&quot;],[&quot;OneElementSequence&quot;,[&quot;Number&quot;,&quot;2&quot;]]]],[&quot;OneElementSequence&quot;,[&quot;Number&quot;,&quot;6&quot;]]]]</code></li>
</ul>
</li>
<li>Test 11
<ul>
<li>input: LaTeX <code>\langle(1,2),6\rangle</code>, typeset $\langle(1,2),6\rangle$</li>
<li>output: JSON <code>null</code></li>
</ul>
</li>
<li>Test 12
<ul>
<li>input: LaTeX <code>\langle\langle1,2\rangle,6\rangle</code>, typeset $\langle\langle1,2\rangle,6\rangle$</li>
<li>output: JSON <code>null</code></li>
</ul>
</li>
<li>Test 13
<ul>
<li>input: LaTeX <code>\langle A\cup B,6\rangle</code>, typeset $\langle A\cup B,6\rangle$</li>
<li>output: JSON <code>null</code></li>
</ul>
</li>
</ul>
<h3>can convert simple set memberships and subsets to JSON</h3>
<ul>
<li>Test 1
<ul>
<li>input: LaTeX <code>b\in B</code>, typeset $b\in B$</li>
<li>output: JSON <code>[&quot;NounIsElement&quot;,[&quot;NumberVariable&quot;,&quot;b&quot;],[&quot;SetVariable&quot;,&quot;B&quot;]]</code></li>
</ul>
</li>
<li>Test 2
<ul>
<li>input: LaTeX <code>2\in\{1,2\}</code>, typeset $2\in{1,2}$</li>
<li>output: JSON <code>[&quot;NounIsElement&quot;,[&quot;Number&quot;,&quot;2&quot;],[&quot;FiniteSet&quot;,[&quot;ElementThenSequence&quot;,[&quot;Number&quot;,&quot;1&quot;],[&quot;OneElementSequence&quot;,[&quot;Number&quot;,&quot;2&quot;]]]]]</code></li>
</ul>
</li>
<li>Test 3
<ul>
<li>input: LaTeX <code>X\in a\cup b</code>, typeset $X\in a\cup b$</li>
<li>output: JSON <code>[&quot;NounIsElement&quot;,[&quot;NumberVariable&quot;,&quot;X&quot;],[&quot;SetUnion&quot;,[&quot;SetVariable&quot;,&quot;a&quot;],[&quot;SetVariable&quot;,&quot;b&quot;]]]</code></li>
</ul>
</li>
<li>Test 4
<ul>
<li>input: LaTeX <code>A\cup B\in X\cup Y</code>, typeset $A\cup B\in X\cup Y$</li>
<li>output: JSON <code>[&quot;NounIsElement&quot;,[&quot;SetUnion&quot;,[&quot;SetVariable&quot;,&quot;A&quot;],[&quot;SetVariable&quot;,&quot;B&quot;]],[&quot;SetUnion&quot;,[&quot;SetVariable&quot;,&quot;X&quot;],[&quot;SetVariable&quot;,&quot;Y&quot;]]]</code></li>
</ul>
</li>
<li>Test 5
<ul>
<li>input: LaTeX <code>A\subset\bar B</code>, typeset $A\subset\bar B$</li>
<li>output: JSON <code>[&quot;Subset&quot;,[&quot;SetVariable&quot;,&quot;A&quot;],[&quot;SetComplement&quot;,[&quot;SetVariable&quot;,&quot;B&quot;]]]</code></li>
</ul>
</li>
<li>Test 6
<ul>
<li>input: LaTeX <code>A\subset B'</code>, typeset $A\subset B'$</li>
<li>output: JSON <code>[&quot;Subset&quot;,[&quot;SetVariable&quot;,&quot;A&quot;],[&quot;SetComplement&quot;,[&quot;SetVariable&quot;,&quot;B&quot;]]]</code></li>
</ul>
</li>
<li>Test 7
<ul>
<li>input: LaTeX <code>u\cap v\subseteq u\cup v</code>, typeset $u\cap v\subseteq u\cup v$</li>
<li>output: JSON <code>[&quot;SubsetOrEqual&quot;,[&quot;SetIntersection&quot;,[&quot;SetVariable&quot;,&quot;u&quot;],[&quot;SetVariable&quot;,&quot;v&quot;]],[&quot;SetUnion&quot;,[&quot;SetVariable&quot;,&quot;u&quot;],[&quot;SetVariable&quot;,&quot;v&quot;]]]</code></li>
</ul>
</li>
<li>Test 8
<ul>
<li>input: LaTeX <code>\{1\}\subseteq\{1\}\cup\{2\}</code>, typeset ${1}\subseteq{1}\cup{2}$</li>
<li>output: JSON <code>[&quot;SubsetOrEqual&quot;,[&quot;FiniteSet&quot;,[&quot;OneElementSequence&quot;,[&quot;Number&quot;,&quot;1&quot;]]],[&quot;SetUnion&quot;,[&quot;FiniteSet&quot;,[&quot;OneElementSequence&quot;,[&quot;Number&quot;,&quot;1&quot;]]],[&quot;FiniteSet&quot;,[&quot;OneElementSequence&quot;,[&quot;Number&quot;,&quot;2&quot;]]]]]</code></li>
</ul>
</li>
<li>Test 9
<ul>
<li>input: LaTeX <code>p\in U\times V</code>, typeset $p\in U\times V$</li>
<li>output: JSON <code>[&quot;NounIsElement&quot;,[&quot;NumberVariable&quot;,&quot;p&quot;],[&quot;SetCartesianProduct&quot;,[&quot;SetVariable&quot;,&quot;U&quot;],[&quot;SetVariable&quot;,&quot;V&quot;]]]</code></li>
</ul>
</li>
<li>Test 10
<ul>
<li>input: LaTeX <code>q \in U'\cup V\times W</code>, typeset $q \in U'\cup V\times W$</li>
<li>output: JSON <code>[&quot;NounIsElement&quot;,[&quot;NumberVariable&quot;,&quot;q&quot;],[&quot;SetUnion&quot;,[&quot;SetComplement&quot;,[&quot;SetVariable&quot;,&quot;U&quot;]],[&quot;SetCartesianProduct&quot;,[&quot;SetVariable&quot;,&quot;V&quot;],[&quot;SetVariable&quot;,&quot;W&quot;]]]]</code></li>
</ul>
</li>
<li>Test 11
<ul>
<li>input: LaTeX <code>(a,b)\in A\times B</code>, typeset $(a,b)\in A\times B$</li>
<li>output: JSON <code>[&quot;NounIsElement&quot;,[&quot;Tuple&quot;,[&quot;ElementThenSequence&quot;,[&quot;NumberVariable&quot;,&quot;a&quot;],[&quot;OneElementSequence&quot;,[&quot;NumberVariable&quot;,&quot;b&quot;]]]],[&quot;SetCartesianProduct&quot;,[&quot;SetVariable&quot;,&quot;A&quot;],[&quot;SetVariable&quot;,&quot;B&quot;]]]</code></li>
</ul>
</li>
<li>Test 12
<ul>
<li>input: LaTeX <code>\langle a,b\rangle\in A\times B</code>, typeset $\langle a,b\rangle\in A\times B$</li>
<li>output: JSON <code>[&quot;NounIsElement&quot;,[&quot;Vector&quot;,[&quot;NumberThenSequence&quot;,[&quot;NumberVariable&quot;,&quot;a&quot;],[&quot;OneNumberSequence&quot;,[&quot;NumberVariable&quot;,&quot;b&quot;]]]],[&quot;SetCartesianProduct&quot;,[&quot;SetVariable&quot;,&quot;A&quot;],[&quot;SetVariable&quot;,&quot;B&quot;]]]</code></li>
</ul>
</li>
</ul>
<h3>converts &quot;notin&quot; notation to its placeholder concept</h3>
<ul>
<li>Test 1
<ul>
<li>input: LaTeX <code>a\notin A</code>, typeset $a\notin A$</li>
<li>output: JSON <code>[&quot;NounIsNotElement&quot;,[&quot;NumberVariable&quot;,&quot;a&quot;],[&quot;SetVariable&quot;,&quot;A&quot;]]</code></li>
</ul>
</li>
<li>Test 2
<ul>
<li>input: LaTeX <code>\emptyset\notin\emptyset</code>, typeset $\emptyset\notin\emptyset$</li>
<li>output: JSON <code>[&quot;NounIsNotElement&quot;,&quot;EmptySet&quot;,&quot;EmptySet&quot;]</code></li>
</ul>
</li>
<li>Test 3
<ul>
<li>input: LaTeX <code>3-5 \notin K\cap P</code>, typeset $3-5 \notin K\cap P$</li>
<li>output: JSON <code>[&quot;NounIsNotElement&quot;,[&quot;Subtraction&quot;,[&quot;Number&quot;,&quot;3&quot;],[&quot;Number&quot;,&quot;5&quot;]],[&quot;SetIntersection&quot;,[&quot;SetVariable&quot;,&quot;K&quot;],[&quot;SetVariable&quot;,&quot;P&quot;]]]</code></li>
</ul>
</li>
</ul>
<h3>can parse to JSON sentences built from various relations</h3>
<ul>
<li>Test 1
<ul>
<li>input: LaTeX <code>P\vee b\in B</code>, typeset $P\vee b\in B$</li>
<li>output: JSON <code>[&quot;Disjunction&quot;,[&quot;LogicVariable&quot;,&quot;P&quot;],[&quot;NounIsElement&quot;,[&quot;NumberVariable&quot;,&quot;b&quot;],[&quot;SetVariable&quot;,&quot;B&quot;]]]</code></li>
</ul>
</li>
<li>Test 2
<ul>
<li>input: LaTeX <code>{P \vee b} \in B</code>, typeset ${P \vee b} \in B$</li>
<li>output: JSON <code>[&quot;PropositionIsElement&quot;,[&quot;Disjunction&quot;,[&quot;LogicVariable&quot;,&quot;P&quot;],[&quot;LogicVariable&quot;,&quot;b&quot;]],[&quot;SetVariable&quot;,&quot;B&quot;]]</code></li>
</ul>
</li>
<li>Test 3
<ul>
<li>input: LaTeX <code>\forall x, x\in X</code>, typeset $\forall x, x\in X$</li>
<li>output: JSON <code>[&quot;UniversalQuantifier&quot;,[&quot;NumberVariable&quot;,&quot;x&quot;],[&quot;NounIsElement&quot;,[&quot;NumberVariable&quot;,&quot;x&quot;],[&quot;SetVariable&quot;,&quot;X&quot;]]]</code></li>
</ul>
</li>
<li>Test 4
<ul>
<li>input: LaTeX <code>A\subseteq B\wedge B\subseteq A</code>, typeset $A\subseteq B\wedge B\subseteq A$</li>
<li>output: JSON <code>[&quot;Conjunction&quot;,[&quot;SubsetOrEqual&quot;,[&quot;SetVariable&quot;,&quot;A&quot;],[&quot;SetVariable&quot;,&quot;B&quot;]],[&quot;SubsetOrEqual&quot;,[&quot;SetVariable&quot;,&quot;B&quot;],[&quot;SetVariable&quot;,&quot;A&quot;]]]</code></li>
</ul>
</li>
<li>Test 5
<ul>
<li>input: LaTeX <code>R = A\cup B</code>, typeset $R = A\cup B$</li>
<li>output: JSON <code>[&quot;Equals&quot;,[&quot;NumberVariable&quot;,&quot;R&quot;],[&quot;SetUnion&quot;,[&quot;SetVariable&quot;,&quot;A&quot;],[&quot;SetVariable&quot;,&quot;B&quot;]]]</code></li>
</ul>
</li>
<li>Test 6
<ul>
<li>input: LaTeX <code>\forall n, n|n!</code>, typeset $\forall n, n|n!$</li>
<li>output: JSON <code>[&quot;UniversalQuantifier&quot;,[&quot;NumberVariable&quot;,&quot;n&quot;],[&quot;BinaryRelationHolds&quot;,&quot;Divides&quot;,[&quot;NumberVariable&quot;,&quot;n&quot;],[&quot;Factorial&quot;,[&quot;NumberVariable&quot;,&quot;n&quot;]]]]</code></li>
</ul>
</li>
<li>Test 7
<ul>
<li>input: LaTeX <code>a\sim b\Rightarrow b\sim a</code>, typeset $a\sim b\Rightarrow b\sim a$</li>
<li>output: JSON <code>[&quot;Implication&quot;,[&quot;BinaryRelationHolds&quot;,&quot;GenericBinaryRelation&quot;,[&quot;NumberVariable&quot;,&quot;a&quot;],[&quot;NumberVariable&quot;,&quot;b&quot;]],[&quot;BinaryRelationHolds&quot;,&quot;GenericBinaryRelation&quot;,[&quot;NumberVariable&quot;,&quot;b&quot;],[&quot;NumberVariable&quot;,&quot;a&quot;]]]</code></li>
</ul>
</li>
</ul>
<h3>can parse notation related to functions</h3>
<ul>
<li>Test 1
<ul>
<li>input: LaTeX <code>f:A\to B</code>, typeset $f:A\to B$</li>
<li>output: JSON <code>[&quot;FunctionSignature&quot;,[&quot;FunctionVariable&quot;,&quot;f&quot;],[&quot;SetVariable&quot;,&quot;A&quot;],[&quot;SetVariable&quot;,&quot;B&quot;]]</code></li>
</ul>
</li>
<li>Test 2
<ul>
<li>input: LaTeX <code>f\colon A\to B</code>, typeset $f\colon A\to B$</li>
<li>output: JSON <code>[&quot;FunctionSignature&quot;,[&quot;FunctionVariable&quot;,&quot;f&quot;],[&quot;SetVariable&quot;,&quot;A&quot;],[&quot;SetVariable&quot;,&quot;B&quot;]]</code></li>
</ul>
</li>
<li>Test 3
<ul>
<li>input: LaTeX <code>\neg F:X\cup Y\rightarrow Z</code>, typeset $\neg F:X\cup Y\rightarrow Z$</li>
<li>output: JSON <code>[&quot;LogicalNegation&quot;,[&quot;FunctionSignature&quot;,[&quot;FunctionVariable&quot;,&quot;F&quot;],[&quot;SetUnion&quot;,[&quot;SetVariable&quot;,&quot;X&quot;],[&quot;SetVariable&quot;,&quot;Y&quot;]],[&quot;SetVariable&quot;,&quot;Z&quot;]]]</code></li>
</ul>
</li>
<li>Test 4
<ul>
<li>input: LaTeX <code>\neg F\colon X\cup Y\rightarrow Z</code>, typeset $\neg F\colon X\cup Y\rightarrow Z$</li>
<li>output: JSON <code>[&quot;LogicalNegation&quot;,[&quot;FunctionSignature&quot;,[&quot;FunctionVariable&quot;,&quot;F&quot;],[&quot;SetUnion&quot;,[&quot;SetVariable&quot;,&quot;X&quot;],[&quot;SetVariable&quot;,&quot;Y&quot;]],[&quot;SetVariable&quot;,&quot;Z&quot;]]]</code></li>
</ul>
</li>
<li>Test 5
<ul>
<li>input: LaTeX <code>f\circ g:A\to C</code>, typeset $f\circ g:A\to C$</li>
<li>output: JSON <code>[&quot;FunctionSignature&quot;,[&quot;FunctionComposition&quot;,[&quot;FunctionVariable&quot;,&quot;f&quot;],[&quot;FunctionVariable&quot;,&quot;g&quot;]],[&quot;SetVariable&quot;,&quot;A&quot;],[&quot;SetVariable&quot;,&quot;C&quot;]]</code></li>
</ul>
</li>
<li>Test 6
<ul>
<li>input: LaTeX <code>f(x)</code>, typeset $f(x)$</li>
<li>output: JSON <code>[&quot;NumberFunctionApplication&quot;,[&quot;FunctionVariable&quot;,&quot;f&quot;],[&quot;NumberVariable&quot;,&quot;x&quot;]]</code></li>
</ul>
</li>
<li>Test 7
<ul>
<li>input: LaTeX <code>f^{-1}(g^{-1}(10))</code>, typeset $f^{-1}(g^{-1}(10))$</li>
<li>output: JSON <code>[&quot;NumberFunctionApplication&quot;,[&quot;FunctionInverse&quot;,[&quot;FunctionVariable&quot;,&quot;f&quot;]],[&quot;NumberFunctionApplication&quot;,[&quot;FunctionInverse&quot;,[&quot;FunctionVariable&quot;,&quot;g&quot;]],[&quot;Number&quot;,&quot;10&quot;]]]</code></li>
</ul>
</li>
<li>Test 8
<ul>
<li>input: LaTeX <code>E(L')</code>, typeset $E(L')$</li>
<li>output: JSON <code>[&quot;NumberFunctionApplication&quot;,[&quot;FunctionVariable&quot;,&quot;E&quot;],[&quot;SetComplement&quot;,[&quot;SetVariable&quot;,&quot;L&quot;]]]</code></li>
</ul>
</li>
<li>Test 9
<ul>
<li>input: LaTeX <code>\emptyset\cap f(2)</code>, typeset $\emptyset\cap f(2)$</li>
<li>output: JSON <code>[&quot;SetIntersection&quot;,&quot;EmptySet&quot;,[&quot;SetFunctionApplication&quot;,[&quot;FunctionVariable&quot;,&quot;f&quot;],[&quot;Number&quot;,&quot;2&quot;]]]</code></li>
</ul>
</li>
<li>Test 10
<ul>
<li>input: LaTeX <code>P(e)\wedge Q(3+b)</code>, typeset $P(e)\wedge Q(3+b)$</li>
<li>output: JSON <code>[&quot;Conjunction&quot;,[&quot;PropositionFunctionApplication&quot;,[&quot;FunctionVariable&quot;,&quot;P&quot;],&quot;EulersNumber&quot;],[&quot;PropositionFunctionApplication&quot;,[&quot;FunctionVariable&quot;,&quot;Q&quot;],[&quot;Addition&quot;,[&quot;Number&quot;,&quot;3&quot;],[&quot;NumberVariable&quot;,&quot;b&quot;]]]]</code></li>
</ul>
</li>
<li>Test 11
<ul>
<li>input: LaTeX <code>F=G\circ H^{-1}</code>, typeset $F=G\circ H^{-1}$</li>
<li>output: JSON <code>[&quot;EqualFunctions&quot;,[&quot;FunctionVariable&quot;,&quot;F&quot;],[&quot;FunctionComposition&quot;,[&quot;FunctionVariable&quot;,&quot;G&quot;],[&quot;FunctionInverse&quot;,[&quot;FunctionVariable&quot;,&quot;H&quot;]]]]</code></li>
</ul>
</li>
</ul>
<h3>can parse trigonometric functions correctly</h3>
<ul>
<li>Test 1
<ul>
<li>input: LaTeX <code>\sin x</code>, typeset $\sin x$</li>
<li>output: JSON <code>[&quot;PrefixFunctionApplication&quot;,&quot;SineFunction&quot;,[&quot;NumberVariable&quot;,&quot;x&quot;]]</code></li>
</ul>
</li>
<li>Test 2
<ul>
<li>input: LaTeX <code>\cos\pi\cdot x</code>, typeset $\cos\pi\cdot x$</li>
<li>output: JSON <code>[&quot;PrefixFunctionApplication&quot;,&quot;CosineFunction&quot;,[&quot;Multiplication&quot;,&quot;Pi&quot;,[&quot;NumberVariable&quot;,&quot;x&quot;]]]</code></li>
</ul>
</li>
<li>Test 3
<ul>
<li>input: LaTeX <code>\tan t</code>, typeset $\tan t$</li>
<li>output: JSON <code>[&quot;PrefixFunctionApplication&quot;,&quot;TangentFunction&quot;,[&quot;NumberVariable&quot;,&quot;t&quot;]]</code></li>
</ul>
</li>
<li>Test 4
<ul>
<li>input: LaTeX <code>1\div\cot\pi</code>, typeset $1\div\cot\pi$</li>
<li>output: JSON <code>[&quot;Division&quot;,[&quot;Number&quot;,&quot;1&quot;],[&quot;PrefixFunctionApplication&quot;,&quot;CotangentFunction&quot;,&quot;Pi&quot;]]</code></li>
</ul>
</li>
<li>Test 5
<ul>
<li>input: LaTeX <code>\sec y=\csc y</code>, typeset $\sec y=\csc y$</li>
<li>output: JSON <code>[&quot;Equals&quot;,[&quot;PrefixFunctionApplication&quot;,&quot;SecantFunction&quot;,[&quot;NumberVariable&quot;,&quot;y&quot;]],[&quot;PrefixFunctionApplication&quot;,&quot;CosecantFunction&quot;,[&quot;NumberVariable&quot;,&quot;y&quot;]]]</code></li>
</ul>
</li>
</ul>
<h3>can parse logarithms correctly</h3>
<ul>
<li>Test 1
<ul>
<li>input: LaTeX <code>\log n</code>, typeset $\log n$</li>
<li>output: JSON <code>[&quot;PrefixFunctionApplication&quot;,&quot;Logarithm&quot;,[&quot;NumberVariable&quot;,&quot;n&quot;]]</code></li>
</ul>
</li>
<li>Test 2
<ul>
<li>input: LaTeX <code>1+\ln{x}</code>, typeset $1+\ln{x}$</li>
<li>output: JSON <code>[&quot;Addition&quot;,[&quot;Number&quot;,&quot;1&quot;],[&quot;PrefixFunctionApplication&quot;,&quot;NaturalLogarithm&quot;,[&quot;NumberVariable&quot;,&quot;x&quot;]]]</code></li>
</ul>
</li>
<li>Test 3
<ul>
<li>input: LaTeX <code>\log_2 1024</code>, typeset $\log_2 1024$</li>
<li>output: JSON <code>[&quot;PrefixFunctionApplication&quot;,[&quot;LogarithmWithBase&quot;,[&quot;Number&quot;,&quot;2&quot;]],[&quot;Number&quot;,&quot;1024&quot;]]</code></li>
</ul>
</li>
<li>Test 4
<ul>
<li>input: LaTeX <code>\log_{2}{1024}</code>, typeset $\log_{2}{1024}$</li>
<li>output: JSON <code>[&quot;PrefixFunctionApplication&quot;,[&quot;LogarithmWithBase&quot;,[&quot;Number&quot;,&quot;2&quot;]],[&quot;Number&quot;,&quot;1024&quot;]]</code></li>
</ul>
</li>
<li>Test 5
<ul>
<li>input: LaTeX <code>\log n \div \log\log n</code>, typeset $\log n \div \log\log n$</li>
<li>output: JSON <code>[&quot;Division&quot;,[&quot;PrefixFunctionApplication&quot;,&quot;Logarithm&quot;,[&quot;NumberVariable&quot;,&quot;n&quot;]],[&quot;PrefixFunctionApplication&quot;,&quot;Logarithm&quot;,[&quot;PrefixFunctionApplication&quot;,&quot;Logarithm&quot;,[&quot;NumberVariable&quot;,&quot;n&quot;]]]]</code></li>
</ul>
</li>
</ul>
<h3>can parse equivalence classes and treat them as sets</h3>
<ul>
<li>Test 1
<ul>
<li>input: LaTeX <code>[1,\approx]</code>, typeset $[1,\approx]$</li>
<li>output: JSON <code>[&quot;EquivalenceClass&quot;,[&quot;Number&quot;,&quot;1&quot;],&quot;ApproximatelyEqual&quot;]</code></li>
</ul>
</li>
<li>Test 2
<ul>
<li>input: LaTeX <code>\left[1,\approx\right]</code>, typeset $\left[1,\approx\right]$</li>
<li>output: JSON <code>[&quot;EquivalenceClass&quot;,[&quot;Number&quot;,&quot;1&quot;],&quot;ApproximatelyEqual&quot;]</code></li>
</ul>
</li>
<li>Test 3
<ul>
<li>input: LaTeX <code>\lbrack1,\approx\rbrack</code>, typeset $\lbrack1,\approx\rbrack$</li>
<li>output: JSON <code>[&quot;EquivalenceClass&quot;,[&quot;Number&quot;,&quot;1&quot;],&quot;ApproximatelyEqual&quot;]</code></li>
</ul>
</li>
<li>Test 4
<ul>
<li>input: LaTeX <code>\left\lbrack1,\approx\right\rbrack</code>, typeset $\left\lbrack1,\approx\right\rbrack$</li>
<li>output: JSON <code>[&quot;EquivalenceClass&quot;,[&quot;Number&quot;,&quot;1&quot;],&quot;ApproximatelyEqual&quot;]</code></li>
</ul>
</li>
<li>Test 5
<ul>
<li>input: LaTeX <code>\left[1,\approx]</code>, typeset $\left[1,\approx]$</li>
<li>output: JSON <code>null</code></li>
</ul>
</li>
<li>Test 6
<ul>
<li>input: LaTeX <code>[1,\approx\right]</code>, typeset $[1,\approx\right]$</li>
<li>output: JSON <code>null</code></li>
</ul>
</li>
<li>Test 7
<ul>
<li>input: LaTeX <code>[x+2,\sim]</code>, typeset $[x+2,\sim]$</li>
<li>output: JSON <code>[&quot;EquivalenceClass&quot;,[&quot;Addition&quot;,[&quot;NumberVariable&quot;,&quot;x&quot;],[&quot;Number&quot;,&quot;2&quot;]],&quot;GenericBinaryRelation&quot;]</code></li>
</ul>
</li>
<li>Test 8
<ul>
<li>input: LaTeX <code>[1,\approx]\cup[2,\approx]</code>, typeset $[1,\approx]\cup[2,\approx]$</li>
<li>output: JSON <code>[&quot;SetUnion&quot;,[&quot;EquivalenceClass&quot;,[&quot;Number&quot;,&quot;1&quot;],&quot;ApproximatelyEqual&quot;],[&quot;EquivalenceClass&quot;,[&quot;Number&quot;,&quot;2&quot;],&quot;ApproximatelyEqual&quot;]]</code></li>
</ul>
</li>
<li>Test 9
<ul>
<li>input: LaTeX <code>7\in[7,\sim]</code>, typeset $7\in[7,\sim]$</li>
<li>output: JSON <code>[&quot;NounIsElement&quot;,[&quot;Number&quot;,&quot;7&quot;],[&quot;EquivalenceClass&quot;,[&quot;Number&quot;,&quot;7&quot;],&quot;GenericBinaryRelation&quot;]]</code></li>
</ul>
</li>
<li>Test 10
<ul>
<li>input: LaTeX <code>[P]</code>, typeset $[P]$</li>
<li>output: JSON <code>[&quot;GenericEquivalenceClass&quot;,[&quot;NumberVariable&quot;,&quot;P&quot;]]</code></li>
</ul>
</li>
<li>Test 11
<ul>
<li>input: LaTeX <code>\left[P\right]</code>, typeset $\left[P\right]$</li>
<li>output: JSON <code>[&quot;GenericEquivalenceClass&quot;,[&quot;NumberVariable&quot;,&quot;P&quot;]]</code></li>
</ul>
</li>
</ul>
<h3>can parse equivalence and classes mod a number</h3>
<ul>
<li>Test 1
<ul>
<li>input: LaTeX <code>5\equiv11\mod3</code>, typeset $5\equiv11\mod3$</li>
<li>output: JSON <code>[&quot;EquivalentModulo&quot;,[&quot;Number&quot;,&quot;5&quot;],[&quot;Number&quot;,&quot;11&quot;],[&quot;Number&quot;,&quot;3&quot;]]</code></li>
</ul>
</li>
<li>Test 2
<ul>
<li>input: LaTeX <code>5\equiv_3 11</code>, typeset $5\equiv_3 11$</li>
<li>output: JSON <code>[&quot;EquivalentModulo&quot;,[&quot;Number&quot;,&quot;5&quot;],[&quot;Number&quot;,&quot;11&quot;],[&quot;Number&quot;,&quot;3&quot;]]</code></li>
</ul>
</li>
<li>Test 3
<ul>
<li>input: LaTeX <code>k \equiv m \mod n</code>, typeset $k \equiv m \mod n$</li>
<li>output: JSON <code>[&quot;EquivalentModulo&quot;,[&quot;NumberVariable&quot;,&quot;k&quot;],[&quot;NumberVariable&quot;,&quot;m&quot;],[&quot;NumberVariable&quot;,&quot;n&quot;]]</code></li>
</ul>
</li>
<li>Test 4
<ul>
<li>input: LaTeX <code>k \equiv_n m</code>, typeset $k \equiv_n m$</li>
<li>output: JSON <code>[&quot;EquivalentModulo&quot;,[&quot;NumberVariable&quot;,&quot;k&quot;],[&quot;NumberVariable&quot;,&quot;m&quot;],[&quot;NumberVariable&quot;,&quot;n&quot;]]</code></li>
</ul>
</li>
<li>Test 5
<ul>
<li>input: LaTeX <code>k \equiv_{n} m</code>, typeset $k \equiv_{n} m$</li>
<li>output: JSON <code>[&quot;EquivalentModulo&quot;,[&quot;NumberVariable&quot;,&quot;k&quot;],[&quot;NumberVariable&quot;,&quot;m&quot;],[&quot;NumberVariable&quot;,&quot;n&quot;]]</code></li>
</ul>
</li>
<li>Test 6
<ul>
<li>input: LaTeX <code>\emptyset \subset [-1,\equiv_10]</code>, typeset $\emptyset \subset [-1,\equiv_10]$</li>
<li>output: JSON <code>[&quot;Subset&quot;,&quot;EmptySet&quot;,[&quot;EquivalenceClassModulo&quot;,[&quot;NumberNegation&quot;,[&quot;Number&quot;,&quot;1&quot;]],[&quot;Number&quot;,&quot;10&quot;]]]</code></li>
</ul>
</li>
<li>Test 7
<ul>
<li>input: LaTeX <code>\emptyset \subset \left[-1,\equiv_10\right]</code>, typeset $\emptyset \subset \left[-1,\equiv_10\right]$</li>
<li>output: JSON <code>[&quot;Subset&quot;,&quot;EmptySet&quot;,[&quot;EquivalenceClassModulo&quot;,[&quot;NumberNegation&quot;,[&quot;Number&quot;,&quot;1&quot;]],[&quot;Number&quot;,&quot;10&quot;]]]</code></li>
</ul>
</li>
</ul>
<h3>can parse type sentences and combinations of them</h3>
<ul>
<li>Test 1
<ul>
<li>input: LaTeX <code>x \text{is a set}</code>, typeset $x \text{is a set}$</li>
<li>output: JSON <code>[&quot;HasType&quot;,[&quot;NumberVariable&quot;,&quot;x&quot;],&quot;SetType&quot;]</code></li>
</ul>
</li>
<li>Test 2
<ul>
<li>input: LaTeX <code>n \text{is }\text{a number}</code>, typeset $n \text{is }\text{a number}$</li>
<li>output: JSON <code>[&quot;HasType&quot;,[&quot;NumberVariable&quot;,&quot;n&quot;],&quot;NumberType&quot;]</code></li>
</ul>
</li>
<li>Test 3
<ul>
<li>input: LaTeX <code>S\text{is}~\text{a partial order}</code>, typeset $S\text{is}~\text{a partial order}$</li>
<li>output: JSON <code>[&quot;HasType&quot;,[&quot;NumberVariable&quot;,&quot;S&quot;],&quot;PartialOrderType&quot;]</code></li>
</ul>
</li>
<li>Test 4
<ul>
<li>input: LaTeX <code>1\text{is a number}\wedge 10\text{is a number}</code>, typeset $1\text{is a number}\wedge 10\text{is a number}$</li>
<li>output: JSON <code>[&quot;Conjunction&quot;,[&quot;HasType&quot;,[&quot;Number&quot;,&quot;1&quot;],&quot;NumberType&quot;],[&quot;HasType&quot;,[&quot;Number&quot;,&quot;10&quot;],&quot;NumberType&quot;]]</code></li>
</ul>
</li>
<li>Test 5
<ul>
<li>input: LaTeX <code>R\text{is an equivalence relation}\Rightarrow R\text{is a relation}</code>, typeset $R\text{is an equivalence relation}\Rightarrow R\text{is a relation}$</li>
<li>output: JSON <code>[&quot;Implication&quot;,[&quot;HasType&quot;,[&quot;NumberVariable&quot;,&quot;R&quot;],&quot;EquivalenceRelationType&quot;],[&quot;HasType&quot;,[&quot;NumberVariable&quot;,&quot;R&quot;],&quot;RelationType&quot;]]</code></li>
</ul>
</li>
</ul>
<h3>can parse notation for expression function application</h3>
<ul>
<li>Test 1
<ul>
<li>input: LaTeX <code>\mathcal{f}(x)</code>, typeset $\mathcal{f}(x)$</li>
<li>output: JSON <code>[&quot;NumberEFA&quot;,[&quot;FunctionVariable&quot;,&quot;f&quot;],[&quot;NumberVariable&quot;,&quot;x&quot;]]</code></li>
</ul>
</li>
<li>Test 2
<ul>
<li>input: LaTeX <code>F(\mathcal{k}(10))</code>, typeset $F(\mathcal{k}(10))$</li>
<li>output: JSON <code>[&quot;NumberFunctionApplication&quot;,[&quot;FunctionVariable&quot;,&quot;F&quot;],[&quot;NumberEFA&quot;,[&quot;FunctionVariable&quot;,&quot;k&quot;],[&quot;Number&quot;,&quot;10&quot;]]]</code></li>
</ul>
</li>
<li>Test 3
<ul>
<li>input: LaTeX <code>\mathcal{E}(L')</code>, typeset $\mathcal{E}(L')$</li>
<li>output: JSON <code>[&quot;NumberEFA&quot;,[&quot;FunctionVariable&quot;,&quot;E&quot;],[&quot;SetComplement&quot;,[&quot;SetVariable&quot;,&quot;L&quot;]]]</code></li>
</ul>
</li>
<li>Test 4
<ul>
<li>input: LaTeX <code>\emptyset\cap\mathcal{f}(2)</code>, typeset $\emptyset\cap\mathcal{f}(2)$</li>
<li>output: JSON <code>[&quot;SetIntersection&quot;,&quot;EmptySet&quot;,[&quot;SetEFA&quot;,[&quot;FunctionVariable&quot;,&quot;f&quot;],[&quot;Number&quot;,&quot;2&quot;]]]</code></li>
</ul>
</li>
<li>Test 5
<ul>
<li>input: LaTeX <code>\mathcal{P}(x)\wedge\mathcal{Q}(y)</code>, typeset $\mathcal{P}(x)\wedge\mathcal{Q}(y)$</li>
<li>output: JSON <code>[&quot;Conjunction&quot;,[&quot;PropositionEFA&quot;,[&quot;FunctionVariable&quot;,&quot;P&quot;],[&quot;NumberVariable&quot;,&quot;x&quot;]],[&quot;PropositionEFA&quot;,[&quot;FunctionVariable&quot;,&quot;Q&quot;],[&quot;NumberVariable&quot;,&quot;y&quot;]]]</code></li>
</ul>
</li>
</ul>
<h3>can parse notation for assumptions</h3>
<ul>
<li>Test 1
<ul>
<li>input: LaTeX <code>\text{Assume }X</code>, typeset $\text{Assume }X$</li>
<li>output: JSON <code>[&quot;Given_Variant1&quot;,[&quot;LogicVariable&quot;,&quot;X&quot;]]</code></li>
</ul>
</li>
<li>Test 2
<ul>
<li>input: LaTeX <code>\text{assume }X</code>, typeset $\text{assume }X$</li>
<li>output: JSON <code>[&quot;Given_Variant2&quot;,[&quot;LogicVariable&quot;,&quot;X&quot;]]</code></li>
</ul>
</li>
<li>Test 3
<ul>
<li>input: LaTeX <code>\text{Given }X</code>, typeset $\text{Given }X$</li>
<li>output: JSON <code>[&quot;Given_Variant3&quot;,[&quot;LogicVariable&quot;,&quot;X&quot;]]</code></li>
</ul>
</li>
<li>Test 4
<ul>
<li>input: LaTeX <code>\text{given }X</code>, typeset $\text{given }X$</li>
<li>output: JSON <code>[&quot;Given_Variant4&quot;,[&quot;LogicVariable&quot;,&quot;X&quot;]]</code></li>
</ul>
</li>
<li>Test 5
<ul>
<li>input: LaTeX <code>\text{Assume }k=1000</code>, typeset $\text{Assume }k=1000$</li>
<li>output: JSON <code>[&quot;Given_Variant1&quot;,[&quot;Equals&quot;,[&quot;NumberVariable&quot;,&quot;k&quot;],[&quot;Number&quot;,&quot;1000&quot;]]]</code></li>
</ul>
</li>
<li>Test 6
<ul>
<li>input: LaTeX <code>\text{assume }k=1000</code>, typeset $\text{assume }k=1000$</li>
<li>output: JSON <code>[&quot;Given_Variant2&quot;,[&quot;Equals&quot;,[&quot;NumberVariable&quot;,&quot;k&quot;],[&quot;Number&quot;,&quot;1000&quot;]]]</code></li>
</ul>
</li>
<li>Test 7
<ul>
<li>input: LaTeX <code>\text{Given }k=1000</code>, typeset $\text{Given }k=1000$</li>
<li>output: JSON <code>[&quot;Given_Variant3&quot;,[&quot;Equals&quot;,[&quot;NumberVariable&quot;,&quot;k&quot;],[&quot;Number&quot;,&quot;1000&quot;]]]</code></li>
</ul>
</li>
<li>Test 8
<ul>
<li>input: LaTeX <code>\text{given }k=1000</code>, typeset $\text{given }k=1000$</li>
<li>output: JSON <code>[&quot;Given_Variant4&quot;,[&quot;Equals&quot;,[&quot;NumberVariable&quot;,&quot;k&quot;],[&quot;Number&quot;,&quot;1000&quot;]]]</code></li>
</ul>
</li>
<li>Test 9
<ul>
<li>input: LaTeX <code>\text{Assume }\top</code>, typeset $\text{Assume }\top$</li>
<li>output: JSON <code>[&quot;Given_Variant1&quot;,&quot;LogicalTrue&quot;]</code></li>
</ul>
</li>
<li>Test 10
<ul>
<li>input: LaTeX <code>\text{assume }\top</code>, typeset $\text{assume }\top$</li>
<li>output: JSON <code>[&quot;Given_Variant2&quot;,&quot;LogicalTrue&quot;]</code></li>
</ul>
</li>
<li>Test 11
<ul>
<li>input: LaTeX <code>\text{Given }\top</code>, typeset $\text{Given }\top$</li>
<li>output: JSON <code>[&quot;Given_Variant3&quot;,&quot;LogicalTrue&quot;]</code></li>
</ul>
</li>
<li>Test 12
<ul>
<li>input: LaTeX <code>\text{given }\top</code>, typeset $\text{given }\top$</li>
<li>output: JSON <code>[&quot;Given_Variant4&quot;,&quot;LogicalTrue&quot;]</code></li>
</ul>
</li>
<li>Test 13
<ul>
<li>input: LaTeX <code>\text{Assume }50</code>, typeset $\text{Assume }50$</li>
<li>output: JSON <code>null</code></li>
</ul>
</li>
<li>Test 14
<ul>
<li>input: LaTeX <code>\text{assume }(5,6)</code>, typeset $\text{assume }(5,6)$</li>
<li>output: JSON <code>null</code></li>
</ul>
</li>
<li>Test 15
<ul>
<li>input: LaTeX <code>\text{Given }f\circ g</code>, typeset $\text{Given }f\circ g$</li>
<li>output: JSON <code>null</code></li>
</ul>
</li>
<li>Test 16
<ul>
<li>input: LaTeX <code>\text{given }\emptyset</code>, typeset $\text{given }\emptyset$</li>
<li>output: JSON <code>null</code></li>
</ul>
</li>
<li>Test 17
<ul>
<li>input: LaTeX <code>\text{Assume }\infty</code>, typeset $\text{Assume }\infty$</li>
<li>output: JSON <code>null</code></li>
</ul>
</li>
</ul>
<h3>can parse notation for Let-style declarations</h3>
<ul>
<li>Test 1
<ul>
<li>input: LaTeX <code>\text{Let }x</code>, typeset $\text{Let }x$</li>
<li>output: JSON <code>[&quot;Let_Variant1&quot;,[&quot;NumberVariable&quot;,&quot;x&quot;]]</code></li>
</ul>
</li>
<li>Test 2
<ul>
<li>input: LaTeX <code>\text{let }x</code>, typeset $\text{let }x$</li>
<li>output: JSON <code>[&quot;Let_Variant2&quot;,[&quot;NumberVariable&quot;,&quot;x&quot;]]</code></li>
</ul>
</li>
<li>Test 3
<ul>
<li>input: LaTeX <code>\text{Let }T</code>, typeset $\text{Let }T$</li>
<li>output: JSON <code>[&quot;Let_Variant1&quot;,[&quot;NumberVariable&quot;,&quot;T&quot;]]</code></li>
</ul>
</li>
<li>Test 4
<ul>
<li>input: LaTeX <code>\text{let }T</code>, typeset $\text{let }T$</li>
<li>output: JSON <code>[&quot;Let_Variant2&quot;,[&quot;NumberVariable&quot;,&quot;T&quot;]]</code></li>
</ul>
</li>
<li>Test 5
<ul>
<li>input: LaTeX <code>\text{Let }x \text{ be such that }x&gt;0</code>, typeset $\text{Let }x \text{ be such that }x&gt;0$</li>
<li>output: JSON <code>[&quot;LetBeSuchThat_Variant1&quot;,[&quot;NumberVariable&quot;,&quot;x&quot;],[&quot;GreaterThan&quot;,[&quot;NumberVariable&quot;,&quot;x&quot;],[&quot;Number&quot;,&quot;0&quot;]]]</code></li>
</ul>
</li>
<li>Test 6
<ul>
<li>input: LaTeX <code>\text{let }x \text{ be such that }x&gt;0</code>, typeset $\text{let }x \text{ be such that }x&gt;0$</li>
<li>output: JSON <code>[&quot;LetBeSuchThat_Variant2&quot;,[&quot;NumberVariable&quot;,&quot;x&quot;],[&quot;GreaterThan&quot;,[&quot;NumberVariable&quot;,&quot;x&quot;],[&quot;Number&quot;,&quot;0&quot;]]]</code></li>
</ul>
</li>
<li>Test 7
<ul>
<li>input: LaTeX <code>\text{Let }T \text{ be such that }T=5\vee T\in S</code>, typeset $\text{Let }T \text{ be such that }T=5\vee T\in S$</li>
<li>output: JSON <code>[&quot;LetBeSuchThat_Variant1&quot;,[&quot;NumberVariable&quot;,&quot;T&quot;],[&quot;Disjunction&quot;,[&quot;Equals&quot;,[&quot;NumberVariable&quot;,&quot;T&quot;],[&quot;Number&quot;,&quot;5&quot;]],[&quot;NounIsElement&quot;,[&quot;NumberVariable&quot;,&quot;T&quot;],[&quot;SetVariable&quot;,&quot;S&quot;]]]]</code></li>
</ul>
</li>
<li>Test 8
<ul>
<li>input: LaTeX <code>\text{let }T \text{ be such that }T=5\vee T\in S</code>, typeset $\text{let }T \text{ be such that }T=5\vee T\in S$</li>
<li>output: JSON <code>[&quot;LetBeSuchThat_Variant2&quot;,[&quot;NumberVariable&quot;,&quot;T&quot;],[&quot;Disjunction&quot;,[&quot;Equals&quot;,[&quot;NumberVariable&quot;,&quot;T&quot;],[&quot;Number&quot;,&quot;5&quot;]],[&quot;NounIsElement&quot;,[&quot;NumberVariable&quot;,&quot;T&quot;],[&quot;SetVariable&quot;,&quot;S&quot;]]]]</code></li>
</ul>
</li>
<li>Test 9
<ul>
<li>input: LaTeX <code>\text{Let }x&gt;5</code>, typeset $\text{Let }x&gt;5$</li>
<li>output: JSON <code>null</code></li>
</ul>
</li>
<li>Test 10
<ul>
<li>input: LaTeX <code>\text{Let }1=1</code>, typeset $\text{Let }1=1$</li>
<li>output: JSON <code>null</code></li>
</ul>
</li>
<li>Test 11
<ul>
<li>input: LaTeX <code>\text{Let }\emptyset</code>, typeset $\text{Let }\emptyset$</li>
<li>output: JSON <code>null</code></li>
</ul>
</li>
<li>Test 12
<ul>
<li>input: LaTeX <code>\text{Let }x \text{ be such that }1</code>, typeset $\text{Let }x \text{ be such that }1$</li>
<li>output: JSON <code>null</code></li>
</ul>
</li>
<li>Test 13
<ul>
<li>input: LaTeX <code>\text{Let }x \text{ be such that }1\vee 2</code>, typeset $\text{Let }x \text{ be such that }1\vee 2$</li>
<li>output: JSON <code>null</code></li>
</ul>
</li>
<li>Test 14
<ul>
<li>input: LaTeX <code>\text{Let }x \text{ be such that }\text{Let }y</code>, typeset $\text{Let }x \text{ be such that }\text{Let }y$</li>
<li>output: JSON <code>null</code></li>
</ul>
</li>
<li>Test 15
<ul>
<li>input: LaTeX <code>\text{Let }x \text{ be such that }\text{Assume }B</code>, typeset $\text{Let }x \text{ be such that }\text{Assume }B$</li>
<li>output: JSON <code>null</code></li>
</ul>
</li>
</ul>
<h3>can parse notation for For Some-style declarations</h3>
<ul>
<li>Test 1
<ul>
<li>input: LaTeX <code>\text{For some }x, x&gt;0</code>, typeset $\text{For some }x, x&gt;0$</li>
<li>output: JSON <code>[&quot;ForSome_Variant1&quot;,[&quot;NumberVariable&quot;,&quot;x&quot;],[&quot;GreaterThan&quot;,[&quot;NumberVariable&quot;,&quot;x&quot;],[&quot;Number&quot;,&quot;0&quot;]]]</code></li>
</ul>
</li>
<li>Test 2
<ul>
<li>input: LaTeX <code>\text{for some }x, x&gt;0</code>, typeset $\text{for some }x, x&gt;0$</li>
<li>output: JSON <code>[&quot;ForSome_Variant2&quot;,[&quot;NumberVariable&quot;,&quot;x&quot;],[&quot;GreaterThan&quot;,[&quot;NumberVariable&quot;,&quot;x&quot;],[&quot;Number&quot;,&quot;0&quot;]]]</code></li>
</ul>
</li>
<li>Test 3
<ul>
<li>input: LaTeX <code>x&gt;0 \text{ for some } x</code>, typeset $x&gt;0 \text{ for some } x$</li>
<li>output: JSON <code>[&quot;ForSome_Variant3&quot;,[&quot;NumberVariable&quot;,&quot;x&quot;],[&quot;GreaterThan&quot;,[&quot;NumberVariable&quot;,&quot;x&quot;],[&quot;Number&quot;,&quot;0&quot;]]]</code></li>
</ul>
</li>
<li>Test 4
<ul>
<li>input: LaTeX <code>x&gt;0~\text{for some}~x</code>, typeset $x&gt;0~\text{for some}~x$</li>
<li>output: JSON <code>[&quot;ForSome_Variant4&quot;,[&quot;NumberVariable&quot;,&quot;x&quot;],[&quot;GreaterThan&quot;,[&quot;NumberVariable&quot;,&quot;x&quot;],[&quot;Number&quot;,&quot;0&quot;]]]</code></li>
</ul>
</li>
<li>Test 5
<ul>
<li>input: LaTeX <code>\text{For some }T, T=5\vee T\in S</code>, typeset $\text{For some }T, T=5\vee T\in S$</li>
<li>output: JSON <code>[&quot;ForSome_Variant1&quot;,[&quot;NumberVariable&quot;,&quot;T&quot;],[&quot;Disjunction&quot;,[&quot;Equals&quot;,[&quot;NumberVariable&quot;,&quot;T&quot;],[&quot;Number&quot;,&quot;5&quot;]],[&quot;NounIsElement&quot;,[&quot;NumberVariable&quot;,&quot;T&quot;],[&quot;SetVariable&quot;,&quot;S&quot;]]]]</code></li>
</ul>
</li>
<li>Test 6
<ul>
<li>input: LaTeX <code>\text{for some }T, T=5\vee T\in S</code>, typeset $\text{for some }T, T=5\vee T\in S$</li>
<li>output: JSON <code>[&quot;ForSome_Variant2&quot;,[&quot;NumberVariable&quot;,&quot;T&quot;],[&quot;Disjunction&quot;,[&quot;Equals&quot;,[&quot;NumberVariable&quot;,&quot;T&quot;],[&quot;Number&quot;,&quot;5&quot;]],[&quot;NounIsElement&quot;,[&quot;NumberVariable&quot;,&quot;T&quot;],[&quot;SetVariable&quot;,&quot;S&quot;]]]]</code></li>
</ul>
</li>
<li>Test 7
<ul>
<li>input: LaTeX <code>T=5\vee T\in S \text{ for some } T</code>, typeset $T=5\vee T\in S \text{ for some } T$</li>
<li>output: JSON <code>[&quot;ForSome_Variant3&quot;,[&quot;NumberVariable&quot;,&quot;T&quot;],[&quot;Disjunction&quot;,[&quot;Equals&quot;,[&quot;NumberVariable&quot;,&quot;T&quot;],[&quot;Number&quot;,&quot;5&quot;]],[&quot;NounIsElement&quot;,[&quot;NumberVariable&quot;,&quot;T&quot;],[&quot;SetVariable&quot;,&quot;S&quot;]]]]</code></li>
</ul>
</li>
<li>Test 8
<ul>
<li>input: LaTeX <code>T=5\vee T\in S~\text{for some}~T</code>, typeset $T=5\vee T\in S~\text{for some}~T$</li>
<li>output: JSON <code>[&quot;ForSome_Variant4&quot;,[&quot;NumberVariable&quot;,&quot;T&quot;],[&quot;Disjunction&quot;,[&quot;Equals&quot;,[&quot;NumberVariable&quot;,&quot;T&quot;],[&quot;Number&quot;,&quot;5&quot;]],[&quot;NounIsElement&quot;,[&quot;NumberVariable&quot;,&quot;T&quot;],[&quot;SetVariable&quot;,&quot;S&quot;]]]]</code></li>
</ul>
</li>
<li>Test 9
<ul>
<li>input: LaTeX <code>\text{For some }x</code>, typeset $\text{For some }x$</li>
<li>output: JSON <code>null</code></li>
</ul>
</li>
<li>Test 10
<ul>
<li>input: LaTeX <code>\text{for some }x</code>, typeset $\text{for some }x$</li>
<li>output: JSON <code>null</code></li>
</ul>
</li>
<li>Test 11
<ul>
<li>input: LaTeX <code>\text{For some }T</code>, typeset $\text{For some }T$</li>
<li>output: JSON <code>null</code></li>
</ul>
</li>
<li>Test 12
<ul>
<li>input: LaTeX <code>\text{for some }T</code>, typeset $\text{for some }T$</li>
<li>output: JSON <code>null</code></li>
</ul>
</li>
<li>Test 13
<ul>
<li>input: LaTeX <code>\text{For some }x&gt;5, x&gt;55</code>, typeset $\text{For some }x&gt;5, x&gt;55$</li>
<li>output: JSON <code>null</code></li>
</ul>
</li>
<li>Test 14
<ul>
<li>input: LaTeX <code>\text{For some }1=1, P</code>, typeset $\text{For some }1=1, P$</li>
<li>output: JSON <code>null</code></li>
</ul>
</li>
<li>Test 15
<ul>
<li>input: LaTeX <code>\text{For some }\emptyset, 1+1=2</code>, typeset $\text{For some }\emptyset, 1+1=2$</li>
<li>output: JSON <code>null</code></li>
</ul>
</li>
<li>Test 16
<ul>
<li>input: LaTeX <code>x&gt;55 \text{ for some } x&gt;5</code>, typeset $x&gt;55 \text{ for some } x&gt;5$</li>
<li>output: JSON <code>null</code></li>
</ul>
</li>
<li>Test 17
<ul>
<li>input: LaTeX <code>P \text{ for some } 1=1</code>, typeset $P \text{ for some } 1=1$</li>
<li>output: JSON <code>null</code></li>
</ul>
</li>
<li>Test 18
<ul>
<li>input: LaTeX <code>\emptyset \text{ for some } 1+1=2</code>, typeset $\emptyset \text{ for some } 1+1=2$</li>
<li>output: JSON <code>null</code></li>
</ul>
</li>
<li>Test 19
<ul>
<li>input: LaTeX <code>\text{For some }x, 1</code>, typeset $\text{For some }x, 1$</li>
<li>output: JSON <code>null</code></li>
</ul>
</li>
<li>Test 20
<ul>
<li>input: LaTeX <code>\text{For some }x, 1\vee 2</code>, typeset $\text{For some }x, 1\vee 2$</li>
<li>output: JSON <code>null</code></li>
</ul>
</li>
<li>Test 21
<ul>
<li>input: LaTeX <code>\text{For some }x, \text{Let }y</code>, typeset $\text{For some }x, \text{Let }y$</li>
<li>output: JSON <code>null</code></li>
</ul>
</li>
<li>Test 22
<ul>
<li>input: LaTeX <code>\text{For some }x, \text{Assume }B</code>, typeset $\text{For some }x, \text{Assume }B$</li>
<li>output: JSON <code>null</code></li>
</ul>
</li>
<li>Test 23
<ul>
<li>input: LaTeX <code>1~\text{for some}~x</code>, typeset $1~\text{for some}~x$</li>
<li>output: JSON <code>null</code></li>
</ul>
</li>
<li>Test 24
<ul>
<li>input: LaTeX <code>1\vee 2~\text{for some}~x</code>, typeset $1\vee 2~\text{for some}~x$</li>
<li>output: JSON <code>null</code></li>
</ul>
</li>
<li>Test 25
<ul>
<li>input: LaTeX <code>\text{Let }y~\text{for some}~x</code>, typeset $\text{Let }y~\text{for some}~x$</li>
<li>output: JSON <code>null</code></li>
</ul>
</li>
<li>Test 26
<ul>
<li>input: LaTeX <code>\text{Assume }B~\text{for some}~x</code>, typeset $\text{Assume }B~\text{for some}~x$</li>
<li>output: JSON <code>null</code></li>
</ul>
</li>
</ul>
<h2><a name="Rendering-JSON-into-LaTeX">Rendering JSON into LaTeX</a></h2>
<h3>can convert JSON numbers to LaTeX</h3>
<ul>
<li>Test 1
<ul>
<li>input: JSON <code>[&quot;Number&quot;,&quot;0&quot;]</code></li>
<li>output: LaTeX <code>0</code>, typeset $0$</li>
</ul>
</li>
<li>Test 2
<ul>
<li>input: JSON <code>[&quot;Number&quot;,&quot;453789&quot;]</code></li>
<li>output: LaTeX <code>453789</code>, typeset $453789$</li>
</ul>
</li>
<li>Test 3
<ul>
<li>input: JSON <code>[&quot;Number&quot;,&quot;99999999999999999999999999999999999999999&quot;]</code></li>
<li>output: LaTeX <code>99999999999999999999999999999999999999999</code>, typeset $99999999999999999999999999999999999999999$</li>
</ul>
</li>
<li>Test 4
<ul>
<li>input: JSON <code>[&quot;NumberNegation&quot;,[&quot;Number&quot;,&quot;453789&quot;]]</code></li>
<li>output: LaTeX <code>-453789</code>, typeset $-453789$</li>
</ul>
</li>
<li>Test 5
<ul>
<li>input: JSON <code>[&quot;NumberNegation&quot;,[&quot;Number&quot;,&quot;99999999999999999999999999999999999999999&quot;]]</code></li>
<li>output: LaTeX <code>-99999999999999999999999999999999999999999</code>, typeset $-99999999999999999999999999999999999999999$</li>
</ul>
</li>
<li>Test 6
<ul>
<li>input: JSON <code>[&quot;Number&quot;,&quot;0.0&quot;]</code></li>
<li>output: LaTeX <code>0.0</code>, typeset $0.0$</li>
</ul>
</li>
<li>Test 7
<ul>
<li>input: JSON <code>[&quot;Number&quot;,&quot;29835.6875940&quot;]</code></li>
<li>output: LaTeX <code>29835.6875940</code>, typeset $29835.6875940$</li>
</ul>
</li>
<li>Test 8
<ul>
<li>input: JSON <code>[&quot;Number&quot;,&quot;653280458689.&quot;]</code></li>
<li>output: LaTeX <code>653280458689.</code>, typeset $653280458689.$</li>
</ul>
</li>
<li>Test 9
<ul>
<li>input: JSON <code>[&quot;Number&quot;,&quot;.000006327589&quot;]</code></li>
<li>output: LaTeX <code>.000006327589</code>, typeset $.000006327589$</li>
</ul>
</li>
<li>Test 10
<ul>
<li>input: JSON <code>[&quot;NumberNegation&quot;,[&quot;Number&quot;,&quot;29835.6875940&quot;]]</code></li>
<li>output: LaTeX <code>-29835.6875940</code>, typeset $-29835.6875940$</li>
</ul>
</li>
<li>Test 11
<ul>
<li>input: JSON <code>[&quot;NumberNegation&quot;,[&quot;Number&quot;,&quot;653280458689.&quot;]]</code></li>
<li>output: LaTeX <code>-653280458689.</code>, typeset $-653280458689.$</li>
</ul>
</li>
<li>Test 12
<ul>
<li>input: JSON <code>[&quot;NumberNegation&quot;,[&quot;Number&quot;,&quot;.000006327589&quot;]]</code></li>
<li>output: LaTeX <code>-.000006327589</code>, typeset $-.000006327589$</li>
</ul>
</li>
</ul>
<h3>can convert any size variable name from JSON to LaTeX</h3>
<ul>
<li>Test 1
<ul>
<li>input: JSON <code>[&quot;NumberVariable&quot;,&quot;x&quot;]</code></li>
<li>output: LaTeX <code>x</code>, typeset $x$</li>
</ul>
</li>
<li>Test 2
<ul>
<li>input: JSON <code>[&quot;NumberVariable&quot;,&quot;E&quot;]</code></li>
<li>output: LaTeX <code>E</code>, typeset $E$</li>
</ul>
</li>
<li>Test 3
<ul>
<li>input: JSON <code>[&quot;NumberVariable&quot;,&quot;q&quot;]</code></li>
<li>output: LaTeX <code>q</code>, typeset $q$</li>
</ul>
</li>
<li>Test 4
<ul>
<li>input: JSON <code>[&quot;NumberVariable&quot;,&quot;foo&quot;]</code></li>
<li>output: LaTeX <code>foo</code>, typeset $foo$</li>
</ul>
</li>
<li>Test 5
<ul>
<li>input: JSON <code>[&quot;NumberVariable&quot;,&quot;bar&quot;]</code></li>
<li>output: LaTeX <code>bar</code>, typeset $bar$</li>
</ul>
</li>
<li>Test 6
<ul>
<li>input: JSON <code>[&quot;NumberVariable&quot;,&quot;to&quot;]</code></li>
<li>output: LaTeX <code>to</code>, typeset $to$</li>
</ul>
</li>
</ul>
<h3>can convert numeric constants from JSON to LaTeX</h3>
<ul>
<li>Test 1
<ul>
<li>input: JSON <code>&quot;Infinity&quot;</code></li>
<li>output: LaTeX <code>\infty</code>, typeset $\infty$</li>
</ul>
</li>
<li>Test 2
<ul>
<li>input: JSON <code>&quot;Pi&quot;</code></li>
<li>output: LaTeX <code>\pi</code>, typeset $\pi$</li>
</ul>
</li>
<li>Test 3
<ul>
<li>input: JSON <code>&quot;EulersNumber&quot;</code></li>
<li>output: LaTeX <code>e</code>, typeset $e$</li>
</ul>
</li>
</ul>
<h3>can convert exponentiation of atomics from JSON to LaTeX</h3>
<ul>
<li>Test 1
<ul>
<li>input: JSON <code>[&quot;Exponentiation&quot;,[&quot;Number&quot;,&quot;1&quot;],[&quot;Number&quot;,&quot;2&quot;]]</code></li>
<li>output: LaTeX <code>1^2</code>, typeset $1^2$</li>
</ul>
</li>
<li>Test 2
<ul>
<li>input: JSON <code>[&quot;Exponentiation&quot;,[&quot;NumberVariable&quot;,&quot;e&quot;],[&quot;NumberVariable&quot;,&quot;x&quot;]]</code></li>
<li>output: LaTeX <code>e^x</code>, typeset $e^x$</li>
</ul>
</li>
<li>Test 3
<ul>
<li>input: JSON <code>[&quot;Exponentiation&quot;,[&quot;Number&quot;,&quot;1&quot;],&quot;Infinity&quot;]</code></li>
<li>output: LaTeX <code>1^\infty</code>, typeset $1^\infty$</li>
</ul>
</li>
</ul>
<h3>can convert atomic percentages and factorials from JSON to LaTeX</h3>
<ul>
<li>Test 1
<ul>
<li>input: JSON <code>[&quot;Percentage&quot;,[&quot;Number&quot;,&quot;10&quot;]]</code></li>
<li>output: LaTeX <code>10\%</code>, typeset $10\%$</li>
</ul>
</li>
<li>Test 2
<ul>
<li>input: JSON <code>[&quot;Percentage&quot;,[&quot;NumberVariable&quot;,&quot;t&quot;]]</code></li>
<li>output: LaTeX <code>t\%</code>, typeset $t\%$</li>
</ul>
</li>
<li>Test 3
<ul>
<li>input: JSON <code>[&quot;Factorial&quot;,[&quot;Number&quot;,&quot;10&quot;]]</code></li>
<li>output: LaTeX <code>10!</code>, typeset $10!$</li>
</ul>
</li>
<li>Test 4
<ul>
<li>input: JSON <code>[&quot;Factorial&quot;,[&quot;NumberVariable&quot;,&quot;t&quot;]]</code></li>
<li>output: LaTeX <code>t!</code>, typeset $t!$</li>
</ul>
</li>
</ul>
<h3>can convert division of atomics or factors from JSON to LaTeX</h3>
<ul>
<li>Test 1
<ul>
<li>input: JSON <code>[&quot;Division&quot;,[&quot;Number&quot;,&quot;1&quot;],[&quot;Number&quot;,&quot;2&quot;]]</code></li>
<li>output: LaTeX <code>1\div 2</code>, typeset $1\div 2$</li>
</ul>
</li>
<li>Test 2
<ul>
<li>input: JSON <code>[&quot;Division&quot;,[&quot;NumberVariable&quot;,&quot;x&quot;],[&quot;NumberVariable&quot;,&quot;y&quot;]]</code></li>
<li>output: LaTeX <code>x\div y</code>, typeset $x\div y$</li>
</ul>
</li>
<li>Test 3
<ul>
<li>input: JSON <code>[&quot;Division&quot;,[&quot;Number&quot;,&quot;0&quot;],&quot;Infinity&quot;]</code></li>
<li>output: LaTeX <code>0\div \infty</code>, typeset $0\div \infty$</li>
</ul>
</li>
<li>Test 4
<ul>
<li>input: JSON <code>[&quot;Division&quot;,[&quot;Exponentiation&quot;,[&quot;NumberVariable&quot;,&quot;x&quot;],[&quot;Number&quot;,&quot;2&quot;]],[&quot;Number&quot;,&quot;3&quot;]]</code></li>
<li>output: LaTeX <code>x^2\div 3</code>, typeset $x^2\div 3$</li>
</ul>
</li>
<li>Test 5
<ul>
<li>input: JSON <code>[&quot;Division&quot;,[&quot;Number&quot;,&quot;1&quot;],[&quot;Exponentiation&quot;,[&quot;NumberVariable&quot;,&quot;e&quot;],[&quot;NumberVariable&quot;,&quot;x&quot;]]]</code></li>
<li>output: LaTeX <code>1\div e^x</code>, typeset $1\div e^x$</li>
</ul>
</li>
<li>Test 6
<ul>
<li>input: JSON <code>[&quot;Division&quot;,[&quot;Percentage&quot;,[&quot;Number&quot;,&quot;10&quot;]],[&quot;Exponentiation&quot;,[&quot;Number&quot;,&quot;2&quot;],[&quot;Number&quot;,&quot;100&quot;]]]</code></li>
<li>output: LaTeX <code>10\%\div 2^100</code>, typeset $10\%\div 2^100$</li>
</ul>
</li>
</ul>
<h3>can convert multiplication of atomics or factors from JSON to LaTeX</h3>
<ul>
<li>Test 1
<ul>
<li>input: JSON <code>[&quot;Multiplication&quot;,[&quot;Number&quot;,&quot;1&quot;],[&quot;Number&quot;,&quot;2&quot;]]</code></li>
<li>output: LaTeX <code>1\times 2</code>, typeset $1\times 2$</li>
</ul>
</li>
<li>Test 2
<ul>
<li>input: JSON <code>[&quot;Multiplication&quot;,[&quot;NumberVariable&quot;,&quot;x&quot;],[&quot;NumberVariable&quot;,&quot;y&quot;]]</code></li>
<li>output: LaTeX <code>x\times y</code>, typeset $x\times y$</li>
</ul>
</li>
<li>Test 3
<ul>
<li>input: JSON <code>[&quot;Multiplication&quot;,[&quot;Number&quot;,&quot;0&quot;],&quot;Infinity&quot;]</code></li>
<li>output: LaTeX <code>0\times \infty</code>, typeset $0\times \infty$</li>
</ul>
</li>
<li>Test 4
<ul>
<li>input: JSON <code>[&quot;Multiplication&quot;,[&quot;Exponentiation&quot;,[&quot;NumberVariable&quot;,&quot;x&quot;],[&quot;Number&quot;,&quot;2&quot;]],[&quot;Number&quot;,&quot;3&quot;]]</code></li>
<li>output: LaTeX <code>x^2\times 3</code>, typeset $x^2\times 3$</li>
</ul>
</li>
<li>Test 5
<ul>
<li>input: JSON <code>[&quot;Multiplication&quot;,[&quot;Number&quot;,&quot;1&quot;],[&quot;Exponentiation&quot;,[&quot;NumberVariable&quot;,&quot;e&quot;],[&quot;NumberVariable&quot;,&quot;x&quot;]]]</code></li>
<li>output: LaTeX <code>1\times e^x</code>, typeset $1\times e^x$</li>
</ul>
</li>
<li>Test 6
<ul>
<li>input: JSON <code>[&quot;Multiplication&quot;,[&quot;Percentage&quot;,[&quot;Number&quot;,&quot;10&quot;]],[&quot;Exponentiation&quot;,[&quot;Number&quot;,&quot;2&quot;],[&quot;Number&quot;,&quot;100&quot;]]]</code></li>
<li>output: LaTeX <code>10\%\times 2^100</code>, typeset $10\%\times 2^100$</li>
</ul>
</li>
</ul>
<h3>can convert negations of atomics or factors from JSON to LaTeX</h3>
<ul>
<li>Test 1
<ul>
<li>input: JSON <code>[&quot;Multiplication&quot;,[&quot;NumberNegation&quot;,[&quot;Number&quot;,&quot;1&quot;]],[&quot;Number&quot;,&quot;2&quot;]]</code></li>
<li>output: LaTeX <code>-1\times 2</code>, typeset $-1\times 2$</li>
</ul>
</li>
<li>Test 2
<ul>
<li>input: JSON <code>[&quot;Multiplication&quot;,[&quot;NumberVariable&quot;,&quot;x&quot;],[&quot;NumberNegation&quot;,[&quot;NumberVariable&quot;,&quot;y&quot;]]]</code></li>
<li>output: LaTeX <code>x\times -y</code>, typeset $x\times -y$</li>
</ul>
</li>
<li>Test 3
<ul>
<li>input: JSON <code>[&quot;Multiplication&quot;,[&quot;NumberNegation&quot;,[&quot;Exponentiation&quot;,[&quot;NumberVariable&quot;,&quot;x&quot;],[&quot;Number&quot;,&quot;2&quot;]]],[&quot;NumberNegation&quot;,[&quot;Number&quot;,&quot;3&quot;]]]</code></li>
<li>output: LaTeX <code>-x^2\times -3</code>, typeset $-x^2\times -3$</li>
</ul>
</li>
<li>Test 4
<ul>
<li>input: JSON <code>[&quot;NumberNegation&quot;,[&quot;NumberNegation&quot;,[&quot;NumberNegation&quot;,[&quot;NumberNegation&quot;,[&quot;Number&quot;,&quot;1000&quot;]]]]]</code></li>
<li>output: LaTeX <code>----1000</code>, typeset $----1000$</li>
</ul>
</li>
</ul>
<h3>can convert additions and subtractions from JSON to LaTeX</h3>
<ul>
<li>Test 1
<ul>
<li>input: JSON <code>[&quot;Addition&quot;,[&quot;NumberVariable&quot;,&quot;x&quot;],[&quot;NumberVariable&quot;,&quot;y&quot;]]</code></li>
<li>output: LaTeX <code>x+y</code>, typeset $x+y$</li>
</ul>
</li>
<li>Test 2
<ul>
<li>input: JSON <code>[&quot;Subtraction&quot;,[&quot;Number&quot;,&quot;1&quot;],[&quot;NumberNegation&quot;,[&quot;Number&quot;,&quot;3&quot;]]]</code></li>
<li>output: LaTeX <code>1--3</code>, typeset $1--3$</li>
</ul>
</li>
<li>Test 3
<ul>
<li>input: JSON <code>[&quot;Subtraction&quot;,[&quot;Addition&quot;,[&quot;Exponentiation&quot;,[&quot;NumberVariable&quot;,&quot;A&quot;],[&quot;NumberVariable&quot;,&quot;B&quot;]],[&quot;NumberVariable&quot;,&quot;C&quot;]],&quot;Pi&quot;]</code></li>
<li>output: LaTeX <code>A^B+C-\pi</code>, typeset $A^B+C-\pi$</li>
</ul>
</li>
</ul>
<h3>can convert Number expressions with groupers from JSON to LaTeX</h3>
<ul>
<li>Test 1
<ul>
<li>input: JSON <code>[&quot;NumberNegation&quot;,[&quot;Multiplication&quot;,[&quot;Number&quot;,&quot;1&quot;],[&quot;Number&quot;,&quot;2&quot;]]]</code></li>
<li>output: LaTeX <code>-1\times 2</code>, typeset $-1\times 2$</li>
</ul>
</li>
<li>Test 2
<ul>
<li>input: JSON <code>[&quot;Factorial&quot;,[&quot;Addition&quot;,[&quot;Number&quot;,&quot;1&quot;],[&quot;Number&quot;,&quot;2&quot;]]]</code></li>
<li>output: LaTeX <code>{1+2}!</code>, typeset ${1+2}!$</li>
</ul>
</li>
<li>Test 3
<ul>
<li>input: JSON <code>[&quot;Exponentiation&quot;,[&quot;NumberNegation&quot;,[&quot;NumberVariable&quot;,&quot;x&quot;]],[&quot;Multiplication&quot;,[&quot;Number&quot;,&quot;2&quot;],[&quot;NumberNegation&quot;,[&quot;Number&quot;,&quot;3&quot;]]]]</code></li>
<li>output: LaTeX <code>{-x}^{2\times -3}</code>, typeset ${-x}^{2\times -3}$</li>
</ul>
</li>
<li>Test 4
<ul>
<li>input: JSON <code>[&quot;Addition&quot;,[&quot;Exponentiation&quot;,[&quot;NumberVariable&quot;,&quot;A&quot;],[&quot;NumberVariable&quot;,&quot;B&quot;]],[&quot;Subtraction&quot;,[&quot;NumberVariable&quot;,&quot;C&quot;],[&quot;NumberVariable&quot;,&quot;D&quot;]]]</code></li>
<li>output: LaTeX <code>A^B+C-D</code>, typeset $A^B+C-D$</li>
</ul>
</li>
<li>Test 5
<ul>
<li>input: JSON <code>[&quot;Multiplication&quot;,[&quot;Exponentiation&quot;,[&quot;NumberVariable&quot;,&quot;k&quot;],[&quot;Subtraction&quot;,[&quot;Number&quot;,&quot;1&quot;],[&quot;NumberVariable&quot;,&quot;y&quot;]]],[&quot;Addition&quot;,[&quot;Number&quot;,&quot;2&quot;],[&quot;NumberVariable&quot;,&quot;k&quot;]]]</code></li>
<li>output: LaTeX <code>k^{1-y}\times {2+k}</code>, typeset $k^{1-y}\times {2+k}$</li>
</ul>
</li>
</ul>
<h3>can parse relations of numeric expressions from JSON to LaTeX</h3>
<ul>
<li>Test 1
<ul>
<li>input: JSON <code>[&quot;GreaterThan&quot;,[&quot;Number&quot;,&quot;1&quot;],[&quot;Number&quot;,&quot;2&quot;]]</code></li>
<li>output: LaTeX <code>1&gt;2</code>, typeset $1&gt;2$</li>
</ul>
</li>
<li>Test 2
<ul>
<li>input: JSON <code>[&quot;LessThan&quot;,[&quot;Subtraction&quot;,[&quot;Number&quot;,&quot;1&quot;],[&quot;Number&quot;,&quot;2&quot;]],[&quot;Addition&quot;,[&quot;Number&quot;,&quot;1&quot;],[&quot;Number&quot;,&quot;2&quot;]]]</code></li>
<li>output: LaTeX <code>1-2&lt;1+2</code>, typeset $1-2&lt;1+2$</li>
</ul>
</li>
<li>Test 3
<ul>
<li>input: JSON <code>[&quot;Conjunction&quot;,[&quot;GreaterThanOrEqual&quot;,[&quot;Number&quot;,&quot;2&quot;],[&quot;Number&quot;,&quot;1&quot;]],[&quot;LessThanOrEqual&quot;,[&quot;Number&quot;,&quot;2&quot;],[&quot;Number&quot;,&quot;3&quot;]]]</code></li>
<li>output: LaTeX <code>2\ge 1\wedge 2\le 3</code>, typeset $2\ge 1\wedge 2\le 3$</li>
</ul>
</li>
<li>Test 4
<ul>
<li>input: JSON <code>[&quot;BinaryRelationHolds&quot;,&quot;Divides&quot;,[&quot;Number&quot;,&quot;7&quot;],[&quot;Number&quot;,&quot;14&quot;]]</code></li>
<li>output: LaTeX <code>7 | 14</code>, typeset $7 | 14$</li>
</ul>
</li>
<li>Test 5
<ul>
<li>input: JSON <code>[&quot;BinaryRelationHolds&quot;,&quot;Divides&quot;,[&quot;NumberFunctionApplication&quot;,[&quot;FunctionVariable&quot;,&quot;A&quot;],[&quot;NumberVariable&quot;,&quot;k&quot;]],[&quot;Factorial&quot;,[&quot;NumberVariable&quot;,&quot;n&quot;]]]</code></li>
<li>output: LaTeX <code>A(k) | n!</code>, typeset $A(k) | n!$</li>
</ul>
</li>
<li>Test 6
<ul>
<li>input: JSON <code>[&quot;BinaryRelationHolds&quot;,&quot;GenericBinaryRelation&quot;,[&quot;Subtraction&quot;,[&quot;Number&quot;,&quot;1&quot;],[&quot;NumberVariable&quot;,&quot;k&quot;]],[&quot;Addition&quot;,[&quot;Number&quot;,&quot;1&quot;],[&quot;NumberVariable&quot;,&quot;k&quot;]]]</code></li>
<li>output: LaTeX <code>1-k \sim 1+k</code>, typeset $1-k \sim 1+k$</li>
</ul>
</li>
<li>Test 7
<ul>
<li>input: JSON <code>[&quot;BinaryRelationHolds&quot;,&quot;ApproximatelyEqual&quot;,[&quot;Number&quot;,&quot;0.99&quot;],[&quot;Number&quot;,&quot;1.01&quot;]]</code></li>
<li>output: LaTeX <code>0.99 \approx 1.01</code>, typeset $0.99 \approx 1.01$</li>
</ul>
</li>
</ul>
<h3>can represent inequality if JSON explicitly requests it</h3>
<ul>
<li>Test 1
<ul>
<li>input: JSON <code>[&quot;NotEqual&quot;,[&quot;Number&quot;,&quot;1&quot;],[&quot;Number&quot;,&quot;2&quot;]]</code></li>
<li>output: LaTeX <code>1\ne 2</code>, typeset $1\ne 2$</li>
</ul>
</li>
<li>Test 2
<ul>
<li>input: JSON <code>[&quot;LogicalNegation&quot;,[&quot;Equals&quot;,[&quot;Number&quot;,&quot;1&quot;],[&quot;Number&quot;,&quot;2&quot;]]]</code></li>
<li>output: LaTeX <code>\neg 1=2</code>, typeset $\neg 1=2$</li>
</ul>
</li>
</ul>
<h3>can convert propositional logic atomics from JSON to LaTeX</h3>
<ul>
<li>Test 1
<ul>
<li>input: JSON <code>&quot;LogicalTrue&quot;</code></li>
<li>output: LaTeX <code>\top</code>, typeset $\top$</li>
</ul>
</li>
<li>Test 2
<ul>
<li>input: JSON <code>&quot;LogicalFalse&quot;</code></li>
<li>output: LaTeX <code>\bot</code>, typeset $\bot$</li>
</ul>
</li>
<li>Test 3
<ul>
<li>input: JSON <code>&quot;Contradiction&quot;</code></li>
<li>output: LaTeX <code>\rightarrow \leftarrow</code>, typeset $\rightarrow \leftarrow$</li>
</ul>
</li>
</ul>
<h3>can convert propositional logic conjuncts from JSON to LaTeX</h3>
<ul>
<li>Test 1
<ul>
<li>input: JSON <code>[&quot;Conjunction&quot;,&quot;LogicalTrue&quot;,&quot;LogicalFalse&quot;]</code></li>
<li>output: LaTeX <code>\top\wedge \bot</code>, typeset $\top\wedge \bot$</li>
</ul>
</li>
<li>Test 2
<ul>
<li>input: JSON <code>[&quot;Conjunction&quot;,[&quot;LogicalNegation&quot;,[&quot;LogicVariable&quot;,&quot;P&quot;]],[&quot;LogicalNegation&quot;,&quot;LogicalTrue&quot;]]</code></li>
<li>output: LaTeX <code>\neg P\wedge \neg \top</code>, typeset $\neg P\wedge \neg \top$</li>
</ul>
</li>
<li>Test 3
<ul>
<li>input: JSON <code>[&quot;Conjunction&quot;,[&quot;Conjunction&quot;,[&quot;LogicVariable&quot;,&quot;a&quot;],[&quot;LogicVariable&quot;,&quot;b&quot;]],[&quot;LogicVariable&quot;,&quot;c&quot;]]</code></li>
<li>output: LaTeX <code>a\wedge b\wedge c</code>, typeset $a\wedge b\wedge c$</li>
</ul>
</li>
</ul>
<h3>can convert propositional logic disjuncts from JSON to LaTeX</h3>
<ul>
<li>Test 1
<ul>
<li>input: JSON <code>[&quot;Disjunction&quot;,&quot;LogicalTrue&quot;,[&quot;LogicalNegation&quot;,[&quot;LogicVariable&quot;,&quot;A&quot;]]]</code></li>
<li>output: LaTeX <code>\top\vee \neg A</code>, typeset $\top\vee \neg A$</li>
</ul>
</li>
<li>Test 2
<ul>
<li>input: JSON <code>[&quot;Disjunction&quot;,[&quot;Conjunction&quot;,[&quot;LogicVariable&quot;,&quot;P&quot;],[&quot;LogicVariable&quot;,&quot;Q&quot;]],[&quot;Conjunction&quot;,[&quot;LogicVariable&quot;,&quot;Q&quot;],[&quot;LogicVariable&quot;,&quot;P&quot;]]]</code></li>
<li>output: LaTeX <code>P\wedge Q\vee Q\wedge P</code>, typeset $P\wedge Q\vee Q\wedge P$</li>
</ul>
</li>
</ul>
<h3>can convert propositional logic conditionals from JSON to LaTeX</h3>
<ul>
<li>Test 1
<ul>
<li>input: JSON <code>[&quot;Implication&quot;,[&quot;LogicVariable&quot;,&quot;A&quot;],[&quot;Conjunction&quot;,[&quot;LogicVariable&quot;,&quot;Q&quot;],[&quot;LogicalNegation&quot;,[&quot;LogicVariable&quot;,&quot;P&quot;]]]]</code></li>
<li>output: LaTeX <code>A\Rightarrow Q\wedge \neg P</code>, typeset $A\Rightarrow Q\wedge \neg P$</li>
</ul>
</li>
<li>Test 2
<ul>
<li>input: JSON <code>[&quot;Implication&quot;,[&quot;Implication&quot;,[&quot;Disjunction&quot;,[&quot;LogicVariable&quot;,&quot;P&quot;],[&quot;LogicVariable&quot;,&quot;Q&quot;]],[&quot;Conjunction&quot;,[&quot;LogicVariable&quot;,&quot;Q&quot;],[&quot;LogicVariable&quot;,&quot;P&quot;]]],[&quot;LogicVariable&quot;,&quot;T&quot;]]</code></li>
<li>output: LaTeX <code>P\vee Q\Rightarrow Q\wedge P\Rightarrow T</code>, typeset $P\vee Q\Rightarrow Q\wedge P\Rightarrow T$</li>
</ul>
</li>
</ul>
<h3>can convert propositional logic biconditionals from JSON to LaTeX</h3>
<ul>
<li>Test 1
<ul>
<li>input: JSON <code>[&quot;LogicalEquivalence&quot;,[&quot;LogicVariable&quot;,&quot;A&quot;],[&quot;Conjunction&quot;,[&quot;LogicVariable&quot;,&quot;Q&quot;],[&quot;LogicalNegation&quot;,[&quot;LogicVariable&quot;,&quot;P&quot;]]]]</code></li>
<li>output: LaTeX <code>A\Leftrightarrow Q\wedge \neg P</code>, typeset $A\Leftrightarrow Q\wedge \neg P$</li>
</ul>
</li>
<li>Test 2
<ul>
<li>input: JSON <code>[&quot;Implication&quot;,[&quot;LogicalEquivalence&quot;,[&quot;Disjunction&quot;,[&quot;LogicVariable&quot;,&quot;P&quot;],[&quot;LogicVariable&quot;,&quot;Q&quot;]],[&quot;Conjunction&quot;,[&quot;LogicVariable&quot;,&quot;Q&quot;],[&quot;LogicVariable&quot;,&quot;P&quot;]]],[&quot;LogicVariable&quot;,&quot;T&quot;]]</code></li>
<li>output: LaTeX <code>P\vee Q\Leftrightarrow Q\wedge P\Rightarrow T</code>, typeset $P\vee Q\Leftrightarrow Q\wedge P\Rightarrow T$</li>
</ul>
</li>
</ul>
<h3>can convert propositional expressions with groupers from JSON to LaTeX</h3>
<ul>
<li>Test 1
<ul>
<li>input: JSON <code>[&quot;Disjunction&quot;,[&quot;LogicVariable&quot;,&quot;P&quot;],[&quot;Conjunction&quot;,[&quot;LogicalEquivalence&quot;,[&quot;LogicVariable&quot;,&quot;Q&quot;],[&quot;LogicVariable&quot;,&quot;Q&quot;]],[&quot;LogicVariable&quot;,&quot;P&quot;]]]</code></li>
<li>output: LaTeX <code>P\vee {Q\Leftrightarrow Q}\wedge P</code>, typeset $P\vee {Q\Leftrightarrow Q}\wedge P$</li>
</ul>
</li>
<li>Test 2
<ul>
<li>input: JSON <code>[&quot;LogicalNegation&quot;,[&quot;LogicalEquivalence&quot;,&quot;LogicalTrue&quot;,&quot;LogicalFalse&quot;]]</code></li>
<li>output: LaTeX <code>\neg {\top\Leftrightarrow \bot}</code>, typeset $\neg {\top\Leftrightarrow \bot}$</li>
</ul>
</li>
</ul>
<h3>can convert simple predicate logic expressions from JSON to LaTeX</h3>
<ul>
<li>Test 1
<ul>
<li>input: JSON <code>[&quot;UniversalQuantifier&quot;,[&quot;NumberVariable&quot;,&quot;x&quot;],[&quot;LogicVariable&quot;,&quot;P&quot;]]</code></li>
<li>output: LaTeX <code>\forall x, P</code>, typeset $\forall x, P$</li>
</ul>
</li>
<li>Test 2
<ul>
<li>input: JSON <code>[&quot;ExistentialQuantifier&quot;,[&quot;NumberVariable&quot;,&quot;t&quot;],[&quot;LogicalNegation&quot;,[&quot;LogicVariable&quot;,&quot;Q&quot;]]]</code></li>
<li>output: LaTeX <code>\exists t, \neg Q</code>, typeset $\exists t, \neg Q$</li>
</ul>
</li>
<li>Test 3
<ul>
<li>input: JSON <code>[&quot;UniqueExistentialQuantifier&quot;,[&quot;NumberVariable&quot;,&quot;k&quot;],[&quot;Implication&quot;,[&quot;LogicVariable&quot;,&quot;m&quot;],[&quot;LogicVariable&quot;,&quot;n&quot;]]]</code></li>
<li>output: LaTeX <code>\exists ! k, m\Rightarrow n</code>, typeset $\exists ! k, m\Rightarrow n$</li>
</ul>
</li>
</ul>
<h3>can convert finite and empty sets from JSON to LaTeX</h3>
<ul>
<li>Test 1
<ul>
<li>input: JSON <code>&quot;EmptySet&quot;</code></li>
<li>output: LaTeX <code>\emptyset</code>, typeset $\emptyset$</li>
</ul>
</li>
<li>Test 2
<ul>
<li>input: JSON <code>[&quot;FiniteSet&quot;,[&quot;OneElementSequence&quot;,[&quot;Number&quot;,&quot;1&quot;]]]</code></li>
<li>output: LaTeX <code>\{1\}</code>, typeset ${1}$</li>
</ul>
</li>
<li>Test 3
<ul>
<li>input: JSON <code>[&quot;FiniteSet&quot;,[&quot;ElementThenSequence&quot;,[&quot;Number&quot;,&quot;1&quot;],[&quot;OneElementSequence&quot;,[&quot;Number&quot;,&quot;2&quot;]]]]</code></li>
<li>output: LaTeX <code>\{1,2\}</code>, typeset ${1,2}$</li>
</ul>
</li>
<li>Test 4
<ul>
<li>input: JSON <code>[&quot;FiniteSet&quot;,[&quot;ElementThenSequence&quot;,[&quot;Number&quot;,&quot;1&quot;],[&quot;ElementThenSequence&quot;,[&quot;Number&quot;,&quot;2&quot;],[&quot;OneElementSequence&quot;,[&quot;Number&quot;,&quot;3&quot;]]]]]</code></li>
<li>output: LaTeX <code>\{1,2,3\}</code>, typeset ${1,2,3}$</li>
</ul>
</li>
<li>Test 5
<ul>
<li>input: JSON <code>[&quot;FiniteSet&quot;,[&quot;ElementThenSequence&quot;,&quot;EmptySet&quot;,[&quot;OneElementSequence&quot;,&quot;EmptySet&quot;]]]</code></li>
<li>output: LaTeX <code>\{\emptyset,\emptyset\}</code>, typeset ${\emptyset,\emptyset}$</li>
</ul>
</li>
<li>Test 6
<ul>
<li>input: JSON <code>[&quot;FiniteSet&quot;,[&quot;OneElementSequence&quot;,[&quot;FiniteSet&quot;,[&quot;OneElementSequence&quot;,&quot;EmptySet&quot;]]]]</code></li>
<li>output: LaTeX <code>\{\{\emptyset\}\}</code>, typeset ${{\emptyset}}$</li>
</ul>
</li>
<li>Test 7
<ul>
<li>input: JSON <code>[&quot;FiniteSet&quot;,[&quot;ElementThenSequence&quot;,[&quot;Number&quot;,&quot;3&quot;],[&quot;OneElementSequence&quot;,[&quot;NumberVariable&quot;,&quot;x&quot;]]]]</code></li>
<li>output: LaTeX <code>\{3,x\}</code>, typeset ${3,x}$</li>
</ul>
</li>
<li>Test 8
<ul>
<li>input: JSON <code>[&quot;FiniteSet&quot;,[&quot;ElementThenSequence&quot;,[&quot;SetUnion&quot;,[&quot;SetVariable&quot;,&quot;A&quot;],[&quot;SetVariable&quot;,&quot;B&quot;]],[&quot;OneElementSequence&quot;,[&quot;SetIntersection&quot;,[&quot;SetVariable&quot;,&quot;A&quot;],[&quot;SetVariable&quot;,&quot;B&quot;]]]]]</code></li>
<li>output: LaTeX <code>\{A\cup B,A\cap B\}</code>, typeset ${A\cup B,A\cap B}$</li>
</ul>
</li>
<li>Test 9
<ul>
<li>input: JSON <code>[&quot;FiniteSet&quot;,[&quot;ElementThenSequence&quot;,[&quot;Number&quot;,&quot;1&quot;],[&quot;ElementThenSequence&quot;,[&quot;Number&quot;,&quot;2&quot;],[&quot;ElementThenSequence&quot;,&quot;EmptySet&quot;,[&quot;ElementThenSequence&quot;,[&quot;NumberVariable&quot;,&quot;K&quot;],[&quot;OneElementSequence&quot;,[&quot;NumberVariable&quot;,&quot;P&quot;]]]]]]]</code></li>
<li>output: LaTeX <code>\{1,2,\emptyset,K,P\}</code>, typeset ${1,2,\emptyset,K,P}$</li>
</ul>
</li>
</ul>
<h3>can convert tuples and vectors from JSON to LaTeX</h3>
<ul>
<li>Test 1
<ul>
<li>input: JSON <code>[&quot;Tuple&quot;,[&quot;ElementThenSequence&quot;,[&quot;Number&quot;,&quot;5&quot;],[&quot;OneElementSequence&quot;,[&quot;Number&quot;,&quot;6&quot;]]]]</code></li>
<li>output: LaTeX <code>(5,6)</code>, typeset $(5,6)$</li>
</ul>
</li>
<li>Test 2
<ul>
<li>input: JSON <code>[&quot;Tuple&quot;,[&quot;ElementThenSequence&quot;,[&quot;Number&quot;,&quot;5&quot;],[&quot;ElementThenSequence&quot;,[&quot;SetUnion&quot;,[&quot;SetVariable&quot;,&quot;A&quot;],[&quot;SetVariable&quot;,&quot;B&quot;]],[&quot;OneElementSequence&quot;,[&quot;NumberVariable&quot;,&quot;k&quot;]]]]]</code></li>
<li>output: LaTeX <code>(5,A\cup B,k)</code>, typeset $(5,A\cup B,k)$</li>
</ul>
</li>
<li>Test 3
<ul>
<li>input: JSON <code>[&quot;Vector&quot;,[&quot;NumberThenSequence&quot;,[&quot;Number&quot;,&quot;5&quot;],[&quot;OneNumberSequence&quot;,[&quot;Number&quot;,&quot;6&quot;]]]]</code></li>
<li>output: LaTeX <code>\langle 5,6\rangle</code>, typeset $\langle 5,6\rangle$</li>
</ul>
</li>
<li>Test 4
<ul>
<li>input: JSON <code>[&quot;Vector&quot;,[&quot;NumberThenSequence&quot;,[&quot;Number&quot;,&quot;5&quot;],[&quot;NumberThenSequence&quot;,[&quot;NumberNegation&quot;,[&quot;Number&quot;,&quot;7&quot;]],[&quot;OneNumberSequence&quot;,[&quot;NumberVariable&quot;,&quot;k&quot;]]]]]</code></li>
<li>output: LaTeX <code>\langle 5,-7,k\rangle</code>, typeset $\langle 5,-7,k\rangle$</li>
</ul>
</li>
<li>Test 5
<ul>
<li>input: JSON <code>[&quot;Tuple&quot;,[&quot;ElementThenSequence&quot;,[&quot;Tuple&quot;,[&quot;ElementThenSequence&quot;,[&quot;Number&quot;,&quot;1&quot;],[&quot;OneElementSequence&quot;,[&quot;Number&quot;,&quot;2&quot;]]]],[&quot;OneElementSequence&quot;,[&quot;Number&quot;,&quot;6&quot;]]]]</code></li>
<li>output: LaTeX <code>((1,2),6)</code>, typeset $((1,2),6)$</li>
</ul>
</li>
</ul>
<h3>can convert simple set memberships and subsets to LaTeX</h3>
<ul>
<li>Test 1
<ul>
<li>input: JSON <code>[&quot;NounIsElement&quot;,[&quot;NumberVariable&quot;,&quot;b&quot;],[&quot;SetVariable&quot;,&quot;B&quot;]]</code></li>
<li>output: LaTeX <code>b\in B</code>, typeset $b\in B$</li>
</ul>
</li>
<li>Test 2
<ul>
<li>input: JSON <code>[&quot;NounIsElement&quot;,[&quot;Number&quot;,&quot;2&quot;],[&quot;FiniteSet&quot;,[&quot;ElementThenSequence&quot;,[&quot;Number&quot;,&quot;1&quot;],[&quot;OneElementSequence&quot;,[&quot;Number&quot;,&quot;2&quot;]]]]]</code></li>
<li>output: LaTeX <code>2\in \{1,2\}</code>, typeset $2\in {1,2}$</li>
</ul>
</li>
<li>Test 3
<ul>
<li>input: JSON <code>[&quot;NounIsElement&quot;,[&quot;NumberVariable&quot;,&quot;X&quot;],[&quot;SetUnion&quot;,[&quot;SetVariable&quot;,&quot;a&quot;],[&quot;SetVariable&quot;,&quot;b&quot;]]]</code></li>
<li>output: LaTeX <code>X\in a\cup b</code>, typeset $X\in a\cup b$</li>
</ul>
</li>
<li>Test 4
<ul>
<li>input: JSON <code>[&quot;NounIsElement&quot;,[&quot;SetUnion&quot;,[&quot;SetVariable&quot;,&quot;A&quot;],[&quot;SetVariable&quot;,&quot;B&quot;]],[&quot;SetUnion&quot;,[&quot;SetVariable&quot;,&quot;X&quot;],[&quot;SetVariable&quot;,&quot;Y&quot;]]]</code></li>
<li>output: LaTeX <code>A\cup B\in X\cup Y</code>, typeset $A\cup B\in X\cup Y$</li>
</ul>
</li>
<li>Test 5
<ul>
<li>input: JSON <code>[&quot;Subset&quot;,[&quot;SetVariable&quot;,&quot;A&quot;],[&quot;SetComplement&quot;,[&quot;SetVariable&quot;,&quot;B&quot;]]]</code></li>
<li>output: LaTeX <code>A\subset \bar B</code>, typeset $A\subset \bar B$</li>
</ul>
</li>
<li>Test 6
<ul>
<li>input: JSON <code>[&quot;SubsetOrEqual&quot;,[&quot;SetIntersection&quot;,[&quot;SetVariable&quot;,&quot;u&quot;],[&quot;SetVariable&quot;,&quot;v&quot;]],[&quot;SetUnion&quot;,[&quot;SetVariable&quot;,&quot;u&quot;],[&quot;SetVariable&quot;,&quot;v&quot;]]]</code></li>
<li>output: LaTeX <code>u\cap v\subseteq u\cup v</code>, typeset $u\cap v\subseteq u\cup v$</li>
</ul>
</li>
<li>Test 7
<ul>
<li>input: JSON <code>[&quot;SubsetOrEqual&quot;,[&quot;FiniteSet&quot;,[&quot;OneElementSequence&quot;,[&quot;Number&quot;,&quot;1&quot;]]],[&quot;SetUnion&quot;,[&quot;FiniteSet&quot;,[&quot;OneElementSequence&quot;,[&quot;Number&quot;,&quot;1&quot;]]],[&quot;FiniteSet&quot;,[&quot;OneElementSequence&quot;,[&quot;Number&quot;,&quot;2&quot;]]]]]</code></li>
<li>output: LaTeX <code>\{1\}\subseteq \{1\}\cup \{2\}</code>, typeset ${1}\subseteq {1}\cup {2}$</li>
</ul>
</li>
<li>Test 8
<ul>
<li>input: JSON <code>[&quot;NounIsElement&quot;,[&quot;NumberVariable&quot;,&quot;p&quot;],[&quot;SetCartesianProduct&quot;,[&quot;SetVariable&quot;,&quot;U&quot;],[&quot;SetVariable&quot;,&quot;V&quot;]]]</code></li>
<li>output: LaTeX <code>p\in U\times V</code>, typeset $p\in U\times V$</li>
</ul>
</li>
<li>Test 9
<ul>
<li>input: JSON <code>[&quot;NounIsElement&quot;,[&quot;NumberVariable&quot;,&quot;q&quot;],[&quot;SetUnion&quot;,[&quot;SetComplement&quot;,[&quot;SetVariable&quot;,&quot;U&quot;]],[&quot;SetCartesianProduct&quot;,[&quot;SetVariable&quot;,&quot;V&quot;],[&quot;SetVariable&quot;,&quot;W&quot;]]]]</code></li>
<li>output: LaTeX <code>q\in \bar U\cup V\times W</code>, typeset $q\in \bar U\cup V\times W$</li>
</ul>
</li>
<li>Test 10
<ul>
<li>input: JSON <code>[&quot;NounIsElement&quot;,[&quot;Tuple&quot;,[&quot;ElementThenSequence&quot;,[&quot;NumberVariable&quot;,&quot;a&quot;],[&quot;OneElementSequence&quot;,[&quot;NumberVariable&quot;,&quot;b&quot;]]]],[&quot;SetCartesianProduct&quot;,[&quot;SetVariable&quot;,&quot;A&quot;],[&quot;SetVariable&quot;,&quot;B&quot;]]]</code></li>
<li>output: LaTeX <code>(a,b)\in A\times B</code>, typeset $(a,b)\in A\times B$</li>
</ul>
</li>
<li>Test 11
<ul>
<li>input: JSON <code>[&quot;NounIsElement&quot;,[&quot;Vector&quot;,[&quot;NumberThenSequence&quot;,[&quot;NumberVariable&quot;,&quot;a&quot;],[&quot;OneNumberSequence&quot;,[&quot;NumberVariable&quot;,&quot;b&quot;]]]],[&quot;SetCartesianProduct&quot;,[&quot;SetVariable&quot;,&quot;A&quot;],[&quot;SetVariable&quot;,&quot;B&quot;]]]</code></li>
<li>output: LaTeX <code>\langle a,b\rangle\in A\times B</code>, typeset $\langle a,b\rangle\in A\times B$</li>
</ul>
</li>
</ul>
<h3>can represent &quot;notin&quot; notation if JSON explicitly requests it</h3>
<ul>
<li>Test 1
<ul>
<li>input: JSON <code>[&quot;LogicalNegation&quot;,[&quot;NounIsElement&quot;,[&quot;NumberVariable&quot;,&quot;a&quot;],[&quot;SetVariable&quot;,&quot;A&quot;]]]</code></li>
<li>output: LaTeX <code>\neg a\in A</code>, typeset $\neg a\in A$</li>
</ul>
</li>
<li>Test 2
<ul>
<li>input: JSON <code>[&quot;LogicalNegation&quot;,[&quot;NounIsElement&quot;,&quot;EmptySet&quot;,&quot;EmptySet&quot;]]</code></li>
<li>output: LaTeX <code>\neg \emptyset\in \emptyset</code>, typeset $\neg \emptyset\in \emptyset$</li>
</ul>
</li>
<li>Test 3
<ul>
<li>input: JSON <code>[&quot;LogicalNegation&quot;,[&quot;NounIsElement&quot;,[&quot;Subtraction&quot;,[&quot;Number&quot;,&quot;3&quot;],[&quot;Number&quot;,&quot;5&quot;]],[&quot;SetIntersection&quot;,[&quot;SetVariable&quot;,&quot;K&quot;],[&quot;SetVariable&quot;,&quot;P&quot;]]]]</code></li>
<li>output: LaTeX <code>\neg 3-5\in K\cap P</code>, typeset $\neg 3-5\in K\cap P$</li>
</ul>
</li>
<li>Test 4
<ul>
<li>input: JSON <code>[&quot;NounIsNotElement&quot;,[&quot;NumberVariable&quot;,&quot;a&quot;],[&quot;SetVariable&quot;,&quot;A&quot;]]</code></li>
<li>output: LaTeX <code>a\notin A</code>, typeset $a\notin A$</li>
</ul>
</li>
<li>Test 5
<ul>
<li>input: JSON <code>[&quot;NounIsNotElement&quot;,&quot;EmptySet&quot;,&quot;EmptySet&quot;]</code></li>
<li>output: LaTeX <code>\emptyset\notin \emptyset</code>, typeset $\emptyset\notin \emptyset$</li>
</ul>
</li>
<li>Test 6
<ul>
<li>input: JSON <code>[&quot;NounIsNotElement&quot;,[&quot;Subtraction&quot;,[&quot;Number&quot;,&quot;3&quot;],[&quot;Number&quot;,&quot;5&quot;]],[&quot;SetIntersection&quot;,[&quot;SetVariable&quot;,&quot;K&quot;],[&quot;SetVariable&quot;,&quot;P&quot;]]]</code></li>
<li>output: LaTeX <code>3-5\notin K\cap P</code>, typeset $3-5\notin K\cap P$</li>
</ul>
</li>
</ul>
<h3>can convert to LaTeX sentences built from various relations</h3>
<ul>
<li>Test 1
<ul>
<li>input: JSON <code>[&quot;Disjunction&quot;,[&quot;LogicVariable&quot;,&quot;P&quot;],[&quot;NounIsElement&quot;,[&quot;NumberVariable&quot;,&quot;b&quot;],[&quot;SetVariable&quot;,&quot;B&quot;]]]</code></li>
<li>output: LaTeX <code>P\vee b\in B</code>, typeset $P\vee b\in B$</li>
</ul>
</li>
<li>Test 2
<ul>
<li>input: JSON <code>[&quot;PropositionIsElement&quot;,[&quot;Disjunction&quot;,[&quot;LogicVariable&quot;,&quot;P&quot;],[&quot;LogicVariable&quot;,&quot;b&quot;]],[&quot;SetVariable&quot;,&quot;B&quot;]]</code></li>
<li>output: LaTeX <code>{P\vee b}\in B</code>, typeset ${P\vee b}\in B$</li>
</ul>
</li>
<li>Test 3
<ul>
<li>input: JSON <code>[&quot;UniversalQuantifier&quot;,[&quot;NumberVariable&quot;,&quot;x&quot;],[&quot;NounIsElement&quot;,[&quot;NumberVariable&quot;,&quot;x&quot;],[&quot;SetVariable&quot;,&quot;X&quot;]]]</code></li>
<li>output: LaTeX <code>\forall x, x\in X</code>, typeset $\forall x, x\in X$</li>
</ul>
</li>
<li>Test 4
<ul>
<li>input: JSON <code>[&quot;Conjunction&quot;,[&quot;SubsetOrEqual&quot;,[&quot;SetVariable&quot;,&quot;A&quot;],[&quot;SetVariable&quot;,&quot;B&quot;]],[&quot;SubsetOrEqual&quot;,[&quot;SetVariable&quot;,&quot;B&quot;],[&quot;SetVariable&quot;,&quot;A&quot;]]]</code></li>
<li>output: LaTeX <code>A\subseteq B\wedge B\subseteq A</code>, typeset $A\subseteq B\wedge B\subseteq A$</li>
</ul>
</li>
<li>Test 5
<ul>
<li>input: JSON <code>[&quot;Equals&quot;,[&quot;SetVariable&quot;,&quot;R&quot;],[&quot;SetCartesianProduct&quot;,[&quot;SetVariable&quot;,&quot;A&quot;],[&quot;SetVariable&quot;,&quot;B&quot;]]]</code></li>
<li>output: LaTeX <code>R=A\times B</code>, typeset $R=A\times B$</li>
</ul>
</li>
<li>Test 6
<ul>
<li>input: JSON <code>[&quot;UniversalQuantifier&quot;,[&quot;NumberVariable&quot;,&quot;n&quot;],[&quot;BinaryRelationHolds&quot;,&quot;Divides&quot;,[&quot;NumberVariable&quot;,&quot;n&quot;],[&quot;Factorial&quot;,[&quot;NumberVariable&quot;,&quot;n&quot;]]]]</code></li>
<li>output: LaTeX <code>\forall n, n | n!</code>, typeset $\forall n, n | n!$</li>
</ul>
</li>
<li>Test 7
<ul>
<li>input: JSON <code>[&quot;Implication&quot;,[&quot;BinaryRelationHolds&quot;,&quot;GenericBinaryRelation&quot;,[&quot;NumberVariable&quot;,&quot;a&quot;],[&quot;NumberVariable&quot;,&quot;b&quot;]],[&quot;BinaryRelationHolds&quot;,&quot;GenericBinaryRelation&quot;,[&quot;NumberVariable&quot;,&quot;b&quot;],[&quot;NumberVariable&quot;,&quot;a&quot;]]]</code></li>
<li>output: LaTeX <code>a \sim b\Rightarrow b \sim a</code>, typeset $a \sim b\Rightarrow b \sim a$</li>
</ul>
</li>
</ul>
<h3>can create LaTeX notation related to functions</h3>
<ul>
<li>Test 1
<ul>
<li>input: JSON <code>[&quot;FunctionSignature&quot;,[&quot;FunctionVariable&quot;,&quot;f&quot;],[&quot;SetVariable&quot;,&quot;A&quot;],[&quot;SetVariable&quot;,&quot;B&quot;]]</code></li>
<li>output: LaTeX <code>f:A\to B</code>, typeset $f:A\to B$</li>
</ul>
</li>
<li>Test 2
<ul>
<li>input: JSON <code>[&quot;LogicalNegation&quot;,[&quot;FunctionSignature&quot;,[&quot;FunctionVariable&quot;,&quot;F&quot;],[&quot;SetUnion&quot;,[&quot;SetVariable&quot;,&quot;X&quot;],[&quot;SetVariable&quot;,&quot;Y&quot;]],[&quot;SetVariable&quot;,&quot;Z&quot;]]]</code></li>
<li>output: LaTeX <code>\neg F:X\cup Y\to Z</code>, typeset $\neg F:X\cup Y\to Z$</li>
</ul>
</li>
<li>Test 3
<ul>
<li>input: JSON <code>[&quot;FunctionSignature&quot;,[&quot;FunctionComposition&quot;,[&quot;FunctionVariable&quot;,&quot;f&quot;],[&quot;FunctionVariable&quot;,&quot;g&quot;]],[&quot;SetVariable&quot;,&quot;A&quot;],[&quot;SetVariable&quot;,&quot;C&quot;]]</code></li>
<li>output: LaTeX <code>f\circ g:A\to C</code>, typeset $f\circ g:A\to C$</li>
</ul>
</li>
<li>Test 4
<ul>
<li>input: JSON <code>[&quot;NumberFunctionApplication&quot;,[&quot;FunctionVariable&quot;,&quot;f&quot;],[&quot;NumberVariable&quot;,&quot;x&quot;]]</code></li>
<li>output: LaTeX <code>f(x)</code>, typeset $f(x)$</li>
</ul>
</li>
<li>Test 5
<ul>
<li>input: JSON <code>[&quot;NumberFunctionApplication&quot;,[&quot;FunctionInverse&quot;,[&quot;FunctionVariable&quot;,&quot;f&quot;]],[&quot;NumberFunctionApplication&quot;,[&quot;FunctionInverse&quot;,[&quot;FunctionVariable&quot;,&quot;g&quot;]],[&quot;Number&quot;,&quot;10&quot;]]]</code></li>
<li>output: LaTeX <code>f ^ { - 1 }(g ^ { - 1 }(10))</code>, typeset $f ^ { - 1 }(g ^ { - 1 }(10))$</li>
</ul>
</li>
<li>Test 6
<ul>
<li>input: JSON <code>[&quot;NumberFunctionApplication&quot;,[&quot;FunctionVariable&quot;,&quot;E&quot;],[&quot;SetComplement&quot;,[&quot;SetVariable&quot;,&quot;L&quot;]]]</code></li>
<li>output: LaTeX <code>E(\bar L)</code>, typeset $E(\bar L)$</li>
</ul>
</li>
<li>Test 7
<ul>
<li>input: JSON <code>[&quot;SetIntersection&quot;,&quot;EmptySet&quot;,[&quot;SetFunctionApplication&quot;,[&quot;FunctionVariable&quot;,&quot;f&quot;],[&quot;Number&quot;,&quot;2&quot;]]]</code></li>
<li>output: LaTeX <code>\emptyset\cap f(2)</code>, typeset $\emptyset\cap f(2)$</li>
</ul>
</li>
<li>Test 8
<ul>
<li>input: JSON <code>[&quot;Conjunction&quot;,[&quot;PropositionFunctionApplication&quot;,[&quot;FunctionVariable&quot;,&quot;P&quot;],[&quot;NumberVariable&quot;,&quot;e&quot;]],[&quot;PropositionFunctionApplication&quot;,[&quot;FunctionVariable&quot;,&quot;Q&quot;],[&quot;Addition&quot;,[&quot;Number&quot;,&quot;3&quot;],[&quot;NumberVariable&quot;,&quot;b&quot;]]]]</code></li>
<li>output: LaTeX <code>P(e)\wedge Q(3+b)</code>, typeset $P(e)\wedge Q(3+b)$</li>
</ul>
</li>
<li>Test 9
<ul>
<li>input: JSON <code>[&quot;EqualFunctions&quot;,[&quot;FunctionVariable&quot;,&quot;F&quot;],[&quot;FunctionComposition&quot;,[&quot;FunctionVariable&quot;,&quot;G&quot;],[&quot;FunctionInverse&quot;,[&quot;FunctionVariable&quot;,&quot;H&quot;]]]]</code></li>
<li>output: LaTeX <code>F=G\circ H ^ { - 1 }</code>, typeset $F=G\circ H ^ { - 1 }$</li>
</ul>
</li>
</ul>
<h3>can represent trigonometric functions correctly</h3>
<ul>
<li>Test 1
<ul>
<li>input: JSON <code>[&quot;PrefixFunctionApplication&quot;,&quot;SineFunction&quot;,[&quot;NumberVariable&quot;,&quot;x&quot;]]</code></li>
<li>output: LaTeX <code>\sin x</code>, typeset $\sin x$</li>
</ul>
</li>
<li>Test 2
<ul>
<li>input: JSON <code>[&quot;PrefixFunctionApplication&quot;,&quot;CosineFunction&quot;,[&quot;Multiplication&quot;,&quot;Pi&quot;,[&quot;NumberVariable&quot;,&quot;x&quot;]]]</code></li>
<li>output: LaTeX <code>\cos \pi\times x</code>, typeset $\cos \pi\times x$</li>
</ul>
</li>
<li>Test 3
<ul>
<li>input: JSON <code>[&quot;PrefixFunctionApplication&quot;,&quot;TangentFunction&quot;,[&quot;NumberVariable&quot;,&quot;t&quot;]]</code></li>
<li>output: LaTeX <code>\tan t</code>, typeset $\tan t$</li>
</ul>
</li>
<li>Test 4
<ul>
<li>input: JSON <code>[&quot;Division&quot;,[&quot;Number&quot;,&quot;1&quot;],[&quot;PrefixFunctionApplication&quot;,&quot;CotangentFunction&quot;,&quot;Pi&quot;]]</code></li>
<li>output: LaTeX <code>1\div \cot \pi</code>, typeset $1\div \cot \pi$</li>
</ul>
</li>
<li>Test 5
<ul>
<li>input: JSON <code>[&quot;Equals&quot;,[&quot;PrefixFunctionApplication&quot;,&quot;SecantFunction&quot;,[&quot;NumberVariable&quot;,&quot;y&quot;]],[&quot;PrefixFunctionApplication&quot;,&quot;CosecantFunction&quot;,[&quot;NumberVariable&quot;,&quot;y&quot;]]]</code></li>
<li>output: LaTeX <code>\sec y=\csc y</code>, typeset $\sec y=\csc y$</li>
</ul>
</li>
</ul>
<h3>can express logarithms correctly</h3>
<ul>
<li>Test 1
<ul>
<li>input: JSON <code>[&quot;PrefixFunctionApplication&quot;,&quot;Logarithm&quot;,[&quot;NumberVariable&quot;,&quot;n&quot;]]</code></li>
<li>output: LaTeX <code>\log n</code>, typeset $\log n$</li>
</ul>
</li>
<li>Test 2
<ul>
<li>input: JSON <code>[&quot;Addition&quot;,[&quot;Number&quot;,&quot;1&quot;],[&quot;PrefixFunctionApplication&quot;,&quot;NaturalLogarithm&quot;,[&quot;NumberVariable&quot;,&quot;x&quot;]]]</code></li>
<li>output: LaTeX <code>1+\ln x</code>, typeset $1+\ln x$</li>
</ul>
</li>
<li>Test 3
<ul>
<li>input: JSON <code>[&quot;PrefixFunctionApplication&quot;,[&quot;LogarithmWithBase&quot;,[&quot;Number&quot;,&quot;2&quot;]],[&quot;Number&quot;,&quot;1024&quot;]]</code></li>
<li>output: LaTeX <code>\log_2 1024</code>, typeset $\log_2 1024$</li>
</ul>
</li>
<li>Test 4
<ul>
<li>input: JSON <code>[&quot;Division&quot;,[&quot;PrefixFunctionApplication&quot;,&quot;Logarithm&quot;,[&quot;NumberVariable&quot;,&quot;n&quot;]],[&quot;PrefixFunctionApplication&quot;,&quot;Logarithm&quot;,[&quot;PrefixFunctionApplication&quot;,&quot;Logarithm&quot;,[&quot;NumberVariable&quot;,&quot;n&quot;]]]]</code></li>
<li>output: LaTeX <code>\log n\div \log \log n</code>, typeset $\log n\div \log \log n$</li>
</ul>
</li>
</ul>
<h3>can express equivalence classes and expressions that use them</h3>
<ul>
<li>Test 1
<ul>
<li>input: JSON <code>[&quot;EquivalenceClass&quot;,[&quot;Number&quot;,&quot;1&quot;],&quot;ApproximatelyEqual&quot;]</code></li>
<li>output: LaTeX <code>[1,\approx]</code>, typeset $[1,\approx]$</li>
</ul>
</li>
<li>Test 2
<ul>
<li>input: JSON <code>[&quot;EquivalenceClass&quot;,[&quot;Addition&quot;,[&quot;NumberVariable&quot;,&quot;x&quot;],[&quot;Number&quot;,&quot;2&quot;]],&quot;GenericBinaryRelation&quot;]</code></li>
<li>output: LaTeX <code>[x+2,\sim]</code>, typeset $[x+2,\sim]$</li>
</ul>
</li>
<li>Test 3
<ul>
<li>input: JSON <code>[&quot;SetUnion&quot;,[&quot;EquivalenceClass&quot;,[&quot;Number&quot;,&quot;1&quot;],&quot;ApproximatelyEqual&quot;],[&quot;EquivalenceClass&quot;,[&quot;Number&quot;,&quot;2&quot;],&quot;ApproximatelyEqual&quot;]]</code></li>
<li>output: LaTeX <code>[1,\approx]\cup [2,\approx]</code>, typeset $[1,\approx]\cup [2,\approx]$</li>
</ul>
</li>
<li>Test 4
<ul>
<li>input: JSON <code>[&quot;NounIsElement&quot;,[&quot;Number&quot;,&quot;7&quot;],[&quot;EquivalenceClass&quot;,[&quot;Number&quot;,&quot;7&quot;],&quot;GenericBinaryRelation&quot;]]</code></li>
<li>output: LaTeX <code>7\in [7,\sim]</code>, typeset $7\in [7,\sim]$</li>
</ul>
</li>
<li>Test 5
<ul>
<li>input: JSON <code>[&quot;GenericEquivalenceClass&quot;,[&quot;NumberVariable&quot;,&quot;P&quot;]]</code></li>
<li>output: LaTeX <code>[P]</code>, typeset $[P]$</li>
</ul>
</li>
</ul>
<h3>can express equivalence and classes mod a number</h3>
<ul>
<li>Test 1
<ul>
<li>input: JSON <code>[&quot;EquivalentModulo&quot;,[&quot;Number&quot;,&quot;5&quot;],[&quot;Number&quot;,&quot;11&quot;],[&quot;Number&quot;,&quot;3&quot;]]</code></li>
<li>output: LaTeX <code>5 \equiv 11 \mod 3</code>, typeset $5 \equiv 11 \mod 3$</li>
</ul>
</li>
<li>Test 2
<ul>
<li>input: JSON <code>[&quot;EquivalentModulo&quot;,[&quot;NumberVariable&quot;,&quot;k&quot;],[&quot;NumberVariable&quot;,&quot;m&quot;],[&quot;NumberVariable&quot;,&quot;n&quot;]]</code></li>
<li>output: LaTeX <code>k \equiv m \mod n</code>, typeset $k \equiv m \mod n$</li>
</ul>
</li>
<li>Test 3
<ul>
<li>input: JSON <code>[&quot;Subset&quot;,&quot;EmptySet&quot;,[&quot;EquivalenceClassModulo&quot;,[&quot;NumberNegation&quot;,[&quot;Number&quot;,&quot;1&quot;]],[&quot;Number&quot;,&quot;10&quot;]]]</code></li>
<li>output: LaTeX <code>\emptyset\subset [-1, \equiv _ 10]</code>, typeset $\emptyset\subset [-1, \equiv _ 10]$</li>
</ul>
</li>
</ul>
<h3>can construct type sentences and combinations of them</h3>
<ul>
<li>Test 1
<ul>
<li>input: JSON <code>[&quot;HasType&quot;,[&quot;NumberVariable&quot;,&quot;x&quot;],&quot;SetType&quot;]</code></li>
<li>output: LaTeX <code>x \text{is a set}</code>, typeset $x \text{is a set}$</li>
</ul>
</li>
<li>Test 2
<ul>
<li>input: JSON <code>[&quot;HasType&quot;,[&quot;NumberVariable&quot;,&quot;n&quot;],&quot;NumberType&quot;]</code></li>
<li>output: LaTeX <code>n \text{is a number}</code>, typeset $n \text{is a number}$</li>
</ul>
</li>
<li>Test 3
<ul>
<li>input: JSON <code>[&quot;HasType&quot;,[&quot;NumberVariable&quot;,&quot;S&quot;],&quot;PartialOrderType&quot;]</code></li>
<li>output: LaTeX <code>S \text{is a partial order}</code>, typeset $S \text{is a partial order}$</li>
</ul>
</li>
<li>Test 4
<ul>
<li>input: JSON <code>[&quot;Conjunction&quot;,[&quot;HasType&quot;,[&quot;Number&quot;,&quot;1&quot;],&quot;NumberType&quot;],[&quot;HasType&quot;,[&quot;Number&quot;,&quot;10&quot;],&quot;NumberType&quot;]]</code></li>
<li>output: LaTeX <code>1 \text{is a number}\wedge 10 \text{is a number}</code>, typeset $1 \text{is a number}\wedge 10 \text{is a number}$</li>
</ul>
</li>
<li>Test 5
<ul>
<li>input: JSON <code>[&quot;Implication&quot;,[&quot;HasType&quot;,[&quot;NumberVariable&quot;,&quot;R&quot;],&quot;EquivalenceRelationType&quot;],[&quot;HasType&quot;,[&quot;NumberVariable&quot;,&quot;R&quot;],&quot;RelationType&quot;]]</code></li>
<li>output: LaTeX <code>R \text{is an equivalence relation}\Rightarrow R \text{is a relation}</code>, typeset $R \text{is an equivalence relation}\Rightarrow R \text{is a relation}$</li>
</ul>
</li>
</ul>
<h3>can create notation for expression function application</h3>
<ul>
<li>Test 1
<ul>
<li>input: JSON <code>[&quot;NumberEFA&quot;,[&quot;FunctionVariable&quot;,&quot;f&quot;],[&quot;NumberVariable&quot;,&quot;x&quot;]]</code></li>
<li>output: LaTeX <code>\mathcal{f} (x)</code>, typeset $\mathcal{f} (x)$</li>
</ul>
</li>
<li>Test 2
<ul>
<li>input: JSON <code>[&quot;NumberFunctionApplication&quot;,[&quot;FunctionVariable&quot;,&quot;F&quot;],[&quot;NumberEFA&quot;,[&quot;FunctionVariable&quot;,&quot;k&quot;],[&quot;Number&quot;,&quot;10&quot;]]]</code></li>
<li>output: LaTeX <code>F(\mathcal{k} (10))</code>, typeset $F(\mathcal{k} (10))$</li>
</ul>
</li>
<li>Test 3
<ul>
<li>input: JSON <code>[&quot;NumberEFA&quot;,[&quot;FunctionVariable&quot;,&quot;E&quot;],[&quot;SetComplement&quot;,[&quot;SetVariable&quot;,&quot;L&quot;]]]</code></li>
<li>output: LaTeX <code>\mathcal{E} (\bar L)</code>, typeset $\mathcal{E} (\bar L)$</li>
</ul>
</li>
<li>Test 4
<ul>
<li>input: JSON <code>[&quot;SetIntersection&quot;,&quot;EmptySet&quot;,[&quot;SetEFA&quot;,[&quot;FunctionVariable&quot;,&quot;f&quot;],[&quot;Number&quot;,&quot;2&quot;]]]</code></li>
<li>output: LaTeX <code>\emptyset\cap \mathcal{f} (2)</code>, typeset $\emptyset\cap \mathcal{f} (2)$</li>
</ul>
</li>
<li>Test 5
<ul>
<li>input: JSON <code>[&quot;Conjunction&quot;,[&quot;PropositionEFA&quot;,[&quot;FunctionVariable&quot;,&quot;P&quot;],[&quot;NumberVariable&quot;,&quot;x&quot;]],[&quot;PropositionEFA&quot;,[&quot;FunctionVariable&quot;,&quot;Q&quot;],[&quot;NumberVariable&quot;,&quot;y&quot;]]]</code></li>
<li>output: LaTeX <code>\mathcal{P} (x)\wedge \mathcal{Q} (y)</code>, typeset $\mathcal{P} (x)\wedge \mathcal{Q} (y)$</li>
</ul>
</li>
</ul>
<h3>can create notation for assumptions</h3>
<ul>
<li>Test 1
<ul>
<li>input: JSON <code>[&quot;Given_Variant1&quot;,[&quot;LogicVariable&quot;,&quot;X&quot;]]</code></li>
<li>output: LaTeX <code>\text{Assume }X</code>, typeset $\text{Assume }X$</li>
</ul>
</li>
<li>Test 2
<ul>
<li>input: JSON <code>[&quot;Given_Variant2&quot;,[&quot;LogicVariable&quot;,&quot;X&quot;]]</code></li>
<li>output: LaTeX <code>\text{assume }X</code>, typeset $\text{assume }X$</li>
</ul>
</li>
<li>Test 3
<ul>
<li>input: JSON <code>[&quot;Given_Variant3&quot;,[&quot;LogicVariable&quot;,&quot;X&quot;]]</code></li>
<li>output: LaTeX <code>\text{Given }X</code>, typeset $\text{Given }X$</li>
</ul>
</li>
<li>Test 4
<ul>
<li>input: JSON <code>[&quot;Given_Variant4&quot;,[&quot;LogicVariable&quot;,&quot;X&quot;]]</code></li>
<li>output: LaTeX <code>\text{given }X</code>, typeset $\text{given }X$</li>
</ul>
</li>
<li>Test 5
<ul>
<li>input: JSON <code>[&quot;Given_Variant1&quot;,[&quot;Equals&quot;,[&quot;NumberVariable&quot;,&quot;k&quot;],[&quot;Number&quot;,&quot;1000&quot;]]]</code></li>
<li>output: LaTeX <code>\text{Assume }k=1000</code>, typeset $\text{Assume }k=1000$</li>
</ul>
</li>
<li>Test 6
<ul>
<li>input: JSON <code>[&quot;Given_Variant2&quot;,[&quot;Equals&quot;,[&quot;NumberVariable&quot;,&quot;k&quot;],[&quot;Number&quot;,&quot;1000&quot;]]]</code></li>
<li>output: LaTeX <code>\text{assume }k=1000</code>, typeset $\text{assume }k=1000$</li>
</ul>
</li>
<li>Test 7
<ul>
<li>input: JSON <code>[&quot;Given_Variant3&quot;,[&quot;Equals&quot;,[&quot;NumberVariable&quot;,&quot;k&quot;],[&quot;Number&quot;,&quot;1000&quot;]]]</code></li>
<li>output: LaTeX <code>\text{Given }k=1000</code>, typeset $\text{Given }k=1000$</li>
</ul>
</li>
<li>Test 8
<ul>
<li>input: JSON <code>[&quot;Given_Variant4&quot;,[&quot;Equals&quot;,[&quot;NumberVariable&quot;,&quot;k&quot;],[&quot;Number&quot;,&quot;1000&quot;]]]</code></li>
<li>output: LaTeX <code>\text{given }k=1000</code>, typeset $\text{given }k=1000$</li>
</ul>
</li>
<li>Test 9
<ul>
<li>input: JSON <code>[&quot;Given_Variant1&quot;,&quot;LogicalTrue&quot;]</code></li>
<li>output: LaTeX <code>\text{Assume }\top</code>, typeset $\text{Assume }\top$</li>
</ul>
</li>
<li>Test 10
<ul>
<li>input: JSON <code>[&quot;Given_Variant2&quot;,&quot;LogicalTrue&quot;]</code></li>
<li>output: LaTeX <code>\text{assume }\top</code>, typeset $\text{assume }\top$</li>
</ul>
</li>
<li>Test 11
<ul>
<li>input: JSON <code>[&quot;Given_Variant3&quot;,&quot;LogicalTrue&quot;]</code></li>
<li>output: LaTeX <code>\text{Given }\top</code>, typeset $\text{Given }\top$</li>
</ul>
</li>
<li>Test 12
<ul>
<li>input: JSON <code>[&quot;Given_Variant4&quot;,&quot;LogicalTrue&quot;]</code></li>
<li>output: LaTeX <code>\text{given }\top</code>, typeset $\text{given }\top$</li>
</ul>
</li>
</ul>
<h3>can create notation for Let-style declarations</h3>
<ul>
<li>Test 1
<ul>
<li>input: JSON <code>[&quot;Let_Variant1&quot;,[&quot;NumberVariable&quot;,&quot;x&quot;]]</code></li>
<li>output: LaTeX <code>\text{Let }x</code>, typeset $\text{Let }x$</li>
</ul>
</li>
<li>Test 2
<ul>
<li>input: JSON <code>[&quot;Let_Variant2&quot;,[&quot;NumberVariable&quot;,&quot;x&quot;]]</code></li>
<li>output: LaTeX <code>\text{let }x</code>, typeset $\text{let }x$</li>
</ul>
</li>
<li>Test 3
<ul>
<li>input: JSON <code>[&quot;Let_Variant1&quot;,[&quot;NumberVariable&quot;,&quot;T&quot;]]</code></li>
<li>output: LaTeX <code>\text{Let }T</code>, typeset $\text{Let }T$</li>
</ul>
</li>
<li>Test 4
<ul>
<li>input: JSON <code>[&quot;Let_Variant2&quot;,[&quot;NumberVariable&quot;,&quot;T&quot;]]</code></li>
<li>output: LaTeX <code>\text{let }T</code>, typeset $\text{let }T$</li>
</ul>
</li>
<li>Test 5
<ul>
<li>input: JSON <code>[&quot;LetBeSuchThat_Variant1&quot;,[&quot;NumberVariable&quot;,&quot;x&quot;],[&quot;GreaterThan&quot;,[&quot;NumberVariable&quot;,&quot;x&quot;],[&quot;Number&quot;,&quot;0&quot;]]]</code></li>
<li>output: LaTeX <code>\text{Let }x \text{ be such that }x&gt;0</code>, typeset $\text{Let }x \text{ be such that }x&gt;0$</li>
</ul>
</li>
<li>Test 6
<ul>
<li>input: JSON <code>[&quot;LetBeSuchThat_Variant2&quot;,[&quot;NumberVariable&quot;,&quot;x&quot;],[&quot;GreaterThan&quot;,[&quot;NumberVariable&quot;,&quot;x&quot;],[&quot;Number&quot;,&quot;0&quot;]]]</code></li>
<li>output: LaTeX <code>\text{let }x \text{ be such that }x&gt;0</code>, typeset $\text{let }x \text{ be such that }x&gt;0$</li>
</ul>
</li>
<li>Test 7
<ul>
<li>input: JSON <code>[&quot;LetBeSuchThat_Variant1&quot;,[&quot;NumberVariable&quot;,&quot;T&quot;],[&quot;Disjunction&quot;,[&quot;Equals&quot;,[&quot;NumberVariable&quot;,&quot;T&quot;],[&quot;Number&quot;,&quot;5&quot;]],[&quot;NounIsElement&quot;,[&quot;NumberVariable&quot;,&quot;T&quot;],[&quot;SetVariable&quot;,&quot;S&quot;]]]]</code></li>
<li>output: LaTeX <code>\text{Let }T \text{ be such that }T=5\vee T\in S</code>, typeset $\text{Let }T \text{ be such that }T=5\vee T\in S$</li>
</ul>
</li>
<li>Test 8
<ul>
<li>input: JSON <code>[&quot;LetBeSuchThat_Variant2&quot;,[&quot;NumberVariable&quot;,&quot;T&quot;],[&quot;Disjunction&quot;,[&quot;Equals&quot;,[&quot;NumberVariable&quot;,&quot;T&quot;],[&quot;Number&quot;,&quot;5&quot;]],[&quot;NounIsElement&quot;,[&quot;NumberVariable&quot;,&quot;T&quot;],[&quot;SetVariable&quot;,&quot;S&quot;]]]]</code></li>
<li>output: LaTeX <code>\text{let }T \text{ be such that }T=5\vee T\in S</code>, typeset $\text{let }T \text{ be such that }T=5\vee T\in S$</li>
</ul>
</li>
</ul>
<h3>can parse notation for For Some-style declarations</h3>
<ul>
<li>Test 1
<ul>
<li>input: JSON <code>[&quot;ForSome_Variant1&quot;,[&quot;NumberVariable&quot;,&quot;x&quot;],[&quot;GreaterThan&quot;,[&quot;NumberVariable&quot;,&quot;x&quot;],[&quot;Number&quot;,&quot;0&quot;]]]</code></li>
<li>output: LaTeX <code>\text{For some }x, x&gt;0</code>, typeset $\text{For some }x, x&gt;0$</li>
</ul>
</li>
<li>Test 2
<ul>
<li>input: JSON <code>[&quot;ForSome_Variant2&quot;,[&quot;NumberVariable&quot;,&quot;x&quot;],[&quot;GreaterThan&quot;,[&quot;NumberVariable&quot;,&quot;x&quot;],[&quot;Number&quot;,&quot;0&quot;]]]</code></li>
<li>output: LaTeX <code>\text{for some }x, x&gt;0</code>, typeset $\text{for some }x, x&gt;0$</li>
</ul>
</li>
<li>Test 3
<ul>
<li>input: JSON <code>[&quot;ForSome_Variant3&quot;,[&quot;NumberVariable&quot;,&quot;x&quot;],[&quot;GreaterThan&quot;,[&quot;NumberVariable&quot;,&quot;x&quot;],[&quot;Number&quot;,&quot;0&quot;]]]</code></li>
<li>output: LaTeX <code>x&gt;0 \text{ for some } x</code>, typeset $x&gt;0 \text{ for some } x$</li>
</ul>
</li>
<li>Test 4
<ul>
<li>input: JSON <code>[&quot;ForSome_Variant4&quot;,[&quot;NumberVariable&quot;,&quot;x&quot;],[&quot;GreaterThan&quot;,[&quot;NumberVariable&quot;,&quot;x&quot;],[&quot;Number&quot;,&quot;0&quot;]]]</code></li>
<li>output: LaTeX <code>x&gt;0~\text{for some}~x</code>, typeset $x&gt;0~\text{for some}~x$</li>
</ul>
</li>
<li>Test 5
<ul>
<li>input: JSON <code>[&quot;ForSome_Variant1&quot;,[&quot;NumberVariable&quot;,&quot;T&quot;],[&quot;Disjunction&quot;,[&quot;Equals&quot;,[&quot;NumberVariable&quot;,&quot;T&quot;],[&quot;Number&quot;,&quot;5&quot;]],[&quot;NounIsElement&quot;,[&quot;NumberVariable&quot;,&quot;T&quot;],[&quot;SetVariable&quot;,&quot;S&quot;]]]]</code></li>
<li>output: LaTeX <code>\text{For some }T, T=5\vee T\in S</code>, typeset $\text{For some }T, T=5\vee T\in S$</li>
</ul>
</li>
<li>Test 6
<ul>
<li>input: JSON <code>[&quot;ForSome_Variant2&quot;,[&quot;NumberVariable&quot;,&quot;T&quot;],[&quot;Disjunction&quot;,[&quot;Equals&quot;,[&quot;NumberVariable&quot;,&quot;T&quot;],[&quot;Number&quot;,&quot;5&quot;]],[&quot;NounIsElement&quot;,[&quot;NumberVariable&quot;,&quot;T&quot;],[&quot;SetVariable&quot;,&quot;S&quot;]]]]</code></li>
<li>output: LaTeX <code>\text{for some }T, T=5\vee T\in S</code>, typeset $\text{for some }T, T=5\vee T\in S$</li>
</ul>
</li>
<li>Test 7
<ul>
<li>input: JSON <code>[&quot;ForSome_Variant3&quot;,[&quot;NumberVariable&quot;,&quot;T&quot;],[&quot;Disjunction&quot;,[&quot;Equals&quot;,[&quot;NumberVariable&quot;,&quot;T&quot;],[&quot;Number&quot;,&quot;5&quot;]],[&quot;NounIsElement&quot;,[&quot;NumberVariable&quot;,&quot;T&quot;],[&quot;SetVariable&quot;,&quot;S&quot;]]]]</code></li>
<li>output: LaTeX <code>T=5\vee T\in S \text{ for some } T</code>, typeset $T=5\vee T\in S \text{ for some } T$</li>
</ul>
</li>
<li>Test 8
<ul>
<li>input: JSON <code>[&quot;ForSome_Variant4&quot;,[&quot;NumberVariable&quot;,&quot;T&quot;],[&quot;Disjunction&quot;,[&quot;Equals&quot;,[&quot;NumberVariable&quot;,&quot;T&quot;],[&quot;Number&quot;,&quot;5&quot;]],[&quot;NounIsElement&quot;,[&quot;NumberVariable&quot;,&quot;T&quot;],[&quot;SetVariable&quot;,&quot;S&quot;]]]]</code></li>
<li>output: LaTeX <code>T=5\vee T\in S~\text{for some}~T</code>, typeset $T=5\vee T\in S~\text{for some}~T$</li>
</ul>
</li>
</ul>
<h2><a name="Converting-putdown-to-LaTeX">Converting putdown to LaTeX</a></h2>
<h3>correctly converts many kinds of numbers but not malformed ones</h3>
<ul>
<li>Test 1
<ul>
<li>input: putdown <code>0</code></li>
<li>output: LaTeX <code>0</code>, typeset $0$</li>
</ul>
</li>
<li>Test 2
<ul>
<li>input: putdown <code>328975289</code></li>
<li>output: LaTeX <code>328975289</code>, typeset $328975289$</li>
</ul>
</li>
<li>Test 3
<ul>
<li>input: putdown <code>(- 9097285323)</code></li>
<li>output: LaTeX <code>-9097285323</code>, typeset $-9097285323$</li>
</ul>
</li>
<li>Test 4
<ul>
<li>input: putdown <code>0.0</code></li>
<li>output: LaTeX <code>0.0</code>, typeset $0.0$</li>
</ul>
</li>
<li>Test 5
<ul>
<li>input: putdown <code>32897.5289</code></li>
<li>output: LaTeX <code>32897.5289</code>, typeset $32897.5289$</li>
</ul>
</li>
<li>Test 6
<ul>
<li>input: putdown <code>(- 1.9097285323)</code></li>
<li>output: LaTeX <code>-1.9097285323</code>, typeset $-1.9097285323$</li>
</ul>
</li>
<li>Test 7
<ul>
<li>input: putdown <code>0.0.0</code></li>
<li>output: LaTeX <code>null</code>, typeset $undefined$</li>
</ul>
</li>
<li>Test 8
<ul>
<li>input: putdown <code>0k0</code></li>
<li>output: LaTeX <code>null</code>, typeset $undefined$</li>
</ul>
</li>
</ul>
<h3>correctly converts one-letter variable names but not larger ones</h3>
<ul>
<li>Test 1
<ul>
<li>input: putdown <code>x</code></li>
<li>output: LaTeX <code>x</code>, typeset $x$</li>
</ul>
</li>
<li>Test 2
<ul>
<li>input: putdown <code>U</code></li>
<li>output: LaTeX <code>U</code>, typeset $U$</li>
</ul>
</li>
<li>Test 3
<ul>
<li>input: putdown <code>Q</code></li>
<li>output: LaTeX <code>Q</code>, typeset $Q$</li>
</ul>
</li>
<li>Test 4
<ul>
<li>input: putdown <code>m</code></li>
<li>output: LaTeX <code>m</code>, typeset $m$</li>
</ul>
</li>
<li>Test 5
<ul>
<li>input: putdown <code>foo</code></li>
<li>output: LaTeX <code>null</code>, typeset $undefined$</li>
</ul>
</li>
<li>Test 6
<ul>
<li>input: putdown <code>Hi</code></li>
<li>output: LaTeX <code>null</code>, typeset $undefined$</li>
</ul>
</li>
</ul>
<h3>correctly converts numeric constants</h3>
<ul>
<li>Test 1
<ul>
<li>input: putdown <code>infinity</code></li>
<li>output: LaTeX <code>\infty</code>, typeset $\infty$</li>
</ul>
</li>
<li>Test 2
<ul>
<li>input: putdown <code>pi</code></li>
<li>output: LaTeX <code>\pi</code>, typeset $\pi$</li>
</ul>
</li>
<li>Test 3
<ul>
<li>input: putdown <code>eulersnumber</code></li>
<li>output: LaTeX <code>e</code>, typeset $e$</li>
</ul>
</li>
</ul>
<h3>correctly converts exponentiation of atomics</h3>
<ul>
<li>Test 1
<ul>
<li>input: putdown <code>(^ 1 2)</code></li>
<li>output: LaTeX <code>1^2</code>, typeset $1^2$</li>
</ul>
</li>
<li>Test 2
<ul>
<li>input: putdown <code>(^ e x)</code></li>
<li>output: LaTeX <code>e^x</code>, typeset $e^x$</li>
</ul>
</li>
<li>Test 3
<ul>
<li>input: putdown <code>(^ 1 infinity)</code></li>
<li>output: LaTeX <code>1^\infty</code>, typeset $1^\infty$</li>
</ul>
</li>
</ul>
<h3>correctly converts atomic percentages and factorials</h3>
<ul>
<li>Test 1
<ul>
<li>input: putdown <code>(% 10)</code></li>
<li>output: LaTeX <code>10\%</code>, typeset $10\%$</li>
</ul>
</li>
<li>Test 2
<ul>
<li>input: putdown <code>(% t)</code></li>
<li>output: LaTeX <code>t\%</code>, typeset $t\%$</li>
</ul>
</li>
<li>Test 3
<ul>
<li>input: putdown <code>(! 10)</code></li>
<li>output: LaTeX <code>10!</code>, typeset $10!$</li>
</ul>
</li>
<li>Test 4
<ul>
<li>input: putdown <code>(! t)</code></li>
<li>output: LaTeX <code>t!</code>, typeset $t!$</li>
</ul>
</li>
</ul>
<h3>correctly converts division of atomics or factors</h3>
<ul>
<li>Test 1
<ul>
<li>input: putdown <code>(/ 1 2)</code></li>
<li>output: LaTeX <code>1\div 2</code>, typeset $1\div 2$</li>
</ul>
</li>
<li>Test 2
<ul>
<li>input: putdown <code>(/ x y)</code></li>
<li>output: LaTeX <code>x\div y</code>, typeset $x\div y$</li>
</ul>
</li>
<li>Test 3
<ul>
<li>input: putdown <code>(/ 0 infinity)</code></li>
<li>output: LaTeX <code>0\div \infty</code>, typeset $0\div \infty$</li>
</ul>
</li>
<li>Test 4
<ul>
<li>input: putdown <code>(/ (^ x 2) 3)</code></li>
<li>output: LaTeX <code>x^2\div 3</code>, typeset $x^2\div 3$</li>
</ul>
</li>
<li>Test 5
<ul>
<li>input: putdown <code>(/ 1 (^ e x))</code></li>
<li>output: LaTeX <code>1\div e^x</code>, typeset $1\div e^x$</li>
</ul>
</li>
<li>Test 6
<ul>
<li>input: putdown <code>(/ (% 10) (^ 2 100))</code></li>
<li>output: LaTeX <code>10\%\div 2^100</code>, typeset $10\%\div 2^100$</li>
</ul>
</li>
</ul>
<h3>correctly converts multiplication of atomics or factors</h3>
<ul>
<li>Test 1
<ul>
<li>input: putdown <code>(* 1 2)</code></li>
<li>output: LaTeX <code>1\times 2</code>, typeset $1\times 2$</li>
</ul>
</li>
<li>Test 2
<ul>
<li>input: putdown <code>(* x y)</code></li>
<li>output: LaTeX <code>x\times y</code>, typeset $x\times y$</li>
</ul>
</li>
<li>Test 3
<ul>
<li>input: putdown <code>(* 0 infinity)</code></li>
<li>output: LaTeX <code>0\times \infty</code>, typeset $0\times \infty$</li>
</ul>
</li>
<li>Test 4
<ul>
<li>input: putdown <code>(* (^ x 2) 3)</code></li>
<li>output: LaTeX <code>x^2\times 3</code>, typeset $x^2\times 3$</li>
</ul>
</li>
<li>Test 5
<ul>
<li>input: putdown <code>(* 1 (^ e x))</code></li>
<li>output: LaTeX <code>1\times e^x</code>, typeset $1\times e^x$</li>
</ul>
</li>
<li>Test 6
<ul>
<li>input: putdown <code>(* (% 10) (^ 2 100))</code></li>
<li>output: LaTeX <code>10\%\times 2^100</code>, typeset $10\%\times 2^100$</li>
</ul>
</li>
</ul>
<h3>correctly converts negations of atomics or factors</h3>
<ul>
<li>Test 1
<ul>
<li>input: putdown <code>(* (- 1) 2)</code></li>
<li>output: LaTeX <code>-1\times 2</code>, typeset $-1\times 2$</li>
</ul>
</li>
<li>Test 2
<ul>
<li>input: putdown <code>(* x (- y))</code></li>
<li>output: LaTeX <code>x\times -y</code>, typeset $x\times -y$</li>
</ul>
</li>
<li>Test 3
<ul>
<li>input: putdown <code>(* (- (^ x 2)) (- 3))</code></li>
<li>output: LaTeX <code>-x^2\times -3</code>, typeset $-x^2\times -3$</li>
</ul>
</li>
<li>Test 4
<ul>
<li>input: putdown <code>(- (- (- (- 1000))))</code></li>
<li>output: LaTeX <code>----1000</code>, typeset $----1000$</li>
</ul>
</li>
</ul>
<h3>correctly converts additions and subtractions</h3>
<ul>
<li>Test 1
<ul>
<li>input: putdown <code>(+ x y)</code></li>
<li>output: LaTeX <code>x+y</code>, typeset $x+y$</li>
</ul>
</li>
<li>Test 2
<ul>
<li>input: putdown <code>(- 1 (- 3))</code></li>
<li>output: LaTeX <code>1--3</code>, typeset $1--3$</li>
</ul>
</li>
<li>Test 3
<ul>
<li>input: putdown <code>(+ (^ A B) (- C pi))</code></li>
<li>output: LaTeX <code>A^B+C-\pi</code>, typeset $A^B+C-\pi$</li>
</ul>
</li>
</ul>
<h3>correctly converts number expressions with groupers</h3>
<ul>
<li>Test 1
<ul>
<li>input: putdown <code>(- (* 1 2))</code></li>
<li>output: LaTeX <code>-1\times 2</code>, typeset $-1\times 2$</li>
</ul>
</li>
<li>Test 2
<ul>
<li>input: putdown <code>(! (^ x 2))</code></li>
<li>output: LaTeX <code>{x^2}!</code>, typeset ${x^2}!$</li>
</ul>
</li>
<li>Test 3
<ul>
<li>input: putdown <code>(^ (- x) (* 2 (- 3)))</code></li>
<li>output: LaTeX <code>{-x}^{2\times -3}</code>, typeset ${-x}^{2\times -3}$</li>
</ul>
</li>
<li>Test 4
<ul>
<li>input: putdown <code>(^ (- 3) (+ 1 2))</code></li>
<li>output: LaTeX <code>{-3}^{1+2}</code>, typeset ${-3}^{1+2}$</li>
</ul>
</li>
</ul>
<h3>can convert relations of numeric expressions</h3>
<ul>
<li>Test 1
<ul>
<li>input: putdown <code>(&gt; 1 2)</code></li>
<li>output: LaTeX <code>1&gt;2</code>, typeset $1&gt;2$</li>
</ul>
</li>
<li>Test 2
<ul>
<li>input: putdown <code>(&lt; (- 1 2) (+ 1 2))</code></li>
<li>output: LaTeX <code>1-2&lt;1+2</code>, typeset $1-2&lt;1+2$</li>
</ul>
</li>
<li>Test 3
<ul>
<li>input: putdown <code>(not (= 1 2))</code></li>
<li>output: LaTeX <code>\neg 1=2</code>, typeset $\neg 1=2$</li>
</ul>
</li>
<li>Test 4
<ul>
<li>input: putdown <code>(and (&gt;= 2 1) (&lt;= 2 3))</code></li>
<li>output: LaTeX <code>2\ge 1\wedge 2\le 3</code>, typeset $2\ge 1\wedge 2\le 3$</li>
</ul>
</li>
<li>Test 5
<ul>
<li>input: putdown <code>(relationholds | 7 14)</code></li>
<li>output: LaTeX <code>7 | 14</code>, typeset $7 | 14$</li>
</ul>
</li>
<li>Test 6
<ul>
<li>input: putdown <code>(relationholds | (apply A k) (! n))</code></li>
<li>output: LaTeX <code>A(k) | n!</code>, typeset $A(k) | n!$</li>
</ul>
</li>
<li>Test 7
<ul>
<li>input: putdown <code>(relationholds ~ (- 1 k) (+ 1 k))</code></li>
<li>output: LaTeX <code>1-k \sim 1+k</code>, typeset $1-k \sim 1+k$</li>
</ul>
</li>
<li>Test 8
<ul>
<li>input: putdown <code>(relationholds ~~ 0.99 1.01)</code></li>
<li>output: LaTeX <code>0.99 \approx 1.01</code>, typeset $0.99 \approx 1.01$</li>
</ul>
</li>
</ul>
<h3>does not undo the canonical form for inequality</h3>
<ul>
<li>Test 1
<ul>
<li>input: putdown <code>(not (= x y))</code></li>
<li>output: LaTeX <code>\neg x=y</code>, typeset $\neg x=y$</li>
</ul>
</li>
</ul>
<h3>correctly converts propositional logic atomics</h3>
<ul>
<li>Test 1
<ul>
<li>input: putdown <code>true</code></li>
<li>output: LaTeX <code>\top</code>, typeset $\top$</li>
</ul>
</li>
<li>Test 2
<ul>
<li>input: putdown <code>false</code></li>
<li>output: LaTeX <code>\bot</code>, typeset $\bot$</li>
</ul>
</li>
<li>Test 3
<ul>
<li>input: putdown <code>contradiction</code></li>
<li>output: LaTeX <code>\rightarrow \leftarrow</code>, typeset $\rightarrow \leftarrow$</li>
</ul>
</li>
</ul>
<h3>correctly converts propositional logic conjuncts</h3>
<ul>
<li>Test 1
<ul>
<li>input: putdown <code>(and true false)</code></li>
<li>output: LaTeX <code>\top\wedge \bot</code>, typeset $\top\wedge \bot$</li>
</ul>
</li>
<li>Test 2
<ul>
<li>input: putdown <code>(and (not P) (not true))</code></li>
<li>output: LaTeX <code>\neg P\wedge \neg \top</code>, typeset $\neg P\wedge \neg \top$</li>
</ul>
</li>
<li>Test 3
<ul>
<li>input: putdown <code>(and (and a b) c)</code></li>
<li>output: LaTeX <code>a\wedge b\wedge c</code>, typeset $a\wedge b\wedge c$</li>
</ul>
</li>
</ul>
<h3>correctly converts propositional logic disjuncts</h3>
<ul>
<li>Test 1
<ul>
<li>input: putdown <code>(or true (not A))</code></li>
<li>output: LaTeX <code>\top\vee \neg A</code>, typeset $\top\vee \neg A$</li>
</ul>
</li>
<li>Test 2
<ul>
<li>input: putdown <code>(or (and P Q) (and Q P))</code></li>
<li>output: LaTeX <code>P\wedge Q\vee Q\wedge P</code>, typeset $P\wedge Q\vee Q\wedge P$</li>
</ul>
</li>
</ul>
<h3>correctly converts propositional logic conditionals</h3>
<ul>
<li>Test 1
<ul>
<li>input: putdown <code>(implies A (and Q (not P)))</code></li>
<li>output: LaTeX <code>A\Rightarrow Q\wedge \neg P</code>, typeset $A\Rightarrow Q\wedge \neg P$</li>
</ul>
</li>
<li>Test 2
<ul>
<li>input: putdown <code>(implies (implies (or P Q) (and Q P)) T)</code></li>
<li>output: LaTeX <code>P\vee Q\Rightarrow Q\wedge P\Rightarrow T</code>, typeset $P\vee Q\Rightarrow Q\wedge P\Rightarrow T$</li>
</ul>
</li>
</ul>
<h3>correctly converts propositional logic biconditionals</h3>
<ul>
<li>Test 1
<ul>
<li>input: putdown <code>(iff A (and Q (not P)))</code></li>
<li>output: LaTeX <code>A\Leftrightarrow Q\wedge \neg P</code>, typeset $A\Leftrightarrow Q\wedge \neg P$</li>
</ul>
</li>
<li>Test 2
<ul>
<li>input: putdown <code>(implies (iff (or P Q) (and Q P)) T)</code></li>
<li>output: LaTeX <code>P\vee Q\Leftrightarrow Q\wedge P\Rightarrow T</code>, typeset $P\vee Q\Leftrightarrow Q\wedge P\Rightarrow T$</li>
</ul>
</li>
</ul>
<h3>correctly converts propositional expressions with groupers</h3>
<ul>
<li>Test 1
<ul>
<li>input: putdown <code>(or P (and (iff Q Q) P))</code></li>
<li>output: LaTeX <code>P\vee {Q\Leftrightarrow Q}\wedge P</code>, typeset $P\vee {Q\Leftrightarrow Q}\wedge P$</li>
</ul>
</li>
<li>Test 2
<ul>
<li>input: putdown <code>(not (iff true false))</code></li>
<li>output: LaTeX <code>\neg {\top\Leftrightarrow \bot}</code>, typeset $\neg {\top\Leftrightarrow \bot}$</li>
</ul>
</li>
</ul>
<h3>correctly converts simple predicate logic expressions</h3>
<ul>
<li>Test 1
<ul>
<li>input: putdown <code>(forall (x , P))</code></li>
<li>output: LaTeX <code>\forall x, P</code>, typeset $\forall x, P$</li>
</ul>
</li>
<li>Test 2
<ul>
<li>input: putdown <code>(exists (t , (not Q)))</code></li>
<li>output: LaTeX <code>\exists t, \neg Q</code>, typeset $\exists t, \neg Q$</li>
</ul>
</li>
<li>Test 3
<ul>
<li>input: putdown <code>(exists! (k , (implies m n)))</code></li>
<li>output: LaTeX <code>\exists ! k, m\Rightarrow n</code>, typeset $\exists ! k, m\Rightarrow n$</li>
</ul>
</li>
</ul>
<h3>can convert finite and empty sets</h3>
<ul>
<li>Test 1
<ul>
<li>input: putdown <code>emptyset</code></li>
<li>output: LaTeX <code>\emptyset</code>, typeset $\emptyset$</li>
</ul>
</li>
<li>Test 2
<ul>
<li>input: putdown <code>(finiteset (elts 1))</code></li>
<li>output: LaTeX <code>\{1\}</code>, typeset ${1}$</li>
</ul>
</li>
<li>Test 3
<ul>
<li>input: putdown <code>(finiteset (elts 1 (elts 2)))</code></li>
<li>output: LaTeX <code>\{1,2\}</code>, typeset ${1,2}$</li>
</ul>
</li>
<li>Test 4
<ul>
<li>input: putdown <code>(finiteset (elts 1 (elts 2 (elts 3))))</code></li>
<li>output: LaTeX <code>\{1,2,3\}</code>, typeset ${1,2,3}$</li>
</ul>
</li>
<li>Test 5
<ul>
<li>input: putdown <code>(finiteset (elts emptyset (elts emptyset)))</code></li>
<li>output: LaTeX <code>\{\emptyset,\emptyset\}</code>, typeset ${\emptyset,\emptyset}$</li>
</ul>
</li>
<li>Test 6
<ul>
<li>input: putdown <code>(finiteset (elts (finiteset (elts emptyset))))</code></li>
<li>output: LaTeX <code>\{\{\emptyset\}\}</code>, typeset ${{\emptyset}}$</li>
</ul>
</li>
<li>Test 7
<ul>
<li>input: putdown <code>(finiteset (elts 3 (elts x)))</code></li>
<li>output: LaTeX <code>\{3,x\}</code>, typeset ${3,x}$</li>
</ul>
</li>
<li>Test 8
<ul>
<li>input: putdown <code>(finiteset (elts (union A B) (elts (intersection A B))))</code></li>
<li>output: LaTeX <code>\{A\cup B,A\cap B\}</code>, typeset ${A\cup B,A\cap B}$</li>
</ul>
</li>
<li>Test 9
<ul>
<li>input: putdown <code>(finiteset (elts 1 (elts 2 (elts emptyset (elts K (elts P))))))</code></li>
<li>output: LaTeX <code>\{1,2,\emptyset,K,P\}</code>, typeset ${1,2,\emptyset,K,P}$</li>
</ul>
</li>
</ul>
<h3>correctly converts tuples and vectors</h3>
<ul>
<li>Test 1
<ul>
<li>input: putdown <code>(tuple (elts 5 (elts 6)))</code></li>
<li>output: LaTeX <code>(5,6)</code>, typeset $(5,6)$</li>
</ul>
</li>
<li>Test 2
<ul>
<li>input: putdown <code>(tuple (elts 5 (elts (union A B) (elts k))))</code></li>
<li>output: LaTeX <code>(5,A\cup B,k)</code>, typeset $(5,A\cup B,k)$</li>
</ul>
</li>
<li>Test 3
<ul>
<li>input: putdown <code>(vector (elts 5 (elts 6)))</code></li>
<li>output: LaTeX <code>\langle 5,6\rangle</code>, typeset $\langle 5,6\rangle$</li>
</ul>
</li>
<li>Test 4
<ul>
<li>input: putdown <code>(vector (elts 5 (elts (- 7) (elts k))))</code></li>
<li>output: LaTeX <code>\langle 5,-7,k\rangle</code>, typeset $\langle 5,-7,k\rangle$</li>
</ul>
</li>
<li>Test 5
<ul>
<li>input: putdown <code>(tuple)</code></li>
<li>output: LaTeX <code>null</code>, typeset $undefined$</li>
</ul>
</li>
<li>Test 6
<ul>
<li>input: putdown <code>(tuple (elts))</code></li>
<li>output: LaTeX <code>null</code>, typeset $undefined$</li>
</ul>
</li>
<li>Test 7
<ul>
<li>input: putdown <code>(tuple (elts 3))</code></li>
<li>output: LaTeX <code>null</code>, typeset $undefined$</li>
</ul>
</li>
<li>Test 8
<ul>
<li>input: putdown <code>(vector)</code></li>
<li>output: LaTeX <code>null</code>, typeset $undefined$</li>
</ul>
</li>
<li>Test 9
<ul>
<li>input: putdown <code>(vector (elts))</code></li>
<li>output: LaTeX <code>null</code>, typeset $undefined$</li>
</ul>
</li>
<li>Test 10
<ul>
<li>input: putdown <code>(vector (elts 3))</code></li>
<li>output: LaTeX <code>null</code>, typeset $undefined$</li>
</ul>
</li>
<li>Test 11
<ul>
<li>input: putdown <code>(tuple (elts (tuple (elts 1 (elts 2))) (elts 6)))</code></li>
<li>output: LaTeX <code>((1,2),6)</code>, typeset $((1,2),6)$</li>
</ul>
</li>
<li>Test 12
<ul>
<li>input: putdown <code>(vector (elts (tuple (elts 1 (elts 2))) (elts 6)))</code></li>
<li>output: LaTeX <code>null</code>, typeset $undefined$</li>
</ul>
</li>
<li>Test 13
<ul>
<li>input: putdown <code>(vector (elts (vector (elts 1 (elts 2))) (elts 6)))</code></li>
<li>output: LaTeX <code>null</code>, typeset $undefined$</li>
</ul>
</li>
<li>Test 14
<ul>
<li>input: putdown <code>(vector (elts (union A B) (elts 6)))</code></li>
<li>output: LaTeX <code>null</code>, typeset $undefined$</li>
</ul>
</li>
</ul>
<h3>can convert simple set memberships and subsets</h3>
<ul>
<li>Test 1
<ul>
<li>input: putdown <code>(in b B)</code></li>
<li>output: LaTeX <code>b\in B</code>, typeset $b\in B$</li>
</ul>
</li>
<li>Test 2
<ul>
<li>input: putdown <code>(in 2 (finiteset (elts 1 (elts 2))))</code></li>
<li>output: LaTeX <code>2\in \{1,2\}</code>, typeset $2\in {1,2}$</li>
</ul>
</li>
<li>Test 3
<ul>
<li>input: putdown <code>(in X (union a b))</code></li>
<li>output: LaTeX <code>X\in a\cup b</code>, typeset $X\in a\cup b$</li>
</ul>
</li>
<li>Test 4
<ul>
<li>input: putdown <code>(in (union A B) (union X Y))</code></li>
<li>output: LaTeX <code>A\cup B\in X\cup Y</code>, typeset $A\cup B\in X\cup Y$</li>
</ul>
</li>
<li>Test 5
<ul>
<li>input: putdown <code>(subset A (complement B))</code></li>
<li>output: LaTeX <code>A\subset \bar B</code>, typeset $A\subset \bar B$</li>
</ul>
</li>
<li>Test 6
<ul>
<li>input: putdown <code>(subseteq (intersection u v) (union u v))</code></li>
<li>output: LaTeX <code>u\cap v\subseteq u\cup v</code>, typeset $u\cap v\subseteq u\cup v$</li>
</ul>
</li>
<li>Test 7
<ul>
<li>input: putdown <code>(subseteq (finiteset (elts 1)) (union (finiteset (elts 1)) (finiteset (elts 2))))</code></li>
<li>output: LaTeX <code>\{1\}\subseteq \{1\}\cup \{2\}</code>, typeset ${1}\subseteq {1}\cup {2}$</li>
</ul>
</li>
<li>Test 8
<ul>
<li>input: putdown <code>(in p (cartesianproduct U V))</code></li>
<li>output: LaTeX <code>p\in U\times V</code>, typeset $p\in U\times V$</li>
</ul>
</li>
<li>Test 9
<ul>
<li>input: putdown <code>(in q (union (complement U) (cartesianproduct V W)))</code></li>
<li>output: LaTeX <code>q\in \bar U\cup V\times W</code>, typeset $q\in \bar U\cup V\times W$</li>
</ul>
</li>
<li>Test 10
<ul>
<li>input: putdown <code>(in (tuple (elts a (elts b))) (cartesianproduct A B))</code></li>
<li>output: LaTeX <code>(a,b)\in A\times B</code>, typeset $(a,b)\in A\times B$</li>
</ul>
</li>
<li>Test 11
<ul>
<li>input: putdown <code>(in (vector (elts a (elts b))) (cartesianproduct A B))</code></li>
<li>output: LaTeX <code>\langle a,b\rangle\in A\times B</code>, typeset $\langle a,b\rangle\in A\times B$</li>
</ul>
</li>
</ul>
<h3>does not undo the canonical form for &quot;notin&quot; notation</h3>
<ul>
<li>Test 1
<ul>
<li>input: putdown <code>(not (in a A))</code></li>
<li>output: LaTeX <code>\neg a\in A</code>, typeset $\neg a\in A$</li>
</ul>
</li>
<li>Test 2
<ul>
<li>input: putdown <code>(not (in emptyset emptyset))</code></li>
<li>output: LaTeX <code>\neg \emptyset\in \emptyset</code>, typeset $\neg \emptyset\in \emptyset$</li>
</ul>
</li>
<li>Test 3
<ul>
<li>input: putdown <code>(not (in (- 3 5) (intersection K P)))</code></li>
<li>output: LaTeX <code>\neg 3-5\in K\cap P</code>, typeset $\neg 3-5\in K\cap P$</li>
</ul>
</li>
</ul>
<h3>can convert sentences built from set operators</h3>
<ul>
<li>Test 1
<ul>
<li>input: putdown <code>(or P (in b B))</code></li>
<li>output: LaTeX <code>P\vee b\in B</code>, typeset $P\vee b\in B$</li>
</ul>
</li>
<li>Test 2
<ul>
<li>input: putdown <code>(in (or P b) B)</code></li>
<li>output: LaTeX <code>{P\vee b}\in B</code>, typeset ${P\vee b}\in B$</li>
</ul>
</li>
<li>Test 3
<ul>
<li>input: putdown <code>(forall (x , (in x X)))</code></li>
<li>output: LaTeX <code>\forall x, x\in X</code>, typeset $\forall x, x\in X$</li>
</ul>
</li>
<li>Test 4
<ul>
<li>input: putdown <code>(and (subseteq A B) (subseteq B A))</code></li>
<li>output: LaTeX <code>A\subseteq B\wedge B\subseteq A</code>, typeset $A\subseteq B\wedge B\subseteq A$</li>
</ul>
</li>
<li>Test 5
<ul>
<li>input: putdown <code>(= R (cartesianproduct A B))</code></li>
<li>output: LaTeX <code>R=A\times B</code>, typeset $R=A\times B$</li>
</ul>
</li>
<li>Test 6
<ul>
<li>input: putdown <code>(forall (n , (relationholds | n (! n))))</code></li>
<li>output: LaTeX <code>\forall n, n | n!</code>, typeset $\forall n, n | n!$</li>
</ul>
</li>
<li>Test 7
<ul>
<li>input: putdown <code>(implies (relationholds ~ a b) (relationholds ~ b a))</code></li>
<li>output: LaTeX <code>a \sim b\Rightarrow b \sim a</code>, typeset $a \sim b\Rightarrow b \sim a$</li>
</ul>
</li>
</ul>
<h3>can convert notation related to functions</h3>
<ul>
<li>Test 1
<ul>
<li>input: putdown <code>(function f A B)</code></li>
<li>output: LaTeX <code>f:A\to B</code>, typeset $f:A\to B$</li>
</ul>
</li>
<li>Test 2
<ul>
<li>input: putdown <code>(not (function F (union X Y) Z))</code></li>
<li>output: LaTeX <code>\neg F:X\cup Y\to Z</code>, typeset $\neg F:X\cup Y\to Z$</li>
</ul>
</li>
<li>Test 3
<ul>
<li>input: putdown <code>(function (compose f g) A C)</code></li>
<li>output: LaTeX <code>f\circ g:A\to C</code>, typeset $f\circ g:A\to C$</li>
</ul>
</li>
<li>Test 4
<ul>
<li>input: putdown <code>(apply f x)</code></li>
<li>output: LaTeX <code>f(x)</code>, typeset $f(x)$</li>
</ul>
</li>
<li>Test 5
<ul>
<li>input: putdown <code>(apply (inverse f) (apply (inverse g) 10))</code></li>
<li>output: LaTeX <code>f ^ { - 1 }(g ^ { - 1 }(10))</code>, typeset $f ^ { - 1 }(g ^ { - 1 }(10))$</li>
</ul>
</li>
<li>Test 6
<ul>
<li>input: putdown <code>(apply E (complement L))</code></li>
<li>output: LaTeX <code>E(\bar L)</code>, typeset $E(\bar L)$</li>
</ul>
</li>
<li>Test 7
<ul>
<li>input: putdown <code>(intersection emptyset (apply f 2))</code></li>
<li>output: LaTeX <code>\emptyset\cap f(2)</code>, typeset $\emptyset\cap f(2)$</li>
</ul>
</li>
<li>Test 8
<ul>
<li>input: putdown <code>(and (apply P e) (apply Q (+ 3 b)))</code></li>
<li>output: LaTeX <code>P(e)\wedge Q(3+b)</code>, typeset $P(e)\wedge Q(3+b)$</li>
</ul>
</li>
<li>Test 9
<ul>
<li>input: putdown <code>(= F (compose G (inverse H)))</code></li>
<li>output: LaTeX <code>F=G\circ H ^ { - 1 }</code>, typeset $F=G\circ H ^ { - 1 }$</li>
</ul>
</li>
</ul>
<h3>can convert expressions with trigonometric functions</h3>
<ul>
<li>Test 1
<ul>
<li>input: putdown <code>(apply sin x)</code></li>
<li>output: LaTeX <code>\sin x</code>, typeset $\sin x$</li>
</ul>
</li>
<li>Test 2
<ul>
<li>input: putdown <code>(apply cos (* pi x))</code></li>
<li>output: LaTeX <code>\cos \pi\times x</code>, typeset $\cos \pi\times x$</li>
</ul>
</li>
<li>Test 3
<ul>
<li>input: putdown <code>(apply tan t)</code></li>
<li>output: LaTeX <code>\tan t</code>, typeset $\tan t$</li>
</ul>
</li>
<li>Test 4
<ul>
<li>input: putdown <code>(/ 1 (apply cot pi))</code></li>
<li>output: LaTeX <code>1\div \cot \pi</code>, typeset $1\div \cot \pi$</li>
</ul>
</li>
<li>Test 5
<ul>
<li>input: putdown <code>(= (apply sec y) (apply csc y))</code></li>
<li>output: LaTeX <code>\sec y=\csc y</code>, typeset $\sec y=\csc y$</li>
</ul>
</li>
</ul>
<h3>can convert expressions with logarithms</h3>
<ul>
<li>Test 1
<ul>
<li>input: putdown <code>(apply log n)</code></li>
<li>output: LaTeX <code>\log n</code>, typeset $\log n$</li>
</ul>
</li>
<li>Test 2
<ul>
<li>input: putdown <code>(+ 1 (apply ln x))</code></li>
<li>output: LaTeX <code>1+\ln x</code>, typeset $1+\ln x$</li>
</ul>
</li>
<li>Test 3
<ul>
<li>input: putdown <code>(apply (logbase 2) 1024)</code></li>
<li>output: LaTeX <code>\log_2 1024</code>, typeset $\log_2 1024$</li>
</ul>
</li>
<li>Test 4
<ul>
<li>input: putdown <code>(/ (apply log n) (apply log (apply log n)))</code></li>
<li>output: LaTeX <code>\log n\div \log \log n</code>, typeset $\log n\div \log \log n$</li>
</ul>
</li>
</ul>
<h3>can convert equivalence classes and expressions that use them</h3>
<ul>
<li>Test 1
<ul>
<li>input: putdown <code>(equivclass 1 ~~)</code></li>
<li>output: LaTeX <code>[1,\approx]</code>, typeset $[1,\approx]$</li>
</ul>
</li>
<li>Test 2
<ul>
<li>input: putdown <code>(equivclass (+ x 2) ~)</code></li>
<li>output: LaTeX <code>[x+2,\sim]</code>, typeset $[x+2,\sim]$</li>
</ul>
</li>
<li>Test 3
<ul>
<li>input: putdown <code>(union (equivclass 1 ~~) (equivclass 2 ~~))</code></li>
<li>output: LaTeX <code>[1,\approx]\cup [2,\approx]</code>, typeset $[1,\approx]\cup [2,\approx]$</li>
</ul>
</li>
<li>Test 4
<ul>
<li>input: putdown <code>(in 7 (equivclass 7 ~))</code></li>
<li>output: LaTeX <code>7\in [7,\sim]</code>, typeset $7\in [7,\sim]$</li>
</ul>
</li>
</ul>
<h3>can convert equivalence and classes mod a number</h3>
<ul>
<li>Test 1
<ul>
<li>input: putdown <code>(=mod 5 11 3)</code></li>
<li>output: LaTeX <code>5 \equiv 11 \mod 3</code>, typeset $5 \equiv 11 \mod 3$</li>
</ul>
</li>
<li>Test 2
<ul>
<li>input: putdown <code>(=mod k m n)</code></li>
<li>output: LaTeX <code>k \equiv m \mod n</code>, typeset $k \equiv m \mod n$</li>
</ul>
</li>
<li>Test 3
<ul>
<li>input: putdown <code>(subset emptyset (modclass (- 1) 10))</code></li>
<li>output: LaTeX <code>\emptyset\subset [-1, \equiv _ 10]</code>, typeset $\emptyset\subset [-1, \equiv _ 10]$</li>
</ul>
</li>
</ul>
<h3>can convert type sentences and combinations of them</h3>
<ul>
<li>Test 1
<ul>
<li>input: putdown <code>(hastype x settype)</code></li>
<li>output: LaTeX <code>x \text{is a set}</code>, typeset $x \text{is a set}$</li>
</ul>
</li>
<li>Test 2
<ul>
<li>input: putdown <code>(hastype n numbertype)</code></li>
<li>output: LaTeX <code>n \text{is a number}</code>, typeset $n \text{is a number}$</li>
</ul>
</li>
<li>Test 3
<ul>
<li>input: putdown <code>(hastype S partialordertype)</code></li>
<li>output: LaTeX <code>S \text{is a partial order}</code>, typeset $S \text{is a partial order}$</li>
</ul>
</li>
<li>Test 4
<ul>
<li>input: putdown <code>(and (hastype 1 numbertype) (hastype 10 numbertype))</code></li>
<li>output: LaTeX <code>1 \text{is a number}\wedge 10 \text{is a number}</code>, typeset $1 \text{is a number}\wedge 10 \text{is a number}$</li>
</ul>
</li>
<li>Test 5
<ul>
<li>input: putdown <code>(implies (hastype R equivalencerelationtype) (hastype R relationtype))</code></li>
<li>output: LaTeX <code>R \text{is an equivalence relation}\Rightarrow R \text{is a relation}</code>, typeset $R \text{is an equivalence relation}\Rightarrow R \text{is a relation}$</li>
</ul>
</li>
</ul>
<h3>can convert notation for expression function application</h3>
<ul>
<li>Test 1
<ul>
<li>input: putdown <code>(efa f x)</code></li>
<li>output: LaTeX <code>\mathcal{f} (x)</code>, typeset $\mathcal{f} (x)$</li>
</ul>
</li>
<li>Test 2
<ul>
<li>input: putdown <code>(apply F (efa k 10))</code></li>
<li>output: LaTeX <code>F(\mathcal{k} (10))</code>, typeset $F(\mathcal{k} (10))$</li>
</ul>
</li>
<li>Test 3
<ul>
<li>input: putdown <code>(efa E (complement L))</code></li>
<li>output: LaTeX <code>\mathcal{E} (\bar L)</code>, typeset $\mathcal{E} (\bar L)$</li>
</ul>
</li>
<li>Test 4
<ul>
<li>input: putdown <code>(intersection emptyset (efa f 2))</code></li>
<li>output: LaTeX <code>\emptyset\cap \mathcal{f} (2)</code>, typeset $\emptyset\cap \mathcal{f} (2)$</li>
</ul>
</li>
<li>Test 5
<ul>
<li>input: putdown <code>(and (efa P x) (efa Q y))</code></li>
<li>output: LaTeX <code>\mathcal{P} (x)\wedge \mathcal{Q} (y)</code>, typeset $\mathcal{P} (x)\wedge \mathcal{Q} (y)$</li>
</ul>
</li>
</ul>
<h3>can convert notation for assumptions</h3>
<ul>
<li>Test 1
<ul>
<li>input: putdown <code>:X</code></li>
<li>output: LaTeX <code>\text{Assume }X</code>, typeset $\text{Assume }X$</li>
</ul>
</li>
<li>Test 2
<ul>
<li>input: putdown <code>:(= k 1000)</code></li>
<li>output: LaTeX <code>\text{Assume }k=1000</code>, typeset $\text{Assume }k=1000$</li>
</ul>
</li>
<li>Test 3
<ul>
<li>input: putdown <code>:true</code></li>
<li>output: LaTeX <code>\text{Assume }\top</code>, typeset $\text{Assume }\top$</li>
</ul>
</li>
<li>Test 4
<ul>
<li>input: putdown <code>:50</code></li>
<li>output: LaTeX <code>null</code>, typeset $undefined$</li>
</ul>
</li>
<li>Test 5
<ul>
<li>input: putdown <code>:(tuple (elts 5 (elts 6)))</code></li>
<li>output: LaTeX <code>null</code>, typeset $undefined$</li>
</ul>
</li>
<li>Test 6
<ul>
<li>input: putdown <code>:(compose f g)</code></li>
<li>output: LaTeX <code>null</code>, typeset $undefined$</li>
</ul>
</li>
<li>Test 7
<ul>
<li>input: putdown <code>:emptyset</code></li>
<li>output: LaTeX <code>null</code>, typeset $undefined$</li>
</ul>
</li>
<li>Test 8
<ul>
<li>input: putdown <code>:infinity</code></li>
<li>output: LaTeX <code>null</code>, typeset $undefined$</li>
</ul>
</li>
</ul>
<h3>can convert notation for Let-style declarations</h3>
<ul>
<li>Test 1
<ul>
<li>input: putdown <code>:[x]</code></li>
<li>output: LaTeX <code>\text{Let }x</code>, typeset $\text{Let }x$</li>
</ul>
</li>
<li>Test 2
<ul>
<li>input: putdown <code>:[T]</code></li>
<li>output: LaTeX <code>\text{Let }T</code>, typeset $\text{Let }T$</li>
</ul>
</li>
<li>Test 3
<ul>
<li>input: putdown <code>:[x , (&gt; x 0)]</code></li>
<li>output: LaTeX <code>\text{Let }x \text{ be such that }x&gt;0</code>, typeset $\text{Let }x \text{ be such that }x&gt;0$</li>
</ul>
</li>
<li>Test 4
<ul>
<li>input: putdown <code>:[T , (or (= T 5) (in T S))]</code></li>
<li>output: LaTeX <code>\text{Let }T \text{ be such that }T=5\vee T\in S</code>, typeset $\text{Let }T \text{ be such that }T=5\vee T\in S$</li>
</ul>
</li>
<li>Test 5
<ul>
<li>input: putdown <code>:[(&gt; x 5)]</code></li>
<li>output: LaTeX <code>null</code>, typeset $undefined$</li>
</ul>
</li>
<li>Test 6
<ul>
<li>input: putdown <code>:[(= 1 1)]</code></li>
<li>output: LaTeX <code>null</code>, typeset $undefined$</li>
</ul>
</li>
<li>Test 7
<ul>
<li>input: putdown <code>:[emptyset]</code></li>
<li>output: LaTeX <code>null</code>, typeset $undefined$</li>
</ul>
</li>
<li>Test 8
<ul>
<li>input: putdown <code>:[x , 1]</code></li>
<li>output: LaTeX <code>null</code>, typeset $undefined$</li>
</ul>
</li>
<li>Test 9
<ul>
<li>input: putdown <code>:[x , (or 1 2)]</code></li>
<li>output: LaTeX <code>null</code>, typeset $undefined$</li>
</ul>
</li>
<li>Test 10
<ul>
<li>input: putdown <code>:[x , [y]]</code></li>
<li>output: LaTeX <code>null</code>, typeset $undefined$</li>
</ul>
</li>
<li>Test 11
<ul>
<li>input: putdown <code>:[x , :B]</code></li>
<li>output: LaTeX <code>null</code>, typeset $undefined$</li>
</ul>
</li>
</ul>
<h3>can convert notation for For Some-style declarations</h3>
<ul>
<li>Test 1
<ul>
<li>input: putdown <code>[x , (&gt; x 0)]</code></li>
<li>output: LaTeX <code>\text{For some }x, x&gt;0</code>, typeset $\text{For some }x, x&gt;0$</li>
</ul>
</li>
<li>Test 2
<ul>
<li>input: putdown <code>[T , (or (= T 5) (in T S))]</code></li>
<li>output: LaTeX <code>\text{For some }T, T=5\vee T\in S</code>, typeset $\text{For some }T, T=5\vee T\in S$</li>
</ul>
</li>
<li>Test 3
<ul>
<li>input: putdown <code>[x]</code></li>
<li>output: LaTeX <code>null</code>, typeset $undefined$</li>
</ul>
</li>
<li>Test 4
<ul>
<li>input: putdown <code>[T]</code></li>
<li>output: LaTeX <code>null</code>, typeset $undefined$</li>
</ul>
</li>
<li>Test 5
<ul>
<li>input: putdown <code>[(&gt; x 5)]</code></li>
<li>output: LaTeX <code>null</code>, typeset $undefined$</li>
</ul>
</li>
<li>Test 6
<ul>
<li>input: putdown <code>[(= 1 1)]</code></li>
<li>output: LaTeX <code>null</code>, typeset $undefined$</li>
</ul>
</li>
<li>Test 7
<ul>
<li>input: putdown <code>[emptyset]</code></li>
<li>output: LaTeX <code>null</code>, typeset $undefined$</li>
</ul>
</li>
<li>Test 8
<ul>
<li>input: putdown <code>[x , 1]</code></li>
<li>output: LaTeX <code>null</code>, typeset $undefined$</li>
</ul>
</li>
<li>Test 9
<ul>
<li>input: putdown <code>[x , (or 1 2)]</code></li>
<li>output: LaTeX <code>null</code>, typeset $undefined$</li>
</ul>
</li>
<li>Test 10
<ul>
<li>input: putdown <code>[x , [y]]</code></li>
<li>output: LaTeX <code>null</code>, typeset $undefined$</li>
</ul>
</li>
<li>Test 11
<ul>
<li>input: putdown <code>[x , :B]</code></li>
<li>output: LaTeX <code>null</code>, typeset $undefined$</li>
</ul>
</li>
</ul>
<h2><a name="Converting-LaTeX-to-putdown">Converting LaTeX to putdown</a></h2>
<h3>correctly converts many kinds of numbers but not malformed ones</h3>
<ul>
<li>Test 1
<ul>
<li>input: LaTeX <code>0</code>, typeset $0$</li>
<li>output: putdown <code>0</code></li>
</ul>
</li>
<li>Test 2
<ul>
<li>input: LaTeX <code>328975289</code>, typeset $328975289$</li>
<li>output: putdown <code>328975289</code></li>
</ul>
</li>
<li>Test 3
<ul>
<li>input: LaTeX <code>-9097285323</code>, typeset $-9097285323$</li>
<li>output: putdown <code>(- 9097285323)</code></li>
</ul>
</li>
<li>Test 4
<ul>
<li>input: LaTeX <code>0.0</code>, typeset $0.0$</li>
<li>output: putdown <code>0.0</code></li>
</ul>
</li>
<li>Test 5
<ul>
<li>input: LaTeX <code>32897.5289</code>, typeset $32897.5289$</li>
<li>output: putdown <code>32897.5289</code></li>
</ul>
</li>
<li>Test 6
<ul>
<li>input: LaTeX <code>-1.9097285323</code>, typeset $-1.9097285323$</li>
<li>output: putdown <code>(- 1.9097285323)</code></li>
</ul>
</li>
<li>Test 7
<ul>
<li>input: LaTeX <code>0.0.0</code>, typeset $0.0.0$</li>
<li>output: putdown <code>null</code></li>
</ul>
</li>
<li>Test 8
<ul>
<li>input: LaTeX <code>0k0</code>, typeset $0k0$</li>
<li>output: putdown <code>null</code></li>
</ul>
</li>
</ul>
<h3>correctly converts one-letter variable names but not larger ones</h3>
<ul>
<li>Test 1
<ul>
<li>input: LaTeX <code>x</code>, typeset $x$</li>
<li>output: putdown <code>x</code></li>
</ul>
</li>
<li>Test 2
<ul>
<li>input: LaTeX <code>U</code>, typeset $U$</li>
<li>output: putdown <code>U</code></li>
</ul>
</li>
<li>Test 3
<ul>
<li>input: LaTeX <code>Q</code>, typeset $Q$</li>
<li>output: putdown <code>Q</code></li>
</ul>
</li>
<li>Test 4
<ul>
<li>input: LaTeX <code>m</code>, typeset $m$</li>
<li>output: putdown <code>m</code></li>
</ul>
</li>
<li>Test 5
<ul>
<li>input: LaTeX <code>foo</code>, typeset $foo$</li>
<li>output: putdown <code>null</code></li>
</ul>
</li>
<li>Test 6
<ul>
<li>input: LaTeX <code>Hi</code>, typeset $Hi$</li>
<li>output: putdown <code>null</code></li>
</ul>
</li>
</ul>
<h3>correctly converts numeric constants</h3>
<ul>
<li>Test 1
<ul>
<li>input: LaTeX <code>\infty</code>, typeset $\infty$</li>
<li>output: putdown <code>infinity</code></li>
</ul>
</li>
<li>Test 2
<ul>
<li>input: LaTeX <code>\pi</code>, typeset $\pi$</li>
<li>output: putdown <code>pi</code></li>
</ul>
</li>
<li>Test 3
<ul>
<li>input: LaTeX <code>e</code>, typeset $e$</li>
<li>output: putdown <code>e</code></li>
</ul>
</li>
</ul>
<h3>correctly converts exponentiation of atomics</h3>
<ul>
<li>Test 1
<ul>
<li>input: LaTeX <code>1^2</code>, typeset $1^2$</li>
<li>output: putdown <code>(^ 1 2)</code></li>
</ul>
</li>
<li>Test 2
<ul>
<li>input: LaTeX <code>e^x</code>, typeset $e^x$</li>
<li>output: putdown <code>(^ eulersnumber x)</code></li>
</ul>
</li>
<li>Test 3
<ul>
<li>input: LaTeX <code>1^\infty</code>, typeset $1^\infty$</li>
<li>output: putdown <code>(^ 1 infinity)</code></li>
</ul>
</li>
</ul>
<h3>correctly converts atomic percentages</h3>
<ul>
<li>Test 1
<ul>
<li>input: LaTeX <code>10\%</code>, typeset $10\%$</li>
<li>output: putdown <code>(% 10)</code></li>
</ul>
</li>
<li>Test 2
<ul>
<li>input: LaTeX <code>t\%</code>, typeset $t\%$</li>
<li>output: putdown <code>(% t)</code></li>
</ul>
</li>
<li>Test 3
<ul>
<li>input: LaTeX <code>10!</code>, typeset $10!$</li>
<li>output: putdown <code>(! 10)</code></li>
</ul>
</li>
<li>Test 4
<ul>
<li>input: LaTeX <code>t!</code>, typeset $t!$</li>
<li>output: putdown <code>(! t)</code></li>
</ul>
</li>
</ul>
<h3>correctly converts division of atomics or factors</h3>
<ul>
<li>Test 1
<ul>
<li>input: LaTeX <code>1\div2</code>, typeset $1\div2$</li>
<li>output: putdown <code>(/ 1 2)</code></li>
</ul>
</li>
<li>Test 2
<ul>
<li>input: LaTeX <code>x\div y</code>, typeset $x\div y$</li>
<li>output: putdown <code>(/ x y)</code></li>
</ul>
</li>
<li>Test 3
<ul>
<li>input: LaTeX <code>0\div\infty</code>, typeset $0\div\infty$</li>
<li>output: putdown <code>(/ 0 infinity)</code></li>
</ul>
</li>
<li>Test 4
<ul>
<li>input: LaTeX <code>x^2\div3</code>, typeset $x^2\div3$</li>
<li>output: putdown <code>(/ (^ x 2) 3)</code></li>
</ul>
</li>
<li>Test 5
<ul>
<li>input: LaTeX <code>1\div e^x</code>, typeset $1\div e^x$</li>
<li>output: putdown <code>(/ 1 (^ eulersnumber x))</code></li>
</ul>
</li>
<li>Test 6
<ul>
<li>input: LaTeX <code>10\%\div2^{100}</code>, typeset $10\%\div2^{100}$</li>
<li>output: putdown <code>(/ (% 10) (^ 2 100))</code></li>
</ul>
</li>
</ul>
<h3>correctly converts multiplication of atomics or factors</h3>
<ul>
<li>Test 1
<ul>
<li>input: LaTeX <code>1\times2</code>, typeset $1\times2$</li>
<li>output: putdown <code>(* 1 2)</code></li>
</ul>
</li>
<li>Test 2
<ul>
<li>input: LaTeX <code>x\cdot y</code>, typeset $x\cdot y$</li>
<li>output: putdown <code>(* x y)</code></li>
</ul>
</li>
<li>Test 3
<ul>
<li>input: LaTeX <code>0\times\infty</code>, typeset $0\times\infty$</li>
<li>output: putdown <code>(* 0 infinity)</code></li>
</ul>
</li>
<li>Test 4
<ul>
<li>input: LaTeX <code>x^2\cdot3</code>, typeset $x^2\cdot3$</li>
<li>output: putdown <code>(* (^ x 2) 3)</code></li>
</ul>
</li>
<li>Test 5
<ul>
<li>input: LaTeX <code>1\times e^x</code>, typeset $1\times e^x$</li>
<li>output: putdown <code>(* 1 (^ eulersnumber x))</code></li>
</ul>
</li>
<li>Test 6
<ul>
<li>input: LaTeX <code>10\%\cdot2^{100}</code>, typeset $10\%\cdot2^{100}$</li>
<li>output: putdown <code>(* (% 10) (^ 2 100))</code></li>
</ul>
</li>
</ul>
<h3>correctly converts negations of atomics or factors</h3>
<ul>
<li>Test 1
<ul>
<li>input: LaTeX <code>-1\times2</code>, typeset $-1\times2$</li>
<li>output: putdown <code>(* (- 1) 2)</code></li>
</ul>
</li>
<li>Test 2
<ul>
<li>input: LaTeX <code>x\cdot{-y}</code>, typeset $x\cdot{-y}$</li>
<li>output: putdown <code>(* x (- y))</code></li>
</ul>
</li>
<li>Test 3
<ul>
<li>input: LaTeX <code>x\cdot(-y)</code>, typeset $x\cdot(-y)$</li>
<li>output: putdown <code>(* x (- y))</code></li>
</ul>
</li>
<li>Test 4
<ul>
<li>input: LaTeX <code>{-x^2}\cdot{-3}</code>, typeset ${-x^2}\cdot{-3}$</li>
<li>output: putdown <code>(* (- (^ x 2)) (- 3))</code></li>
</ul>
</li>
<li>Test 5
<ul>
<li>input: LaTeX <code>(-x^2)\cdot(-3)</code>, typeset $(-x^2)\cdot(-3)$</li>
<li>output: putdown <code>(* (- (^ x 2)) (- 3))</code></li>
</ul>
</li>
<li>Test 6
<ul>
<li>input: LaTeX <code>----1000</code>, typeset $----1000$</li>
<li>output: putdown <code>(- (- (- (- 1000))))</code></li>
</ul>
</li>
</ul>
<h3>correctly converts additions and subtractions</h3>
<ul>
<li>Test 1
<ul>
<li>input: LaTeX <code>x + y</code>, typeset $x + y$</li>
<li>output: putdown <code>(+ x y)</code></li>
</ul>
</li>
<li>Test 2
<ul>
<li>input: LaTeX <code>1 - - 3</code>, typeset $1 - - 3$</li>
<li>output: putdown <code>(- 1 (- 3))</code></li>
</ul>
</li>
<li>Test 3
<ul>
<li>input: LaTeX <code>A ^ B + C - \pi</code>, typeset $A ^ B + C - \pi$</li>
<li>output: putdown <code>(+ (^ A B) (- C pi))</code></li>
</ul>
</li>
</ul>
<h3>correctly converts number expressions with groupers</h3>
<ul>
<li>Test 1
<ul>
<li>input: LaTeX <code>-{1\times2}</code>, typeset $-{1\times2}$</li>
<li>output: putdown <code>(- (* 1 2))</code></li>
</ul>
</li>
<li>Test 2
<ul>
<li>input: LaTeX <code>-(1\times2)</code>, typeset $-(1\times2)$</li>
<li>output: putdown <code>(- (* 1 2))</code></li>
</ul>
</li>
<li>Test 3
<ul>
<li>input: LaTeX <code>{x^2}!</code>, typeset ${x^2}!$</li>
<li>output: putdown <code>(! (^ x 2))</code></li>
</ul>
</li>
<li>Test 4
<ul>
<li>input: LaTeX <code>(N-1)!</code>, typeset $(N-1)!$</li>
<li>output: putdown <code>(! (- N 1))</code></li>
</ul>
</li>
<li>Test 5
<ul>
<li>input: LaTeX <code>\left(N-1\right)!</code>, typeset $\left(N-1\right)!$</li>
<li>output: putdown <code>(! (- N 1))</code></li>
</ul>
</li>
<li>Test 6
<ul>
<li>input: LaTeX <code>\left(N-1)!</code>, typeset $\left(N-1)!$</li>
<li>output: putdown <code>null</code></li>
</ul>
</li>
<li>Test 7
<ul>
<li>input: LaTeX <code>(N-1\right)!</code>, typeset $(N-1\right)!$</li>
<li>output: putdown <code>null</code></li>
</ul>
</li>
<li>Test 8
<ul>
<li>input: LaTeX <code>3!\cdot4!</code>, typeset $3!\cdot4!$</li>
<li>output: putdown <code>(* (! 3) (! 4))</code></li>
</ul>
</li>
<li>Test 9
<ul>
<li>input: LaTeX <code>{-x}^{2\cdot{-3}}</code>, typeset ${-x}^{2\cdot{-3}}$</li>
<li>output: putdown <code>(^ (- x) (* 2 (- 3)))</code></li>
</ul>
</li>
<li>Test 10
<ul>
<li>input: LaTeX <code>(-x)^(2\cdot(-3))</code>, typeset $(-x)^(2\cdot(-3))$</li>
<li>output: putdown <code>(^ (- x) (* 2 (- 3)))</code></li>
</ul>
</li>
<li>Test 11
<ul>
<li>input: LaTeX <code>(-x)^{2\cdot(-3)}</code>, typeset $(-x)^{2\cdot(-3)}$</li>
<li>output: putdown <code>(^ (- x) (* 2 (- 3)))</code></li>
</ul>
</li>
<li>Test 12
<ul>
<li>input: LaTeX <code>{-3}^{1+2}</code>, typeset ${-3}^{1+2}$</li>
<li>output: putdown <code>(^ (- 3) (+ 1 2))</code></li>
</ul>
</li>
<li>Test 13
<ul>
<li>input: LaTeX <code>k^{1-y}\cdot(2+k)</code>, typeset $k^{1-y}\cdot(2+k)$</li>
<li>output: putdown <code>(* (^ k (- 1 y)) (+ 2 k))</code></li>
</ul>
</li>
<li>Test 14
<ul>
<li>input: LaTeX <code>0.99\approx1.01</code>, typeset $0.99\approx1.01$</li>
<li>output: putdown <code>(relationholds ~~ 0.99 1.01)</code></li>
</ul>
</li>
</ul>
<h3>can convert relations of numeric expressions</h3>
<ul>
<li>Test 1
<ul>
<li>input: LaTeX <code>1 &gt; 2</code>, typeset $1 &gt; 2$</li>
<li>output: putdown <code>(&gt; 1 2)</code></li>
</ul>
</li>
<li>Test 2
<ul>
<li>input: LaTeX <code>1 \gt 2</code>, typeset $1 \gt 2$</li>
<li>output: putdown <code>(&gt; 1 2)</code></li>
</ul>
</li>
<li>Test 3
<ul>
<li>input: LaTeX <code>1 - 2 &lt; 1 + 2</code>, typeset $1 - 2 &lt; 1 + 2$</li>
<li>output: putdown <code>(&lt; (- 1 2) (+ 1 2))</code></li>
</ul>
</li>
<li>Test 4
<ul>
<li>input: LaTeX <code>1 - 2 \lt 1 + 2</code>, typeset $1 - 2 \lt 1 + 2$</li>
<li>output: putdown <code>(&lt; (- 1 2) (+ 1 2))</code></li>
</ul>
</li>
<li>Test 5
<ul>
<li>input: LaTeX <code>\neg 1 = 2</code>, typeset $\neg 1 = 2$</li>
<li>output: putdown <code>(not (= 1 2))</code></li>
</ul>
</li>
<li>Test 6
<ul>
<li>input: LaTeX <code>2 \ge 1 \wedge 2 \le 3</code>, typeset $2 \ge 1 \wedge 2 \le 3$</li>
<li>output: putdown <code>(and (&gt;= 2 1) (&lt;= 2 3))</code></li>
</ul>
</li>
<li>Test 7
<ul>
<li>input: LaTeX <code>2\geq1\wedge2\leq3</code>, typeset $2\geq1\wedge2\leq3$</li>
<li>output: putdown <code>(and (&gt;= 2 1) (&lt;= 2 3))</code></li>
</ul>
</li>
<li>Test 8
<ul>
<li>input: LaTeX <code>7 | 14</code>, typeset $7 | 14$</li>
<li>output: putdown <code>(relationholds | 7 14)</code></li>
</ul>
</li>
<li>Test 9
<ul>
<li>input: LaTeX <code>7 \vert 14</code>, typeset $7 \vert 14$</li>
<li>output: putdown <code>(relationholds | 7 14)</code></li>
</ul>
</li>
<li>Test 10
<ul>
<li>input: LaTeX <code>A ( k ) | n !</code>, typeset $A ( k ) | n !$</li>
<li>output: putdown <code>(relationholds | (apply A k) (! n))</code></li>
</ul>
</li>
<li>Test 11
<ul>
<li>input: LaTeX <code>A ( k )\vert n !</code>, typeset $A ( k )\vert n !$</li>
<li>output: putdown <code>(relationholds | (apply A k) (! n))</code></li>
</ul>
</li>
<li>Test 12
<ul>
<li>input: LaTeX <code>1 - k \sim 1 + k</code>, typeset $1 - k \sim 1 + k$</li>
<li>output: putdown <code>(relationholds ~ (- 1 k) (+ 1 k))</code></li>
</ul>
</li>
</ul>
<h3>creates the canonical form for inequality</h3>
<ul>
<li>Test 1
<ul>
<li>input: LaTeX <code>x \ne y</code>, typeset $x \ne y$</li>
<li>output: putdown <code>(not (= x y))</code></li>
</ul>
</li>
<li>Test 2
<ul>
<li>input: LaTeX <code>x \neq y</code>, typeset $x \neq y$</li>
<li>output: putdown <code>(not (= x y))</code></li>
</ul>
</li>
<li>Test 3
<ul>
<li>input: LaTeX <code>\neg x = y</code>, typeset $\neg x = y$</li>
<li>output: putdown <code>(not (= x y))</code></li>
</ul>
</li>
</ul>
<h3>correctly converts propositional logic atomics</h3>
<ul>
<li>Test 1
<ul>
<li>input: LaTeX <code>\top</code>, typeset $\top$</li>
<li>output: putdown <code>true</code></li>
</ul>
</li>
<li>Test 2
<ul>
<li>input: LaTeX <code>\bot</code>, typeset $\bot$</li>
<li>output: putdown <code>false</code></li>
</ul>
</li>
<li>Test 3
<ul>
<li>input: LaTeX <code>\rightarrow\leftarrow</code>, typeset $\rightarrow\leftarrow$</li>
<li>output: putdown <code>contradiction</code></li>
</ul>
</li>
</ul>
<h3>correctly converts propositional logic conjuncts</h3>
<ul>
<li>Test 1
<ul>
<li>input: LaTeX <code>\top\wedge\bot</code>, typeset $\top\wedge\bot$</li>
<li>output: putdown <code>(and true false)</code></li>
</ul>
</li>
<li>Test 2
<ul>
<li>input: LaTeX <code>\neg P\wedge\neg\top</code>, typeset $\neg P\wedge\neg\top$</li>
<li>output: putdown <code>(and (not P) (not true))</code></li>
</ul>
</li>
<li>Test 3
<ul>
<li>input: LaTeX <code>a\wedge b\wedge c</code>, typeset $a\wedge b\wedge c$</li>
<li>output: putdown <code>(and a (and b c))</code></li>
</ul>
</li>
</ul>
<h3>correctly converts propositional logic disjuncts</h3>
<ul>
<li>Test 1
<ul>
<li>input: LaTeX <code>\top\vee \neg A</code>, typeset $\top\vee \neg A$</li>
<li>output: putdown <code>(or true (not A))</code></li>
</ul>
</li>
<li>Test 2
<ul>
<li>input: LaTeX <code>P\wedge Q\vee Q\wedge P</code>, typeset $P\wedge Q\vee Q\wedge P$</li>
<li>output: putdown <code>(or (and P Q) (and Q P))</code></li>
</ul>
</li>
</ul>
<h3>correctly converts propositional logic conditionals</h3>
<ul>
<li>Test 1
<ul>
<li>input: LaTeX <code>A\Rightarrow Q\wedge\neg P</code>, typeset $A\Rightarrow Q\wedge\neg P$</li>
<li>output: putdown <code>(implies A (and Q (not P)))</code></li>
</ul>
</li>
<li>Test 2
<ul>
<li>input: LaTeX <code>P\vee Q\Rightarrow Q\wedge P\Rightarrow T</code>, typeset $P\vee Q\Rightarrow Q\wedge P\Rightarrow T$</li>
<li>output: putdown <code>(implies (or P Q) (implies (and Q P) T))</code></li>
</ul>
</li>
</ul>
<h3>correctly converts propositional logic biconditionals</h3>
<ul>
<li>Test 1
<ul>
<li>input: LaTeX <code>A\Leftrightarrow Q\wedge\neg P</code>, typeset $A\Leftrightarrow Q\wedge\neg P$</li>
<li>output: putdown <code>(iff A (and Q (not P)))</code></li>
</ul>
</li>
<li>Test 2
<ul>
<li>input: LaTeX <code>P\vee Q\Leftrightarrow Q\wedge P\Rightarrow T</code>, typeset $P\vee Q\Leftrightarrow Q\wedge P\Rightarrow T$</li>
<li>output: putdown <code>(implies (iff (or P Q) (and Q P)) T)</code></li>
</ul>
</li>
</ul>
<h3>correctly converts propositional expressions with groupers</h3>
<ul>
<li>Test 1
<ul>
<li>input: LaTeX <code>P\lor {Q\Leftrightarrow Q}\land P</code>, typeset $P\lor {Q\Leftrightarrow Q}\land P$</li>
<li>output: putdown <code>(or P (and (iff Q Q) P))</code></li>
</ul>
</li>
<li>Test 2
<ul>
<li>input: LaTeX <code>\lnot{\top\Leftrightarrow\bot}</code>, typeset $\lnot{\top\Leftrightarrow\bot}$</li>
<li>output: putdown <code>(not (iff true false))</code></li>
</ul>
</li>
<li>Test 3
<ul>
<li>input: LaTeX <code>\lnot\left(\top\Leftrightarrow\bot\right)</code>, typeset $\lnot\left(\top\Leftrightarrow\bot\right)$</li>
<li>output: putdown <code>(not (iff true false))</code></li>
</ul>
</li>
<li>Test 4
<ul>
<li>input: LaTeX <code>\lnot(\top\Leftrightarrow\bot)</code>, typeset $\lnot(\top\Leftrightarrow\bot)$</li>
<li>output: putdown <code>(not (iff true false))</code></li>
</ul>
</li>
</ul>
<h3>correctly converts simple predicate logic expressions</h3>
<ul>
<li>Test 1
<ul>
<li>input: LaTeX <code>\forall x, P</code>, typeset $\forall x, P$</li>
<li>output: putdown <code>(forall (x , P))</code></li>
</ul>
</li>
<li>Test 2
<ul>
<li>input: LaTeX <code>\exists t,\neg Q</code>, typeset $\exists t,\neg Q$</li>
<li>output: putdown <code>(exists (t , (not Q)))</code></li>
</ul>
</li>
<li>Test 3
<ul>
<li>input: LaTeX <code>\exists! k,m\Rightarrow n</code>, typeset $\exists! k,m\Rightarrow n$</li>
<li>output: putdown <code>(exists! (k , (implies m n)))</code></li>
</ul>
</li>
</ul>
<h3>can convert finite and empty sets</h3>
<ul>
<li>Test 1
<ul>
<li>input: LaTeX <code>\emptyset</code>, typeset $\emptyset$</li>
<li>output: putdown <code>emptyset</code></li>
</ul>
</li>
<li>Test 2
<ul>
<li>input: LaTeX <code>\{ 1 \}</code>, typeset ${ 1 }$</li>
<li>output: putdown <code>(finiteset (elts 1))</code></li>
</ul>
</li>
<li>Test 3
<ul>
<li>input: LaTeX <code>\left\{ 1 \right\}</code>, typeset $\left{ 1 \right}$</li>
<li>output: putdown <code>(finiteset (elts 1))</code></li>
</ul>
</li>
<li>Test 4
<ul>
<li>input: LaTeX <code>\{ 1 , 2 \}</code>, typeset ${ 1 , 2 }$</li>
<li>output: putdown <code>(finiteset (elts 1 (elts 2)))</code></li>
</ul>
</li>
<li>Test 5
<ul>
<li>input: LaTeX <code>\{ 1 , 2 , 3 \}</code>, typeset ${ 1 , 2 , 3 }$</li>
<li>output: putdown <code>(finiteset (elts 1 (elts 2 (elts 3))))</code></li>
</ul>
</li>
<li>Test 6
<ul>
<li>input: LaTeX <code>\{ \emptyset , \emptyset \}</code>, typeset ${ \emptyset , \emptyset }$</li>
<li>output: putdown <code>(finiteset (elts emptyset (elts emptyset)))</code></li>
</ul>
</li>
<li>Test 7
<ul>
<li>input: LaTeX <code>\{ \{ \emptyset \} \}</code>, typeset ${ { \emptyset } }$</li>
<li>output: putdown <code>(finiteset (elts (finiteset (elts emptyset))))</code></li>
</ul>
</li>
<li>Test 8
<ul>
<li>input: LaTeX <code>\{ 3 , x \}</code>, typeset ${ 3 , x }$</li>
<li>output: putdown <code>(finiteset (elts 3 (elts x)))</code></li>
</ul>
</li>
<li>Test 9
<ul>
<li>input: LaTeX <code>\left\{ 3 , x \right\}</code>, typeset $\left{ 3 , x \right}$</li>
<li>output: putdown <code>(finiteset (elts 3 (elts x)))</code></li>
</ul>
</li>
<li>Test 10
<ul>
<li>input: LaTeX <code>\{ A \cup B , A \cap B \}</code>, typeset ${ A \cup B , A \cap B }$</li>
<li>output: putdown <code>(finiteset (elts (union A B) (elts (intersection A B))))</code></li>
</ul>
</li>
<li>Test 11
<ul>
<li>input: LaTeX <code>\{ 1 , 2 , \emptyset , K , P \}</code>, typeset ${ 1 , 2 , \emptyset , K , P }$</li>
<li>output: putdown <code>(finiteset (elts 1 (elts 2 (elts emptyset (elts K (elts P))))))</code></li>
</ul>
</li>
</ul>
<h3>correctly converts tuples and vectors</h3>
<ul>
<li>Test 1
<ul>
<li>input: LaTeX <code>( 5 , 6 )</code>, typeset $( 5 , 6 )$</li>
<li>output: putdown <code>(tuple (elts 5 (elts 6)))</code></li>
</ul>
</li>
<li>Test 2
<ul>
<li>input: LaTeX <code>( 5 , A \cup B , k )</code>, typeset $( 5 , A \cup B , k )$</li>
<li>output: putdown <code>(tuple (elts 5 (elts (union A B) (elts k))))</code></li>
</ul>
</li>
<li>Test 3
<ul>
<li>input: LaTeX <code>\langle 5 , 6 \rangle</code>, typeset $\langle 5 , 6 \rangle$</li>
<li>output: putdown <code>(vector (elts 5 (elts 6)))</code></li>
</ul>
</li>
<li>Test 4
<ul>
<li>input: LaTeX <code>\langle 5 , - 7 , k \rangle</code>, typeset $\langle 5 , - 7 , k \rangle$</li>
<li>output: putdown <code>(vector (elts 5 (elts (- 7) (elts k))))</code></li>
</ul>
</li>
<li>Test 5
<ul>
<li>input: LaTeX <code>()</code>, typeset $()$</li>
<li>output: putdown <code>null</code></li>
</ul>
</li>
<li>Test 6
<ul>
<li>input: LaTeX <code>(())</code>, typeset $(())$</li>
<li>output: putdown <code>null</code></li>
</ul>
</li>
<li>Test 7
<ul>
<li>input: LaTeX <code>(3)</code>, typeset $(3)$</li>
<li>output: putdown <code>3</code></li>
</ul>
</li>
<li>Test 8
<ul>
<li>input: LaTeX <code>\langle\rangle</code>, typeset $\langle\rangle$</li>
<li>output: putdown <code>null</code></li>
</ul>
</li>
<li>Test 9
<ul>
<li>input: LaTeX <code>\langle3\rangle</code>, typeset $\langle3\rangle$</li>
<li>output: putdown <code>null</code></li>
</ul>
</li>
<li>Test 10
<ul>
<li>input: LaTeX <code>( ( 1 , 2 ) , 6 )</code>, typeset $( ( 1 , 2 ) , 6 )$</li>
<li>output: putdown <code>(tuple (elts (tuple (elts 1 (elts 2))) (elts 6)))</code></li>
</ul>
</li>
<li>Test 11
<ul>
<li>input: LaTeX <code>\langle(1,2),6\rangle</code>, typeset $\langle(1,2),6\rangle$</li>
<li>output: putdown <code>null</code></li>
</ul>
</li>
<li>Test 12
<ul>
<li>input: LaTeX <code>\langle\langle1,2\rangle,6\rangle</code>, typeset $\langle\langle1,2\rangle,6\rangle$</li>
<li>output: putdown <code>null</code></li>
</ul>
</li>
<li>Test 13
<ul>
<li>input: LaTeX <code>\langle A\cup B,6\rangle</code>, typeset $\langle A\cup B,6\rangle$</li>
<li>output: putdown <code>null</code></li>
</ul>
</li>
</ul>
<h3>can convert simple set memberships and subsets</h3>
<ul>
<li>Test 1
<ul>
<li>input: LaTeX <code>b \in B</code>, typeset $b \in B$</li>
<li>output: putdown <code>(in b B)</code></li>
</ul>
</li>
<li>Test 2
<ul>
<li>input: LaTeX <code>2 \in \{ 1 , 2 \}</code>, typeset $2 \in { 1 , 2 }$</li>
<li>output: putdown <code>(in 2 (finiteset (elts 1 (elts 2))))</code></li>
</ul>
</li>
<li>Test 3
<ul>
<li>input: LaTeX <code>X \in a \cup b</code>, typeset $X \in a \cup b$</li>
<li>output: putdown <code>(in X (union a b))</code></li>
</ul>
</li>
<li>Test 4
<ul>
<li>input: LaTeX <code>A \cup B \in X \cup Y</code>, typeset $A \cup B \in X \cup Y$</li>
<li>output: putdown <code>(in (union A B) (union X Y))</code></li>
</ul>
</li>
<li>Test 5
<ul>
<li>input: LaTeX <code>A \subset \bar B</code>, typeset $A \subset \bar B$</li>
<li>output: putdown <code>(subset A (complement B))</code></li>
</ul>
</li>
<li>Test 6
<ul>
<li>input: LaTeX <code>u \cap v \subseteq u \cup v</code>, typeset $u \cap v \subseteq u \cup v$</li>
<li>output: putdown <code>(subseteq (intersection u v) (union u v))</code></li>
</ul>
</li>
<li>Test 7
<ul>
<li>input: LaTeX <code>\{1\}\subseteq\{1\}\cup\{2\}</code>, typeset ${1}\subseteq{1}\cup{2}$</li>
<li>output: putdown <code>(subseteq (finiteset (elts 1)) (union (finiteset (elts 1)) (finiteset (elts 2))))</code></li>
</ul>
</li>
<li>Test 8
<ul>
<li>input: LaTeX <code>p \in U \times V</code>, typeset $p \in U \times V$</li>
<li>output: putdown <code>(in p (cartesianproduct U V))</code></li>
</ul>
</li>
<li>Test 9
<ul>
<li>input: LaTeX <code>q \in \bar U \cup V \times W</code>, typeset $q \in \bar U \cup V \times W$</li>
<li>output: putdown <code>(in q (union (complement U) (cartesianproduct V W)))</code></li>
</ul>
</li>
<li>Test 10
<ul>
<li>input: LaTeX <code>( a , b ) \in A \times B</code>, typeset $( a , b ) \in A \times B$</li>
<li>output: putdown <code>(in (tuple (elts a (elts b))) (cartesianproduct A B))</code></li>
</ul>
</li>
<li>Test 11
<ul>
<li>input: LaTeX <code>\langle a , b \rangle \in A \times B</code>, typeset $\langle a , b \rangle \in A \times B$</li>
<li>output: putdown <code>(in (vector (elts a (elts b))) (cartesianproduct A B))</code></li>
</ul>
</li>
</ul>
<h3>expands &quot;notin&quot; notation into canonical form</h3>
<ul>
<li>Test 1
<ul>
<li>input: LaTeX <code>a\notin A</code>, typeset $a\notin A$</li>
<li>output: putdown <code>(not (in a A))</code></li>
</ul>
</li>
<li>Test 2
<ul>
<li>input: LaTeX <code>\emptyset \notin \emptyset</code>, typeset $\emptyset \notin \emptyset$</li>
<li>output: putdown <code>(not (in emptyset emptyset))</code></li>
</ul>
</li>
<li>Test 3
<ul>
<li>input: LaTeX <code>3-5\notin K\cap P</code>, typeset $3-5\notin K\cap P$</li>
<li>output: putdown <code>(not (in (- 3 5) (intersection K P)))</code></li>
</ul>
</li>
</ul>
<h3>can convert sentences built from set operators</h3>
<ul>
<li>Test 1
<ul>
<li>input: LaTeX <code>P \vee b \in B</code>, typeset $P \vee b \in B$</li>
<li>output: putdown <code>(or P (in b B))</code></li>
</ul>
</li>
<li>Test 2
<ul>
<li>input: LaTeX <code>{P \vee b} \in B</code>, typeset ${P \vee b} \in B$</li>
<li>output: putdown <code>(in (or P b) B)</code></li>
</ul>
</li>
<li>Test 3
<ul>
<li>input: LaTeX <code>\forall x , x \in X</code>, typeset $\forall x , x \in X$</li>
<li>output: putdown <code>(forall (x , (in x X)))</code></li>
</ul>
</li>
<li>Test 4
<ul>
<li>input: LaTeX <code>A \subseteq B \wedge B \subseteq A</code>, typeset $A \subseteq B \wedge B \subseteq A$</li>
<li>output: putdown <code>(and (subseteq A B) (subseteq B A))</code></li>
</ul>
</li>
<li>Test 5
<ul>
<li>input: LaTeX <code>R = A \times B</code>, typeset $R = A \times B$</li>
<li>output: putdown <code>(= R (* A B))</code></li>
</ul>
</li>
<li>Test 6
<ul>
<li>input: LaTeX <code>R = A \cup B</code>, typeset $R = A \cup B$</li>
<li>output: putdown <code>(= R (union A B))</code></li>
</ul>
</li>
<li>Test 7
<ul>
<li>input: LaTeX <code>\forall n , n | n !</code>, typeset $\forall n , n | n !$</li>
<li>output: putdown <code>(forall (n , (relationholds | n (! n))))</code></li>
</ul>
</li>
<li>Test 8
<ul>
<li>input: LaTeX <code>a \sim b \Rightarrow b \sim a</code>, typeset $a \sim b \Rightarrow b \sim a$</li>
<li>output: putdown <code>(implies (relationholds ~ a b) (relationholds ~ b a))</code></li>
</ul>
</li>
</ul>
<h3>can convert notation related to functions</h3>
<ul>
<li>Test 1
<ul>
<li>input: LaTeX <code>f:A\to B</code>, typeset $f:A\to B$</li>
<li>output: putdown <code>(function f A B)</code></li>
</ul>
</li>
<li>Test 2
<ul>
<li>input: LaTeX <code>f\colon A\to B</code>, typeset $f\colon A\to B$</li>
<li>output: putdown <code>(function f A B)</code></li>
</ul>
</li>
<li>Test 3
<ul>
<li>input: LaTeX <code>\neg F:X\cup Y\to Z</code>, typeset $\neg F:X\cup Y\to Z$</li>
<li>output: putdown <code>(not (function F (union X Y) Z))</code></li>
</ul>
</li>
<li>Test 4
<ul>
<li>input: LaTeX <code>\neg F\colon X\cup Y\to Z</code>, typeset $\neg F\colon X\cup Y\to Z$</li>
<li>output: putdown <code>(not (function F (union X Y) Z))</code></li>
</ul>
</li>
<li>Test 5
<ul>
<li>input: LaTeX <code>f \circ g : A \to C</code>, typeset $f \circ g : A \to C$</li>
<li>output: putdown <code>(function (compose f g) A C)</code></li>
</ul>
</li>
<li>Test 6
<ul>
<li>input: LaTeX <code>f(x)</code>, typeset $f(x)$</li>
<li>output: putdown <code>(apply f x)</code></li>
</ul>
</li>
<li>Test 7
<ul>
<li>input: LaTeX <code>f ^ {-1} ( g ^ {-1} ( 10 ) )</code>, typeset $f ^ {-1} ( g ^ {-1} ( 10 ) )$</li>
<li>output: putdown <code>(apply (inverse f) (apply (inverse g) 10))</code></li>
</ul>
</li>
<li>Test 8
<ul>
<li>input: LaTeX <code>E(\bar L)</code>, typeset $E(\bar L)$</li>
<li>output: putdown <code>(apply E (complement L))</code></li>
</ul>
</li>
<li>Test 9
<ul>
<li>input: LaTeX <code>\emptyset\cap f(2)</code>, typeset $\emptyset\cap f(2)$</li>
<li>output: putdown <code>(intersection emptyset (apply f 2))</code></li>
</ul>
</li>
<li>Test 10
<ul>
<li>input: LaTeX <code>P(e)\wedge Q(3+b)</code>, typeset $P(e)\wedge Q(3+b)$</li>
<li>output: putdown <code>(and (apply P eulersnumber) (apply Q (+ 3 b)))</code></li>
</ul>
</li>
<li>Test 11
<ul>
<li>input: LaTeX <code>F=G\circ H^{-1}</code>, typeset $F=G\circ H^{-1}$</li>
<li>output: putdown <code>(= F (compose G (inverse H)))</code></li>
</ul>
</li>
</ul>
<h3>can convert expressions with trigonometric functions</h3>
<ul>
<li>Test 1
<ul>
<li>input: LaTeX <code>\sin x</code>, typeset $\sin x$</li>
<li>output: putdown <code>(apply sin x)</code></li>
</ul>
</li>
<li>Test 2
<ul>
<li>input: LaTeX <code>\cos \pi \times x</code>, typeset $\cos \pi \times x$</li>
<li>output: putdown <code>(apply cos (* pi x))</code></li>
</ul>
</li>
<li>Test 3
<ul>
<li>input: LaTeX <code>\tan t</code>, typeset $\tan t$</li>
<li>output: putdown <code>(apply tan t)</code></li>
</ul>
</li>
<li>Test 4
<ul>
<li>input: LaTeX <code>1 \div \cot \pi</code>, typeset $1 \div \cot \pi$</li>
<li>output: putdown <code>(/ 1 (apply cot pi))</code></li>
</ul>
</li>
<li>Test 5
<ul>
<li>input: LaTeX <code>\sec y = \csc y</code>, typeset $\sec y = \csc y$</li>
<li>output: putdown <code>(= (apply sec y) (apply csc y))</code></li>
</ul>
</li>
</ul>
<h3>can convert expressions with logarithms</h3>
<ul>
<li>Test 1
<ul>
<li>input: LaTeX <code>\log n</code>, typeset $\log n$</li>
<li>output: putdown <code>(apply log n)</code></li>
</ul>
</li>
<li>Test 2
<ul>
<li>input: LaTeX <code>1 + \ln x</code>, typeset $1 + \ln x$</li>
<li>output: putdown <code>(+ 1 (apply ln x))</code></li>
</ul>
</li>
<li>Test 3
<ul>
<li>input: LaTeX <code>\log_ 2 1024</code>, typeset $\log_ 2 1024$</li>
<li>output: putdown <code>(apply (logbase 2) 1024)</code></li>
</ul>
</li>
<li>Test 4
<ul>
<li>input: LaTeX <code>\log n \div \log \log n</code>, typeset $\log n \div \log \log n$</li>
<li>output: putdown <code>(/ (apply log n) (apply log (apply log n)))</code></li>
</ul>
</li>
</ul>
<h3>can convert equivalence classes and expressions that use them</h3>
<ul>
<li>Test 1
<ul>
<li>input: LaTeX <code>[ 1 , \approx ]</code>, typeset $[ 1 , \approx ]$</li>
<li>output: putdown <code>(equivclass 1 ~~)</code></li>
</ul>
</li>
<li>Test 2
<ul>
<li>input: LaTeX <code>\left[ 1 , \approx \right]</code>, typeset $\left[ 1 , \approx \right]$</li>
<li>output: putdown <code>(equivclass 1 ~~)</code></li>
</ul>
</li>
<li>Test 3
<ul>
<li>input: LaTeX <code>\left[ 1 , \approx ]</code>, typeset $\left[ 1 , \approx ]$</li>
<li>output: putdown <code>null</code></li>
</ul>
</li>
<li>Test 4
<ul>
<li>input: LaTeX <code>[ 1 , \approx \right]</code>, typeset $[ 1 , \approx \right]$</li>
<li>output: putdown <code>null</code></li>
</ul>
</li>
<li>Test 5
<ul>
<li>input: LaTeX <code>[ x + 2 , \sim ]</code>, typeset $[ x + 2 , \sim ]$</li>
<li>output: putdown <code>(equivclass (+ x 2) ~)</code></li>
</ul>
</li>
<li>Test 6
<ul>
<li>input: LaTeX <code>[ 1 , \approx ] \cup [ 2 , \approx ]</code>, typeset $[ 1 , \approx ] \cup [ 2 , \approx ]$</li>
<li>output: putdown <code>(union (equivclass 1 ~~) (equivclass 2 ~~))</code></li>
</ul>
</li>
<li>Test 7
<ul>
<li>input: LaTeX <code>7 \in [ 7 , \sim ]</code>, typeset $7 \in [ 7 , \sim ]$</li>
<li>output: putdown <code>(in 7 (equivclass 7 ~))</code></li>
</ul>
</li>
<li>Test 8
<ul>
<li>input: LaTeX <code>[P]</code>, typeset $[P]$</li>
<li>output: putdown <code>(equivclass P ~)</code></li>
</ul>
</li>
<li>Test 9
<ul>
<li>input: LaTeX <code>\left[P\right]</code>, typeset $\left[P\right]$</li>
<li>output: putdown <code>(equivclass P ~)</code></li>
</ul>
</li>
</ul>
<h3>can convert equivalence and classes mod a number</h3>
<ul>
<li>Test 1
<ul>
<li>input: LaTeX <code>5 \equiv 11 \mod 3</code>, typeset $5 \equiv 11 \mod 3$</li>
<li>output: putdown <code>(=mod 5 11 3)</code></li>
</ul>
</li>
<li>Test 2
<ul>
<li>input: LaTeX <code>k \equiv m \mod n</code>, typeset $k \equiv m \mod n$</li>
<li>output: putdown <code>(=mod k m n)</code></li>
</ul>
</li>
<li>Test 3
<ul>
<li>input: LaTeX <code>\emptyset \subset [ - 1 , \equiv _ 10 ]</code>, typeset $\emptyset \subset [ - 1 , \equiv _ 10 ]$</li>
<li>output: putdown <code>(subset emptyset (modclass (- 1) 10))</code></li>
</ul>
</li>
<li>Test 4
<ul>
<li>input: LaTeX <code>\emptyset \subset \left[ - 1 , \equiv _ 10 \right]</code>, typeset $\emptyset \subset \left[ - 1 , \equiv _ 10 \right]$</li>
<li>output: putdown <code>(subset emptyset (modclass (- 1) 10))</code></li>
</ul>
</li>
</ul>
<h3>can convert type sentences and combinations of them</h3>
<ul>
<li>Test 1
<ul>
<li>input: LaTeX <code>x \text{is a set}</code>, typeset $x \text{is a set}$</li>
<li>output: putdown <code>(hastype x settype)</code></li>
</ul>
</li>
<li>Test 2
<ul>
<li>input: LaTeX <code>n \text{is }\text{a number}</code>, typeset $n \text{is }\text{a number}$</li>
<li>output: putdown <code>(hastype n numbertype)</code></li>
</ul>
</li>
<li>Test 3
<ul>
<li>input: LaTeX <code>S\text{is}~\text{a partial order}</code>, typeset $S\text{is}~\text{a partial order}$</li>
<li>output: putdown <code>(hastype S partialordertype)</code></li>
</ul>
</li>
<li>Test 4
<ul>
<li>input: LaTeX <code>1\text{is a number}\wedge 10\text{is a number}</code>, typeset $1\text{is a number}\wedge 10\text{is a number}$</li>
<li>output: putdown <code>(and (hastype 1 numbertype) (hastype 10 numbertype))</code></li>
</ul>
</li>
<li>Test 5
<ul>
<li>input: LaTeX <code>R\text{is an equivalence relation}\Rightarrow R\text{is a relation}</code>, typeset $R\text{is an equivalence relation}\Rightarrow R\text{is a relation}$</li>
<li>output: putdown <code>(implies (hastype R equivalencerelationtype) (hastype R relationtype))</code></li>
</ul>
</li>
</ul>
<h3>can convert notation for expression function application</h3>
<ul>
<li>Test 1
<ul>
<li>input: LaTeX <code>\mathcal{f} (x)</code>, typeset $\mathcal{f} (x)$</li>
<li>output: putdown <code>(efa f x)</code></li>
</ul>
</li>
<li>Test 2
<ul>
<li>input: LaTeX <code>F(\mathcal{k} (10))</code>, typeset $F(\mathcal{k} (10))$</li>
<li>output: putdown <code>(apply F (efa k 10))</code></li>
</ul>
</li>
<li>Test 3
<ul>
<li>input: LaTeX <code>\mathcal{E} (\bar L)</code>, typeset $\mathcal{E} (\bar L)$</li>
<li>output: putdown <code>(efa E (complement L))</code></li>
</ul>
</li>
<li>Test 4
<ul>
<li>input: LaTeX <code>\emptyset\cap \mathcal{f} (2)</code>, typeset $\emptyset\cap \mathcal{f} (2)$</li>
<li>output: putdown <code>(intersection emptyset (efa f 2))</code></li>
</ul>
</li>
<li>Test 5
<ul>
<li>input: LaTeX <code>\mathcal{P} (x)\wedge \mathcal{Q} (y)</code>, typeset $\mathcal{P} (x)\wedge \mathcal{Q} (y)$</li>
<li>output: putdown <code>(and (efa P x) (efa Q y))</code></li>
</ul>
</li>
</ul>
<h3>can convert notation for assumptions</h3>
<ul>
<li>Test 1
<ul>
<li>input: LaTeX <code>\text{Assume }X</code>, typeset $\text{Assume }X$</li>
<li>output: putdown <code>:X</code></li>
</ul>
</li>
<li>Test 2
<ul>
<li>input: LaTeX <code>\text{Assume }k=1000</code>, typeset $\text{Assume }k=1000$</li>
<li>output: putdown <code>:(= k 1000)</code></li>
</ul>
</li>
<li>Test 3
<ul>
<li>input: LaTeX <code>\text{Assume }\top</code>, typeset $\text{Assume }\top$</li>
<li>output: putdown <code>:true</code></li>
</ul>
</li>
<li>Test 4
<ul>
<li>input: LaTeX <code>\text{Assume }50</code>, typeset $\text{Assume }50$</li>
<li>output: putdown <code>null</code></li>
</ul>
</li>
<li>Test 5
<ul>
<li>input: LaTeX <code>\text{assume }(5,6)</code>, typeset $\text{assume }(5,6)$</li>
<li>output: putdown <code>null</code></li>
</ul>
</li>
<li>Test 6
<ul>
<li>input: LaTeX <code>\text{Given }f\circ g</code>, typeset $\text{Given }f\circ g$</li>
<li>output: putdown <code>null</code></li>
</ul>
</li>
<li>Test 7
<ul>
<li>input: LaTeX <code>\text{given }\emptyset</code>, typeset $\text{given }\emptyset$</li>
<li>output: putdown <code>null</code></li>
</ul>
</li>
<li>Test 8
<ul>
<li>input: LaTeX <code>\text{Assume }\infty</code>, typeset $\text{Assume }\infty$</li>
<li>output: putdown <code>null</code></li>
</ul>
</li>
</ul>
<h3>can convert notation for Let-style declarations</h3>
<ul>
<li>Test 1
<ul>
<li>input: LaTeX <code>\text{Let }x</code>, typeset $\text{Let }x$</li>
<li>output: putdown <code>:[x]</code></li>
</ul>
</li>
<li>Test 2
<ul>
<li>input: LaTeX <code>\text{let }x</code>, typeset $\text{let }x$</li>
<li>output: putdown <code>:[x]</code></li>
</ul>
</li>
<li>Test 3
<ul>
<li>input: LaTeX <code>\text{Let }T</code>, typeset $\text{Let }T$</li>
<li>output: putdown <code>:[T]</code></li>
</ul>
</li>
<li>Test 4
<ul>
<li>input: LaTeX <code>\text{let }T</code>, typeset $\text{let }T$</li>
<li>output: putdown <code>:[T]</code></li>
</ul>
</li>
<li>Test 5
<ul>
<li>input: LaTeX <code>\text{Let }x \text{ be such that }x&gt;0</code>, typeset $\text{Let }x \text{ be such that }x&gt;0$</li>
<li>output: putdown <code>:[x , (&gt; x 0)]</code></li>
</ul>
</li>
<li>Test 6
<ul>
<li>input: LaTeX <code>\text{let }x \text{ be such that }x&gt;0</code>, typeset $\text{let }x \text{ be such that }x&gt;0$</li>
<li>output: putdown <code>:[x , (&gt; x 0)]</code></li>
</ul>
</li>
<li>Test 7
<ul>
<li>input: LaTeX <code>\text{Let }T \text{ be such that }T=5\vee T\in S</code>, typeset $\text{Let }T \text{ be such that }T=5\vee T\in S$</li>
<li>output: putdown <code>:[T , (or (= T 5) (in T S))]</code></li>
</ul>
</li>
<li>Test 8
<ul>
<li>input: LaTeX <code>\text{let }T \text{ be such that }T=5\vee T\in S</code>, typeset $\text{let }T \text{ be such that }T=5\vee T\in S$</li>
<li>output: putdown <code>:[T , (or (= T 5) (in T S))]</code></li>
</ul>
</li>
<li>Test 9
<ul>
<li>input: LaTeX <code>\text{Let }x&gt;5</code>, typeset $\text{Let }x&gt;5$</li>
<li>output: putdown <code>null</code></li>
</ul>
</li>
<li>Test 10
<ul>
<li>input: LaTeX <code>\text{Let }1=1</code>, typeset $\text{Let }1=1$</li>
<li>output: putdown <code>null</code></li>
</ul>
</li>
<li>Test 11
<ul>
<li>input: LaTeX <code>\text{Let }\emptyset</code>, typeset $\text{Let }\emptyset$</li>
<li>output: putdown <code>null</code></li>
</ul>
</li>
<li>Test 12
<ul>
<li>input: LaTeX <code>\text{Let }x \text{ be such that }1</code>, typeset $\text{Let }x \text{ be such that }1$</li>
<li>output: putdown <code>null</code></li>
</ul>
</li>
<li>Test 13
<ul>
<li>input: LaTeX <code>\text{Let }x \text{ be such that }1\vee 2</code>, typeset $\text{Let }x \text{ be such that }1\vee 2$</li>
<li>output: putdown <code>null</code></li>
</ul>
</li>
<li>Test 14
<ul>
<li>input: LaTeX <code>\text{Let }x \text{ be such that }\text{Let }y</code>, typeset $\text{Let }x \text{ be such that }\text{Let }y$</li>
<li>output: putdown <code>null</code></li>
</ul>
</li>
<li>Test 15
<ul>
<li>input: LaTeX <code>\text{Let }x \text{ be such that }\text{Assume }B</code>, typeset $\text{Let }x \text{ be such that }\text{Assume }B$</li>
<li>output: putdown <code>null</code></li>
</ul>
</li>
</ul>
<h3>can convert notation for For Some-style declarations</h3>
<ul>
<li>Test 1
<ul>
<li>input: LaTeX <code>\text{For some }x, x&gt;0</code>, typeset $\text{For some }x, x&gt;0$</li>
<li>output: putdown <code>[x , (&gt; x 0)]</code></li>
</ul>
</li>
<li>Test 2
<ul>
<li>input: LaTeX <code>\text{For some }T, T=5\vee T\in S</code>, typeset $\text{For some }T, T=5\vee T\in S$</li>
<li>output: putdown <code>[T , (or (= T 5) (in T S))]</code></li>
</ul>
</li>
<li>Test 3
<ul>
<li>input: LaTeX <code>\text{For some }x</code>, typeset $\text{For some }x$</li>
<li>output: putdown <code>null</code></li>
</ul>
</li>
<li>Test 4
<ul>
<li>input: LaTeX <code>\text{for some }x</code>, typeset $\text{for some }x$</li>
<li>output: putdown <code>null</code></li>
</ul>
</li>
<li>Test 5
<ul>
<li>input: LaTeX <code>\text{For some }T</code>, typeset $\text{For some }T$</li>
<li>output: putdown <code>null</code></li>
</ul>
</li>
<li>Test 6
<ul>
<li>input: LaTeX <code>\text{for some }T</code>, typeset $\text{for some }T$</li>
<li>output: putdown <code>null</code></li>
</ul>
</li>
<li>Test 7
<ul>
<li>input: LaTeX <code>\text{For some }x&gt;5, x&gt;55</code>, typeset $\text{For some }x&gt;5, x&gt;55$</li>
<li>output: putdown <code>null</code></li>
</ul>
</li>
<li>Test 8
<ul>
<li>input: LaTeX <code>\text{For some }1=1, P</code>, typeset $\text{For some }1=1, P$</li>
<li>output: putdown <code>null</code></li>
</ul>
</li>
<li>Test 9
<ul>
<li>input: LaTeX <code>\text{For some }\emptyset, 1+1=2</code>, typeset $\text{For some }\emptyset, 1+1=2$</li>
<li>output: putdown <code>null</code></li>
</ul>
</li>
<li>Test 10
<ul>
<li>input: LaTeX <code>x&gt;55 \text{ for some } x&gt;5</code>, typeset $x&gt;55 \text{ for some } x&gt;5$</li>
<li>output: putdown <code>null</code></li>
</ul>
</li>
<li>Test 11
<ul>
<li>input: LaTeX <code>P \text{ for some } 1=1</code>, typeset $P \text{ for some } 1=1$</li>
<li>output: putdown <code>null</code></li>
</ul>
</li>
<li>Test 12
<ul>
<li>input: LaTeX <code>\emptyset \text{ for some } 1+1=2</code>, typeset $\emptyset \text{ for some } 1+1=2$</li>
<li>output: putdown <code>null</code></li>
</ul>
</li>
<li>Test 13
<ul>
<li>input: LaTeX <code>\text{For some }x, 1</code>, typeset $\text{For some }x, 1$</li>
<li>output: putdown <code>null</code></li>
</ul>
</li>
<li>Test 14
<ul>
<li>input: LaTeX <code>\text{For some }x, 1\vee 2</code>, typeset $\text{For some }x, 1\vee 2$</li>
<li>output: putdown <code>null</code></li>
</ul>
</li>
<li>Test 15
<ul>
<li>input: LaTeX <code>\text{For some }x, \text{Let }y</code>, typeset $\text{For some }x, \text{Let }y$</li>
<li>output: putdown <code>null</code></li>
</ul>
</li>
<li>Test 16
<ul>
<li>input: LaTeX <code>\text{For some }x, \text{Assume }B</code>, typeset $\text{For some }x, \text{Assume }B$</li>
<li>output: putdown <code>null</code></li>
</ul>
</li>
<li>Test 17
<ul>
<li>input: LaTeX <code>1~\text{for some}~x</code>, typeset $1~\text{for some}~x$</li>
<li>output: putdown <code>null</code></li>
</ul>
</li>
<li>Test 18
<ul>
<li>input: LaTeX <code>1\vee 2~\text{for some}~x</code>, typeset $1\vee 2~\text{for some}~x$</li>
<li>output: putdown <code>null</code></li>
</ul>
</li>
<li>Test 19
<ul>
<li>input: LaTeX <code>\text{Let }y~\text{for some}~x</code>, typeset $\text{Let }y~\text{for some}~x$</li>
<li>output: putdown <code>null</code></li>
</ul>
</li>
<li>Test 20
<ul>
<li>input: LaTeX <code>\text{Assume }B~\text{for some}~x</code>, typeset $\text{Assume }B~\text{for some}~x$</li>
<li>output: putdown <code>null</code></li>
</ul>
</li>
</ul>
<h2><a name="Parsing-MathLive-style-LaTeX">Parsing MathLive-style LaTeX</a></h2>
<h3>correctly parses basic expressions</h3>
<ul>
<li>Test 1
<ul>
<li>input: LaTeX <code>6+k</code>, typeset $6+k$</li>
<li>output: JSON <code>[&quot;Addition&quot;,[&quot;Number&quot;,&quot;6&quot;],[&quot;NumberVariable&quot;,&quot;k&quot;]]</code></li>
</ul>
</li>
<li>Test 2
<ul>
<li>input: LaTeX <code>1.9-T</code>, typeset $1.9-T$</li>
<li>output: JSON <code>[&quot;Subtraction&quot;,[&quot;Number&quot;,&quot;1.9&quot;],[&quot;NumberVariable&quot;,&quot;T&quot;]]</code></li>
</ul>
</li>
<li>Test 3
<ul>
<li>input: LaTeX <code>0.2\cdot0.3</code>, typeset $0.2\cdot0.3$</li>
<li>output: JSON <code>[&quot;Multiplication&quot;,[&quot;Number&quot;,&quot;0.2&quot;],[&quot;Number&quot;,&quot;0.3&quot;]]</code></li>
</ul>
</li>
<li>Test 4
<ul>
<li>input: LaTeX <code>0.2\ast0.3</code>, typeset $0.2\ast0.3$</li>
<li>output: JSON <code>[&quot;Multiplication&quot;,[&quot;Number&quot;,&quot;0.2&quot;],[&quot;Number&quot;,&quot;0.3&quot;]]</code></li>
</ul>
</li>
<li>Test 5
<ul>
<li>input: LaTeX <code>v\div w</code>, typeset $v\div w$</li>
<li>output: JSON <code>[&quot;Division&quot;,[&quot;NumberVariable&quot;,&quot;v&quot;],[&quot;NumberVariable&quot;,&quot;w&quot;]]</code></li>
</ul>
</li>
<li>Test 6
<ul>
<li>input: LaTeX <code>2^{k}</code>, typeset $2^{k}$</li>
<li>output: JSON <code>[&quot;Exponentiation&quot;,[&quot;Number&quot;,&quot;2&quot;],[&quot;NumberVariable&quot;,&quot;k&quot;]]</code></li>
</ul>
</li>
<li>Test 7
<ul>
<li>input: LaTeX <code>5.0-K+e</code>, typeset $5.0-K+e$</li>
<li>output: JSON <code>[&quot;Addition&quot;,[&quot;Subtraction&quot;,[&quot;Number&quot;,&quot;5.0&quot;],[&quot;NumberVariable&quot;,&quot;K&quot;]],&quot;EulersNumber&quot;]</code></li>
</ul>
</li>
<li>Test 8
<ul>
<li>input: LaTeX <code>5.0\times K\div e</code>, typeset $5.0\times K\div e$</li>
<li>output: JSON <code>[&quot;Division&quot;,[&quot;Multiplication&quot;,[&quot;Number&quot;,&quot;5.0&quot;],[&quot;NumberVariable&quot;,&quot;K&quot;]],&quot;EulersNumber&quot;]</code></li>
</ul>
</li>
<li>Test 9
<ul>
<li>input: LaTeX <code>\left(a^{b}\right)^{c}</code>, typeset $\left(a^{b}\right)^{c}$</li>
<li>output: JSON <code>[&quot;Exponentiation&quot;,[&quot;Exponentiation&quot;,[&quot;NumberVariable&quot;,&quot;a&quot;],[&quot;NumberVariable&quot;,&quot;b&quot;]],[&quot;NumberVariable&quot;,&quot;c&quot;]]</code></li>
</ul>
</li>
<li>Test 10
<ul>
<li>input: LaTeX <code>5.0-K\cdot e</code>, typeset $5.0-K\cdot e$</li>
<li>output: JSON <code>[&quot;Subtraction&quot;,[&quot;Number&quot;,&quot;5.0&quot;],[&quot;Multiplication&quot;,[&quot;NumberVariable&quot;,&quot;K&quot;],&quot;EulersNumber&quot;]]</code></li>
</ul>
</li>
<li>Test 11
<ul>
<li>input: LaTeX <code>u^{v}\times w^{x}</code>, typeset $u^{v}\times w^{x}$</li>
<li>output: JSON <code>[&quot;Multiplication&quot;,[&quot;Exponentiation&quot;,[&quot;NumberVariable&quot;,&quot;u&quot;],[&quot;NumberVariable&quot;,&quot;v&quot;]],[&quot;Exponentiation&quot;,[&quot;NumberVariable&quot;,&quot;w&quot;],[&quot;NumberVariable&quot;,&quot;x&quot;]]]</code></li>
</ul>
</li>
<li>Test 12
<ul>
<li>input: LaTeX <code>-A^{B}</code>, typeset $-A^{B}$</li>
<li>output: JSON <code>[&quot;NumberNegation&quot;,[&quot;Exponentiation&quot;,[&quot;NumberVariable&quot;,&quot;A&quot;],[&quot;NumberVariable&quot;,&quot;B&quot;]]]</code></li>
</ul>
</li>
</ul>
<h3>respects groupers while parsing</h3>
<ul>
<li>Test 1
<ul>
<li>input: LaTeX <code>6+\left(k+5\right)</code>, typeset $6+\left(k+5\right)$</li>
<li>output: JSON <code>[&quot;Addition&quot;,[&quot;Number&quot;,&quot;6&quot;],[&quot;Addition&quot;,[&quot;NumberVariable&quot;,&quot;k&quot;],[&quot;Number&quot;,&quot;5&quot;]]]</code></li>
</ul>
</li>
<li>Test 2
<ul>
<li>input: LaTeX <code>\left(5.0-K\right)\cdot e</code>, typeset $\left(5.0-K\right)\cdot e$</li>
<li>output: JSON <code>[&quot;Multiplication&quot;,[&quot;Subtraction&quot;,[&quot;Number&quot;,&quot;5.0&quot;],[&quot;NumberVariable&quot;,&quot;K&quot;]],&quot;EulersNumber&quot;]</code></li>
</ul>
</li>
<li>Test 3
<ul>
<li>input: LaTeX <code>5.0\times\left(K+e\right)</code>, typeset $5.0\times\left(K+e\right)$</li>
<li>output: JSON <code>[&quot;Multiplication&quot;,[&quot;Number&quot;,&quot;5.0&quot;],[&quot;Addition&quot;,[&quot;NumberVariable&quot;,&quot;K&quot;],&quot;EulersNumber&quot;]]</code></li>
</ul>
</li>
<li>Test 4
<ul>
<li>input: LaTeX <code>-\left(K+e\right)</code>, typeset $-\left(K+e\right)$</li>
<li>output: JSON <code>[&quot;NumberNegation&quot;,[&quot;Addition&quot;,[&quot;NumberVariable&quot;,&quot;K&quot;],&quot;EulersNumber&quot;]]</code></li>
</ul>
</li>
<li>Test 5
<ul>
<li>input: LaTeX <code>-\left(A^{B}\right)</code>, typeset $-\left(A^{B}\right)$</li>
<li>output: JSON <code>[&quot;NumberNegation&quot;,[&quot;Exponentiation&quot;,[&quot;NumberVariable&quot;,&quot;A&quot;],[&quot;NumberVariable&quot;,&quot;B&quot;]]]</code></li>
</ul>
</li>
</ul>
<h3>correctly parses logarithms</h3>
<ul>
<li>Test 1
<ul>
<li>input: LaTeX <code>\log1000</code>, typeset $\log1000$</li>
<li>output: JSON <code>[&quot;PrefixFunctionApplication&quot;,&quot;Logarithm&quot;,[&quot;Number&quot;,&quot;1000&quot;]]</code></li>
</ul>
</li>
<li>Test 2
<ul>
<li>input: LaTeX <code>\log e^{x}\times y</code>, typeset $\log e^{x}\times y$</li>
<li>output: JSON <code>[&quot;PrefixFunctionApplication&quot;,&quot;Logarithm&quot;,[&quot;Multiplication&quot;,[&quot;Exponentiation&quot;,&quot;EulersNumber&quot;,[&quot;NumberVariable&quot;,&quot;x&quot;]],[&quot;NumberVariable&quot;,&quot;y&quot;]]]</code></li>
</ul>
</li>
<li>Test 3
<ul>
<li>input: LaTeX <code>\log_{-t}\left(k+5\right)</code>, typeset $\log_{-t}\left(k+5\right)$</li>
<li>output: JSON <code>[&quot;PrefixFunctionApplication&quot;,[&quot;LogarithmWithBase&quot;,[&quot;NumberNegation&quot;,[&quot;NumberVariable&quot;,&quot;t&quot;]]],[&quot;Addition&quot;,[&quot;NumberVariable&quot;,&quot;k&quot;],[&quot;Number&quot;,&quot;5&quot;]]]</code></li>
</ul>
</li>
</ul>
<h3>correctly parses fractions</h3>
<ul>
<li>Test 1
<ul>
<li>input: LaTeX <code>\frac 1 2</code>, typeset $\frac 1 2$</li>
<li>output: JSON <code>[&quot;Division&quot;,[&quot;Number&quot;,&quot;1&quot;],[&quot;Number&quot;,&quot;2&quot;]]</code></li>
</ul>
</li>
<li>Test 2
<ul>
<li>input: LaTeX <code>\frac{7-k}{1+x^2}</code>, typeset $\frac{7-k}{1+x^2}$</li>
<li>output: JSON <code>[&quot;Division&quot;,[&quot;Subtraction&quot;,[&quot;Number&quot;,&quot;7&quot;],[&quot;NumberVariable&quot;,&quot;k&quot;]],[&quot;Addition&quot;,[&quot;Number&quot;,&quot;1&quot;],[&quot;Exponentiation&quot;,[&quot;NumberVariable&quot;,&quot;x&quot;],[&quot;Number&quot;,&quot;2&quot;]]]]</code></li>
</ul>
</li>
</ul>
<h3>correctly parses sentences of arithmetic and algebra</h3>
<ul>
<li>Test 1
<ul>
<li>input: LaTeX <code>t+u\ne t+v</code>, typeset $t+u\ne t+v$</li>
<li>output: JSON <code>[&quot;NotEqual&quot;,[&quot;Addition&quot;,[&quot;NumberVariable&quot;,&quot;t&quot;],[&quot;NumberVariable&quot;,&quot;u&quot;]],[&quot;Addition&quot;,[&quot;NumberVariable&quot;,&quot;t&quot;],[&quot;NumberVariable&quot;,&quot;v&quot;]]]</code></li>
</ul>
</li>
<li>Test 2
<ul>
<li>input: LaTeX <code>a\div{7+b}\approx0.75</code>, typeset $a\div{7+b}\approx0.75$</li>
<li>output: JSON <code>[&quot;BinaryRelationHolds&quot;,&quot;ApproximatelyEqual&quot;,[&quot;Division&quot;,[&quot;NumberVariable&quot;,&quot;a&quot;],[&quot;Addition&quot;,[&quot;Number&quot;,&quot;7&quot;],[&quot;NumberVariable&quot;,&quot;b&quot;]]],[&quot;Number&quot;,&quot;0.75&quot;]]</code></li>
</ul>
</li>
<li>Test 3
<ul>
<li>input: LaTeX <code>\frac{a}{7+b}\approx0.75</code>, typeset $\frac{a}{7+b}\approx0.75$</li>
<li>output: JSON <code>[&quot;BinaryRelationHolds&quot;,&quot;ApproximatelyEqual&quot;,[&quot;Division&quot;,[&quot;NumberVariable&quot;,&quot;a&quot;],[&quot;Addition&quot;,[&quot;Number&quot;,&quot;7&quot;],[&quot;NumberVariable&quot;,&quot;b&quot;]]],[&quot;Number&quot;,&quot;0.75&quot;]]</code></li>
</ul>
</li>
<li>Test 4
<ul>
<li>input: LaTeX <code>t^2\le10</code>, typeset $t^2\le10$</li>
<li>output: JSON <code>[&quot;LessThanOrEqual&quot;,[&quot;Exponentiation&quot;,[&quot;NumberVariable&quot;,&quot;t&quot;],[&quot;Number&quot;,&quot;2&quot;]],[&quot;Number&quot;,&quot;10&quot;]]</code></li>
</ul>
</li>
<li>Test 5
<ul>
<li>input: LaTeX <code>1+2+3\ge6</code>, typeset $1+2+3\ge6$</li>
<li>output: JSON <code>[&quot;GreaterThanOrEqual&quot;,[&quot;Addition&quot;,[&quot;Addition&quot;,[&quot;Number&quot;,&quot;1&quot;],[&quot;Number&quot;,&quot;2&quot;]],[&quot;Number&quot;,&quot;3&quot;]],[&quot;Number&quot;,&quot;6&quot;]]</code></li>
</ul>
</li>
<li>Test 6
<ul>
<li>input: LaTeX <code>\neg A+B=C^{D}</code>, typeset $\neg A+B=C^{D}$</li>
<li>output: JSON <code>[&quot;LogicalNegation&quot;,[&quot;Equals&quot;,[&quot;Addition&quot;,[&quot;NumberVariable&quot;,&quot;A&quot;],[&quot;NumberVariable&quot;,&quot;B&quot;]],[&quot;Exponentiation&quot;,[&quot;NumberVariable&quot;,&quot;C&quot;],[&quot;NumberVariable&quot;,&quot;D&quot;]]]]</code></li>
</ul>
</li>
<li>Test 7
<ul>
<li>input: LaTeX <code>\lnot\lnot x=x</code>, typeset $\lnot\lnot x=x$</li>
<li>output: JSON <code>[&quot;LogicalNegation&quot;,[&quot;LogicalNegation&quot;,[&quot;EqualFunctions&quot;,[&quot;FunctionVariable&quot;,&quot;x&quot;],[&quot;FunctionVariable&quot;,&quot;x&quot;]]]]</code></li>
</ul>
</li>
<li>Test 8
<ul>
<li>input: LaTeX <code>3\vert 9</code>, typeset $3\vert 9$</li>
<li>output: JSON <code>[&quot;BinaryRelationHolds&quot;,&quot;Divides&quot;,[&quot;Number&quot;,&quot;3&quot;],[&quot;Number&quot;,&quot;9&quot;]]</code></li>
</ul>
</li>
</ul>
<h3>correctly parses trigonometric function applications</h3>
<ul>
<li>Test 1
<ul>
<li>input: LaTeX <code>\cos x+1</code>, typeset $\cos x+1$</li>
<li>output: JSON <code>[&quot;Addition&quot;,[&quot;PrefixFunctionApplication&quot;,&quot;CosineFunction&quot;,[&quot;NumberVariable&quot;,&quot;x&quot;]],[&quot;Number&quot;,&quot;1&quot;]]</code></li>
</ul>
</li>
<li>Test 2
<ul>
<li>input: LaTeX <code>\cot\left(a-9.9\right)</code>, typeset $\cot\left(a-9.9\right)$</li>
<li>output: JSON <code>[&quot;PrefixFunctionApplication&quot;,&quot;CotangentFunction&quot;,[&quot;Subtraction&quot;,[&quot;NumberVariable&quot;,&quot;a&quot;],[&quot;Number&quot;,&quot;9.9&quot;]]]</code></li>
</ul>
</li>
<li>Test 3
<ul>
<li>input: LaTeX <code>\csc^{-1}\left(1+g\right)</code>, typeset $\csc^{-1}\left(1+g\right)$</li>
<li>output: JSON <code>[&quot;PrefixFunctionApplication&quot;,[&quot;PrefixFunctionInverse&quot;,&quot;CosecantFunction&quot;],[&quot;Addition&quot;,[&quot;Number&quot;,&quot;1&quot;],[&quot;NumberVariable&quot;,&quot;g&quot;]]]</code></li>
</ul>
</li>
</ul>
<h3>correctly parses factorials</h3>
<ul>
<li>Test 1
<ul>
<li>input: LaTeX <code>\left(W+R\right)!</code>, typeset $\left(W+R\right)!$</li>
<li>output: JSON <code>[&quot;Factorial&quot;,[&quot;Addition&quot;,[&quot;NumberVariable&quot;,&quot;W&quot;],[&quot;NumberVariable&quot;,&quot;R&quot;]]]</code></li>
</ul>
</li>
</ul>
<h3>correctly parses unusual implication symbols</h3>
<ul>
<li>Test 1
<ul>
<li>input: LaTeX <code>P\Rarr Q</code>, typeset $P\Rarr Q$</li>
<li>output: JSON <code>[&quot;Implication&quot;,[&quot;LogicVariable&quot;,&quot;P&quot;],[&quot;LogicVariable&quot;,&quot;Q&quot;]]</code></li>
</ul>
</li>
<li>Test 2
<ul>
<li>input: LaTeX <code>P\rArr Q</code>, typeset $P\rArr Q$</li>
<li>output: JSON <code>[&quot;Implication&quot;,[&quot;LogicVariable&quot;,&quot;P&quot;],[&quot;LogicVariable&quot;,&quot;Q&quot;]]</code></li>
</ul>
</li>
<li>Test 3
<ul>
<li>input: LaTeX <code>Q\Larr P</code>, typeset $Q\Larr P$</li>
<li>output: JSON <code>[&quot;Implication&quot;,[&quot;LogicVariable&quot;,&quot;P&quot;],[&quot;LogicVariable&quot;,&quot;Q&quot;]]</code></li>
</ul>
</li>
<li>Test 4
<ul>
<li>input: LaTeX <code>Q\lArr P</code>, typeset $Q\lArr P$</li>
<li>output: JSON <code>[&quot;Implication&quot;,[&quot;LogicVariable&quot;,&quot;P&quot;],[&quot;LogicVariable&quot;,&quot;Q&quot;]]</code></li>
</ul>
</li>
<li>Test 5
<ul>
<li>input: LaTeX <code>P\lrArr Q</code>, typeset $P\lrArr Q$</li>
<li>output: JSON <code>[&quot;LogicalEquivalence&quot;,[&quot;LogicVariable&quot;,&quot;P&quot;],[&quot;LogicVariable&quot;,&quot;Q&quot;]]</code></li>
</ul>
</li>
<li>Test 6
<ul>
<li>input: LaTeX <code>P\Lrarr Q</code>, typeset $P\Lrarr Q$</li>
<li>output: JSON <code>[&quot;LogicalEquivalence&quot;,[&quot;LogicVariable&quot;,&quot;P&quot;],[&quot;LogicVariable&quot;,&quot;Q&quot;]]</code></li>
</ul>
</li>
</ul>
<h3>correctly parses unusual set theory notation</h3>
<ul>
<li>Test 1
<ul>
<li>input: LaTeX <code>(A\cup B)^{\complement}</code>, typeset $(A\cup B)^{\complement}$</li>
<li>output: JSON <code>[&quot;SetComplement&quot;,[&quot;SetUnion&quot;,[&quot;SetVariable&quot;,&quot;A&quot;],[&quot;SetVariable&quot;,&quot;B&quot;]]]</code></li>
</ul>
</li>
</ul>
<h3>correctly parses unusual function signature notation</h3>
<ul>
<li>Test 1
<ul>
<li>input: LaTeX <code>f:A\rarr B</code>, typeset $f:A\rarr B$</li>
<li>output: JSON <code>[&quot;FunctionSignature&quot;,[&quot;FunctionVariable&quot;,&quot;f&quot;],[&quot;SetVariable&quot;,&quot;A&quot;],[&quot;SetVariable&quot;,&quot;B&quot;]]</code></li>
</ul>
</li>
<li>Test 2
<ul>
<li>input: LaTeX <code>f\colon A\rarr B</code>, typeset $f\colon A\rarr B$</li>
<li>output: JSON <code>[&quot;FunctionSignature&quot;,[&quot;FunctionVariable&quot;,&quot;f&quot;],[&quot;SetVariable&quot;,&quot;A&quot;],[&quot;SetVariable&quot;,&quot;B&quot;]]</code></li>
</ul>
</li>
</ul>
</article>

</section>

  </div>
</main>

<footer class="layout-footer">
  <div class="container">
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.6.11</a>
  </div>
</footer>



<script src="scripts/prism.dev.js"></script>
</body>
</html>