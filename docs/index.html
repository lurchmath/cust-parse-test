<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>Customizable Parsing Test Repository: </title>
    
      <link type="text/css" rel="stylesheet" href="styles/vendor/prism-default.css">
    
    <link type="text/css" rel="stylesheet" href="styles/styles.css">
    
    
    <style>
      :root {
      
      
        --nav-width: 335px;
      
      }
    </style>
    

<script>
    MathJax = { tex: { inlineMath: [['$', '$'], ['\\(', '\\)']] } };
</script>
<script id="MathJax-script" async
        src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js">
</script>
</head>
<body>

<header class="layout-header">
  
  <h1>
    <a href="./index.html">
      Customizable Parsing Test Repository
    </a>
  </h1>
  <nav class="layout-nav">
    <ul><li class="nav-heading">Tutorials</li><li class="nav-item"><a href="tutorial-Test Results.html">Test Results</a></li></ul><ul><li class="nav-heading">Classes</li><li class="nav-heading"><span class="nav-item-type type-class" title="class">C</span><span class="nav-item-name is-class"><a href="AST.html">AST</a></span></li><li class="nav-item"><span class="nav-item-type type-function" title="function">F</span><span class="nav-item-name is-function"><a href="AST.html#.fromJSON">fromJSON</a></span></li><li class="nav-item"><span class="nav-item-type type-function" title="function">F</span><span class="nav-item-name is-function"><a href="AST.html#arg">arg</a></span></li><li class="nav-item"><span class="nav-item-type type-function" title="function">F</span><span class="nav-item-name is-function"><a href="AST.html#args">args</a></span></li><li class="nav-item"><span class="nav-item-type type-function" title="function">F</span><span class="nav-item-name is-function"><a href="AST.html#associatesCorrectly">associatesCorrectly</a></span></li><li class="nav-item"><span class="nav-item-type type-function" title="function">F</span><span class="nav-item-name is-function"><a href="AST.html#concept">concept</a></span></li><li class="nav-item"><span class="nav-item-type type-function" title="function">F</span><span class="nav-item-name is-function"><a href="AST.html#head">head</a></span></li><li class="nav-item"><span class="nav-item-type type-function" title="function">F</span><span class="nav-item-name is-function"><a href="AST.html#isCompound">isCompound</a></span></li><li class="nav-item"><span class="nav-item-type type-function" title="function">F</span><span class="nav-item-name is-function"><a href="AST.html#isConcept">isConcept</a></span></li><li class="nav-item"><span class="nav-item-type type-function" title="function">F</span><span class="nav-item-name is-function"><a href="AST.html#isLeaf">isLeaf</a></span></li><li class="nav-item"><span class="nav-item-type type-function" title="function">F</span><span class="nav-item-name is-function"><a href="AST.html#numArgs">numArgs</a></span></li><li class="nav-item"><span class="nav-item-type type-function" title="function">F</span><span class="nav-item-name is-function"><a href="AST.html#toJSON">toJSON</a></span></li><li class="nav-item"><span class="nav-item-type type-function" title="function">F</span><span class="nav-item-name is-function"><a href="AST.html#toLanguage">toLanguage</a></span></li><li class="nav-item"><span class="nav-item-type type-function" title="function">F</span><span class="nav-item-name is-function"><a href="AST.html#toString">toString</a></span></li><li class="nav-heading"><span class="nav-item-type type-class" title="class">C</span><span class="nav-item-name is-class"><a href="Converter.html">Converter</a></span></li><li class="nav-item"><span class="nav-item-type type-function" title="function">F</span><span class="nav-item-name is-function"><a href="Converter.html#addBuiltIns">addBuiltIns</a></span></li><li class="nav-item"><span class="nav-item-type type-function" title="function">F</span><span class="nav-item-name is-function"><a href="Converter.html#addConcept">addConcept</a></span></li><li class="nav-item"><span class="nav-item-type type-function" title="function">F</span><span class="nav-item-name is-function"><a href="Converter.html#concept">concept</a></span></li><li class="nav-item"><span class="nav-item-type type-function" title="function">F</span><span class="nav-item-name is-function"><a href="Converter.html#convert">convert</a></span></li><li class="nav-item"><span class="nav-item-type type-function" title="function">F</span><span class="nav-item-name is-function"><a href="Converter.html#isConcept">isConcept</a></span></li><li class="nav-item"><span class="nav-item-type type-function" title="function">F</span><span class="nav-item-name is-function"><a href="Converter.html#isLanguage">isLanguage</a></span></li><li class="nav-item"><span class="nav-item-type type-function" title="function">F</span><span class="nav-item-name is-function"><a href="Converter.html#language">language</a></span></li><li class="nav-heading"><span class="nav-item-type type-class" title="class">C</span><span class="nav-item-name is-class"><a href="Language.html">Language</a></span></li><li class="nav-item"><span class="nav-item-type type-member" title="member">M</span><span class="nav-item-name is-member"><a href="Language.html#regularExpressions">regularExpressions</a></span></li><li class="nav-item"><span class="nav-item-type type-function" title="function">F</span><span class="nav-item-name is-function"><a href="Language.html#.fromJSON">fromJSON</a></span></li><li class="nav-item"><span class="nav-item-type type-function" title="function">F</span><span class="nav-item-name is-function"><a href="Language.html#addNotation">addNotation</a></span></li><li class="nav-item"><span class="nav-item-type type-function" title="function">F</span><span class="nav-item-name is-function"><a href="Language.html#convertTo">convertTo</a></span></li><li class="nav-item"><span class="nav-item-type type-function" title="function">F</span><span class="nav-item-name is-function"><a href="Language.html#parse">parse</a></span></li><li class="nav-item"><span class="nav-item-type type-function" title="function">F</span><span class="nav-item-name is-function"><a href="Language.html#rulesFor">rulesFor</a></span></li><li class="nav-heading"><span class="nav-item-type type-class" title="class">C</span><span class="nav-item-name is-class"><a href="Template.html">Template</a></span></li><li class="nav-item"><span class="nav-item-type type-member" title="member">M</span><span class="nav-item-name is-member"><a href="Template.html#defaultVariableNames">defaultVariableNames</a></span></li><li class="nav-item"><span class="nav-item-type type-function" title="function">F</span><span class="nav-item-name is-function"><a href="Template.html#arity">arity</a></span></li><li class="nav-item"><span class="nav-item-type type-function" title="function">F</span><span class="nav-item-name is-function"><a href="Template.html#fillIn">fillIn</a></span></li><li class="nav-item"><span class="nav-item-type type-function" title="function">F</span><span class="nav-item-name is-function"><a href="Template.html#toString">toString</a></span></li></ul><ul><li class="nav-heading">Modules</li><li class="nav-heading"><span class="nav-item-type type-module" title="module">M</span><span class="nav-item-name is-module"><a href="module-BuiltInConcepts.html">BuiltInConcepts</a></span></li><li class="nav-item"><span class="nav-item-type type-member" title="member">M</span><span class="nav-item-name is-member"><a href="module-BuiltInConcepts.html#.builtInConcepts">builtInConcepts</a></span></li><li class="nav-heading"><span class="nav-item-type type-module" title="module">M</span><span class="nav-item-name is-module"><a href="module-ExampleConverter.html">ExampleConverter</a></span></li><li class="nav-item"><span class="nav-item-type type-member" title="member">M</span><span class="nav-item-name is-member"><a href="module-ExampleConverter.html#.converter">converter</a></span></li><li class="nav-heading"><span class="nav-item-type type-module" title="module">M</span><span class="nav-item-name is-module"><a href="module-LatexNotation.html">LatexNotation</a></span></li><li class="nav-item"><span class="nav-item-type type-member" title="member">M</span><span class="nav-item-name is-member"><a href="module-LatexNotation.html#.latexNotation">latexNotation</a></span></li><li class="nav-heading"><span class="nav-item-type type-module" title="module">M</span><span class="nav-item-name is-module"><a href="module-SyntacticTypes.html">SyntacticTypes</a></span></li><li class="nav-item"><span class="nav-item-type type-member" title="member">M</span><span class="nav-item-name is-member"><a href="module-SyntacticTypes.html#.hierarchies">hierarchies</a></span></li><li class="nav-item"><span class="nav-item-type type-member" title="member">M</span><span class="nav-item-name is-member"><a href="module-SyntacticTypes.html#.isAtomic">isAtomic</a></span></li><li class="nav-item"><span class="nav-item-type type-member" title="member">M</span><span class="nav-item-name is-member"><a href="module-SyntacticTypes.html#.isSupertype">isSupertype</a></span></li><li class="nav-item"><span class="nav-item-type type-member" title="member">M</span><span class="nav-item-name is-member"><a href="module-SyntacticTypes.html#.isSupertypeOrEqual">isSupertypeOrEqual</a></span></li><li class="nav-item"><span class="nav-item-type type-member" title="member">M</span><span class="nav-item-name is-member"><a href="module-SyntacticTypes.html#.lowestSubtype">lowestSubtype</a></span></li><li class="nav-item"><span class="nav-item-type type-member" title="member">M</span><span class="nav-item-name is-member"><a href="module-SyntacticTypes.html#.types">types</a></span></li></ul><li class="nav-heading"><a href="global.html">Globals</a></li><li class="nav-item"><span class="nav-item-type type-member" title="member">M</span><span class="nav-item-name is-member"><a href="global.html#escapeRegExp">escapeRegExp</a></span></li><li class="nav-item"><span class="nav-item-type type-member" title="member">M</span><span class="nav-item-name is-member"><a href="global.html#notationStringToArray">notationStringToArray</a></span></li><li class="nav-item"><span class="nav-item-type type-member" title="member">M</span><span class="nav-item-name is-member"><a href="global.html#putdownLeaves">putdownLeaves</a></span></li>
  </nav>
</header>


<main class="layout-main ">
  <div class="container">
    <p class="page-kind"></p>
    <h1 class="page-title"></h1>
    



    


    <h3> </h3>










    




    <section class="readme">
        <article><h2>Customizable Parsing Test Repository</h2>
<p>(This is marked as a &quot;test&quot; repository because it is not yet used in the online
app for which it is intended.  We are finishing testing it and then will
incorporate it thereafter.)</p>
<h3>Goal</h3>
<p>This repository attempts to provide a very easy-to-use interface for defining
context-free languages, and an API for applying the Earley parsing algorithm to
expressions in those languages, to convert them into syntax trees (ASTs).</p>
<p>We want users of <a href="https://lurchmath.github.io">the Lurch application</a> to be
able to define their own notation for whatever concepts they use, and thus we
want to provide them with an easy-to-understand UI for doing so.  Such a UI must
therefore be backed by a corresponding API that can convert its content into a
definition for a parser that accomplishes the user's intended goals.</p>
<p>When we say &quot;an easy-to-understand UI,&quot; we mean that the user should not be
writing grammar rules in the usual computer science notation, such as
<code>sum -&gt; summand &quot;+&quot; summand</code>, nor should they be burdened with defining regular
expressions for atomic tokens, nor sequencing the definition of their language
to ensure the correct precedence.  Furthermore, a user who defines multiple
languages for the same set of concepts should expect the system to be able to
translate between any two languages (and ASTs).  And finally, the user
should never have to specify how to write expressions in Lurch's internal
notation (called &quot;putdown&quot;) but that benefit should come automatically and
invisibly by using this system.</p>
<h3>How it works</h3>
<p>There is a set of built-in concepts that were selected because they commonly
appear in introduction-to-proof courses, which is the intended use of Lurch.
They are defined in the <a href="module-BuiltInConcepts.html">built-in concepts module</a>.
The most common LaTeX notation for each is defined in the
<a href="module-LatexNotation.html">LaTeX notation module</a>.  All of those definitions
are brought together into the <a href="module-ExampleConverter.html">example converter</a>,
which is used in most of the unit tests in this repository.</p>
<p>A client who wants a different parser, converter, or language, can provide a
subset (or completely different version) of the JSON data defined in those
modules, which will result in a different converter for a different set of
concepts.  This leads to great flexibility.</p>
<h3>Assumptions and limitations</h3>
<p>There are a few assumptions built into the technology in this repository.</p>
<ul>
<li>Whitespace is not meaningful in any language.  For example, if you define
<code>A+B</code> to be the notation for addition, <code>A + B</code> will also be accepted, as will
input with any number of spaces before/after the <code>A</code>, <code>+</code>, and <code>B</code>.</li>
<li>If you ask for the meaning of a piece of text, and its meaning is ambiguous,
then it is acceptable to return to you any one of the possible meanings.  In
particular, the current implementation returns the one whose
<a href="AST.html#toString">string representation</a> is first in alphabetical order.</li>
<li>Atomic concepts are written the same way in every language.  For example, if
variables are one Roman letter in putdown, then they are also one Roman
letter in LaTeX, and anywhere else.  Similarly, if integers are a sequence of
Arabic numerals, then that's what they are in all languages.</li>
</ul>
<p>The current version has the following limitations.</p>
<ul>
<li>Not all common mathematical concepts are yet added to
<a href="module-BuiltInConcepts.html">the built-in concepts module</a>.  In particular,
we do not yet support the following.
<ul>
<li>Intervals on the real line, such as <code>(1,2)</code>, <code>[1,2]</code>, <code>[1,2)</code>, or <code>(1,2]</code></li>
<li>Absolute values, which are often written <code>|...|</code> or in LaTeX using
<code>\vert...\vert</code> (which is what MathLive uses, sometimes with
<code>\left\vert...\right\vert</code>)</li>
<li>Norms/distances, which are often written <code>||...||</code> or in LaTeX using
<code>\Vert...\Vert</code> (which is what MathLive uses, sometimes with
<code>\left\Vert...\right\Vert</code>)</li>
<li>Greek or Hebrew letters, neither upper nor lower case, nor variants</li>
<li>Inverse trig functions are supported only by taking a trig function and
adding an inverse marker, as in <code>\sin^{-1}</code> in LaTeX.  There are no atomic
symbols like <code>asin</code> or <code>arcsin</code> at present, since it did not seem needed
for testing, and would clutter things up with a dozen or so extra symbols.</li>
</ul>
</li>
<li>LaTeX is a complex language that breaks arguments sometimes at the level of
individual characters, so that <code>\frac12</code> means <code>\frac{1}{2}</code>.  The tokenizer
in this repository always treats <code>12</code> as twelve, never as two parts, so it
cannot handle input such as <code>\frac12</code>, which can be created by other tools we
may want to use, such as MathLive.</li>
<li>If this parser is used to process output from MathLive, then the default
on-screen keyboard should be reduced to prevent the user from entering
symbols that are not currently understood.  See the <code>plan.md</code> file in the
repository for details on which MathLive symbols are not supported.</li>
</ul>
<h3>For more information</h3>
<p>To see the built-in concepts and default LaTeX notation for them, refer to the
three modules linked to in the previous section.</p>
<p>To learn a few other foundational concepts for how this repository views the
type hierarchy of its concepts, see the documentation for
<a href="Converter.html">the Converter class</a>.</p>
<p>To learn more of how these tools function under the hood, dive into the
implementations of <a href="AST.html">abstract syntax trees</a> and <a href="Language.html">languages</a>.</p>
<p>To see a readable summary of the (huge) set of tests that are currently
implemented in the test suite of this repository, so that you can browse the
behavior of <a href="module-ExampleConverter.html">the example converter</a>, see
the <a href="tutorial-Test Results.html">Test Results</a> page.</p>
<h3>Extending unit tests</h3>
<p>If you work on this repository and add a new concept to the set of built-in
concepts, you should also add corresponding unit tests.  I suggest the following
workflow when doing so.</p>
<ol>
<li>Edit the <code>built-in-concepts.js</code> file and add a new entry for your concept.</li>
<li>Edit <code>test-parsing-putdown.js</code> and add a new test case (a new call to
<code>it()</code>) to verify that the putdown form you specified in the concept's
definition can be parsed.
<ul>
<li>Definitely include a simple case, such as <code>(+ 1 2)</code> for addition.</li>
<li>Optionally include a complex case, such as nesting your expression inside
another, or nesting others inside yours.</li>
</ul>
</li>
<li>Edit <code>test-creating-putdown.js</code> and add a new test case (a new call to
<code>it()</code>) to verify that the putdown form you specified in the concept's
definition can be rendered.  The easiest way to do this is to take whatever
new tests you just added in step 2, above, and reverse the order of their
arguments.  I.e., calls to <code>check(putdown,json)</code> become calls to
<code>check(json,putdown)</code>.</li>
<li>Edit the <code>latex-notation.js</code> file and add at least one new entry for the
concept you just added (and just tested in its putdown form).  Some concepts
can be expressed using multiple LaTeX notations, and you may therefore need
to add multiple new entries to that file, one for each such notation.</li>
<li>Edit <code>test-parsing-latex.js</code> and add a new test case (a new call to <code>it()</code>)
to verify each of the LaTeX notation(s) you just introduced can be parsed.
As when testing putdown form, you should test simple cases and complex cases
as well for each valid LaTeX notation you defined.  Because LaTeX is a more
complex parsing situation than putdown, be sure to place your new notation
near various other operators so that their relative precedence gets tested.</li>
<li>Edit <code>test-creating-latex.js</code> and add a new test case (a new call to
<code>it()</code>) to verify that the LaTeX notation you specified in the concept's
definition can be rendered.  You cannot just take all the new tests you
added in step 5, above, and reverse them, like you did in step 3 for
putdown.  The reason is that the first LaTeX notation you provide for a new
concept will be the default one for rendering, and none of the others will
ever be used.</li>
<li>Edit <code>test-putdown-to-latex.js</code> and add a new test case (a new call to
<code>it()</code>) that composes the tests you created in steps 2 and 6, above,
ensuring that you can go from putdown to LaTeX in one step.  Again, the
first LaTeX notation for any given concept is the one the converter will use
for rendering.</li>
<li>Edit <code>test-latex-to-putdown.js</code> and add a new test case (a new call to
<code>it()</code>) that composes the tests you created in steps 5 and 3, above, in that
order, ensuring that you can go from LaTeX to putdown in one step.  In this
case, you should test that all LaTeX notations are accepted and get
converted to the same putdown output.</li>
</ol></article>
    </section>






  </div>
</main>

<footer class="layout-footer">
  <div class="container">
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.6.11</a>
  </div>
</footer>



<script src="scripts/prism.dev.js"></script>
</body>
</html>