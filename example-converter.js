
import { Converter } from './converter.js'
import { Language } from './language.js'

export const converter = new Converter()

converter.addConcept( 'numbervariable',  'atomicnumberexpr', Language.regularExpressions.oneLetterVariable )
converter.addConcept( 'number',          'atomicnumberexpr', Language.regularExpressions.nonnegativeNumber )
converter.addConcept( 'infinity',        'atomicnumberexpr' )
converter.addConcept( 'pi',              'atomicnumberexpr' )
converter.addConcept( 'eulersnumber',    'atomicnumberexpr' )

converter.addConcept( 'exponentiation',  'factorexpr',       '(^ atomicnumberexpr atomicnumberexpr)' )
converter.addConcept( 'percentage',      'factorexpr',       '(% atomicnumberexpr)' )
converter.addConcept( 'factorial',       'factorexpr',       '(! atomicnumberexpr)' )
converter.addConcept( 'division',        'prodexpr',         '(/ prodexpr prodexpr)' )
converter.addConcept( 'multiplication',  'prodexpr',         '(* prodexpr prodexpr)' )
converter.addConcept( 'numbernegation',  'prodexpr',         '(- prodexpr)' )

converter.addConcept( 'addition',        'sumexpr',          '(+ sumexpr sumexpr)' )
converter.addConcept( 'subtraction',     'sumexpr',          '(- sumexpr sumexpr)' )

converter.addConcept( 'logicvariable',   'atomicpropexpr',   Language.regularExpressions.oneLetterVariable )
converter.addConcept( 'logicaltrue',     'atomicpropexpr',   'true' )
converter.addConcept( 'logicalfalse',    'atomicpropexpr',   'false' )
converter.addConcept( 'contradiction',   'atomicpropexpr',   'contradiction' )

converter.addConcept( 'logicnegation',   'atomicpropexpr',   '(not atomicpropexpr)' )
converter.addConcept( 'conjunction',     'conjunctexpr',     '(and conjunctexpr conjunctexpr)' )
converter.addConcept( 'disjunction',     'disjunctexpr',     '(or disjunctexpr disjunctexpr)' )
converter.addConcept( 'implication',     'condexpr',         '(implies condexpr condexpr)' )
converter.addConcept( 'iff',             'condexpr',         '(iff condexpr condexpr)' )

converter.addConcept( 'universal',       'sentenceexpr',     '(forall (numbervariable , sentenceexpr))' )
converter.addConcept( 'existential',     'sentenceexpr',     '(exists (numbervariable , sentenceexpr))' )
converter.addConcept( 'existsunique',    'sentenceexpr',     '(existsunique (numbervariable , sentenceexpr))' )

converter.addConcept( 'setvariable',     'atomicsetexpr',    Language.regularExpressions.oneLetterVariable )

converter.addConcept( 'oneeltseq',       'sequenceexpr',     '(elts nounexpr)' )
converter.addConcept( 'eltthenseq',      'sequenceexpr',     '(elts nounexpr sequenceexpr)' )
converter.addConcept( 'finiteset',       'atomicsetexpr',    '(finiteset sequenceexpr)' )
converter.addConcept( 'emptyset',        'atomicsetexpr',    'emptyset' )

converter.addConcept( 'intersection',    'setexpr',          '(setint intersectionexpr intersectionexpr)' )
converter.addConcept( 'setdifference',   'setexpr',          '(setminus intersectionexpr intersectionexpr)' )
converter.addConcept( 'union',           'setexpr',          '(setuni unionexpr unionexpr)' )
converter.addConcept( 'complement',      'intersectionexpr', '(setcomp atomicsetexpr)' )
converter.addConcept( 'setproduct',      'intersectionexpr', '(setprod atomicsetexpr atomicsetexpr)' )

converter.addConcept( 'subset',          'atomicpropexpr',   '(subset setexpr setexpr)' )
converter.addConcept( 'subseteq',        'atomicpropexpr',   '(subseteq setexpr setexpr)' )
converter.addConcept( 'nounisin',        'atomicpropexpr',   '(in nounexpr setexpr)' )
converter.addConcept( 'propisin',        'atomicpropexpr',   '(in atomicpropexpr setexpr)' )
converter.addConcept( 'nounisnotin',     'atomicpropexpr',   '(not (in nounexpr setexpr))', { primitive : false } )
converter.addConcept( 'propisnotin',     'atomicpropexpr',   '(not (in condexpr setexpr))', { primitive : false } )

converter.addConcept( 'tuple',           'tupleexpr',        '(tuple eltthenseq)' )
converter.addConcept( 'onenumseq',       'numsequenceexpr',  '(elts numberexpr)' )
converter.addConcept( 'numthenseq',      'numsequenceexpr',  '(elts numberexpr numsequenceexpr)' )
converter.addConcept( 'vector',          'tupleexpr',        '(vector numthenseq)' )

converter.addConcept( 'funcvariable',    'atomicfuncexpr',   Language.regularExpressions.oneLetterVariable )
converter.addConcept( 'funcsignature',   'atomicpropexpr',   '(function funcexpr setexpr setexpr)' )
converter.addConcept( 'prefixfuncapp',   'factorexpr',       '(apply prefixfuncexpr numberexpr)' )
converter.addConcept( 'numfuncapp',      'factorexpr',       '(apply funcexpr nounexpr)' )
converter.addConcept( 'propfuncapp',     'atomicpropexpr',   '(apply funcexpr nounexpr)' )
converter.addConcept( 'setfuncapp',      'atomicsetexpr',    '(apply funcexpr nounexpr)' )
converter.addConcept( 'funccomp',        'funcexpr',         '(compose funcexpr funcexpr)' )
converter.addConcept( 'funcinverse',     'funcexpr',         '(inverse funcexpr)' )

converter.addConcept( 'sinfunc',         'prefixfuncexpr',   'sin' )
converter.addConcept( 'cosfunc',         'prefixfuncexpr',   'cos' )
converter.addConcept( 'tanfunc',         'prefixfuncexpr',   'tan' )
converter.addConcept( 'cotfunc',         'prefixfuncexpr',   'cot' )
converter.addConcept( 'secfunc',         'prefixfuncexpr',   'sec' )
converter.addConcept( 'cscfunc',         'prefixfuncexpr',   'csc' )

converter.addConcept( 'logarithm',       'prefixfuncexpr',   'log' )
converter.addConcept( 'naturallog',      'prefixfuncexpr',   'ln' )
converter.addConcept( 'logwithbase',     'prefixfuncexpr',   '(logbase numberexpr)' )

converter.addConcept( 'equality',        'atomicpropexpr',   '(= nounexpr nounexpr)' )
converter.addConcept( 'funcequality',    'atomicpropexpr',   '(= funcexpr funcexpr)' )
converter.addConcept( 'inequality',      'atomicpropexpr',   '(not (= nounexpr nounexpr))', { primitive : false } )
converter.addConcept( 'funcinequality',  'atomicpropexpr',   '(not (= funcexpr funcexpr))', { primitive : false } )
converter.addConcept( 'lessthan',        'atomicpropexpr',   '(< nounexpr nounexpr)' )
converter.addConcept( 'lessthanoreq',    'atomicpropexpr',   '(<= nounexpr nounexpr)' )
converter.addConcept( 'greaterthan',     'atomicpropexpr',   '(> nounexpr nounexpr)' )
converter.addConcept( 'greaterthanoreq', 'atomicpropexpr',   '(>= nounexpr nounexpr)' )

converter.addConcept( 'divisibility',    'binaryrelation',   '|' )
converter.addConcept( 'genericrelation', 'binaryrelation',   '~' )
converter.addConcept( 'approximately',   'binaryrelation',   '~~' )
converter.addConcept( 'binrelapp',       'atomicpropexpr',   '(applyrel binaryrelation nounexpr nounexpr)' )
converter.addConcept( 'equivmodulo',     'atomicpropexpr',   '(=mod numberexpr numberexpr numberexpr)' )

converter.addConcept( 'equivclass',      'atomicsetexpr',    '(eqclass nounexpr binaryrelation)' )
converter.addConcept( 'bareequivclass',  'atomicsetexpr',    '(eqclass nounexpr ~)' )
converter.addConcept( 'eqmodclass',      'atomicsetexpr',    '(modclass numberexpr numberexpr)' )

converter.addConcept( 'settype',         'typephrase',       'settype' )
converter.addConcept( 'numbertype',      'typephrase',       'numbertype' )
converter.addConcept( 'reltype',         'typephrase',       'relationtype' )
converter.addConcept( 'partialordtype',  'typephrase',       'partialordertype' )
converter.addConcept( 'equivreltype',    'typephrase',       'equivalencerelationtype' )

converter.addConcept( 'hastype',         'atomicpropexpr',   '(hastype nounexpr typephrase)' )

converter.addConcept( 'numefa',          'factorexpr',       '(efa funcexpr nounexpr)' )
converter.addConcept( 'propefa',         'atomicpropexpr',   '(efa funcexpr nounexpr)' )
converter.addConcept( 'setefa',          'atomicsetexpr',    '(efa funcexpr nounexpr)' )

converter.addConcept( 'givenvariant1',   'expr',             ':sentenceexpr' )
converter.addConcept( 'givenvariant2',   'expr',             ':sentenceexpr', { primitive : false } )
converter.addConcept( 'givenvariant3',   'expr',             ':sentenceexpr', { primitive : false } )
converter.addConcept( 'givenvariant4',   'expr',             ':sentenceexpr', { primitive : false } )
converter.addConcept( 'letvariant1',     'expr',             ':[numbervariable]' )
converter.addConcept( 'letvariant2',     'expr',             ':[numbervariable]', { primitive : false } )
converter.addConcept( 'letbevariant1',   'expr',             ':[numbervariable , sentenceexpr]' )
converter.addConcept( 'letbevariant2',   'expr',             ':[numbervariable , sentenceexpr]', { primitive : false } )
converter.addConcept( 'forsomevariant1', 'expr',             '[numbervariable , sentenceexpr]' )
converter.addConcept( 'forsomevariant2', 'expr',             '[numbervariable , sentenceexpr]', { primitive : false } )
converter.addConcept( 'forsomevariant3', 'expr',             '[numbervariable , sentenceexpr]', { primitive : false } )
converter.addConcept( 'forsomevariant4', 'expr',             '[numbervariable , sentenceexpr]', { primitive : false } )

const latex = new Language( 'latex', converter, [
    '{', '}',
    '(', ')',
    '\\left(', '\\right)',
] )

latex.addNotation( 'infinity',        '\\infty' )
latex.addNotation( 'pi',              '\\pi' )
latex.addNotation( 'eulersnumber',    'e' )

latex.addNotation( 'exponentiation',  'A^B' )
latex.addNotation( 'percentage',      'A\\%' )
latex.addNotation( 'factorial',       'A!' )

latex.addNotation( 'division',        'A\\div B' )
latex.addNotation( 'multiplication',  'A\\times B' )
latex.addNotation( 'multiplication',  'A\\cdot B' )
latex.addNotation( 'numbernegation',  '-A' )

latex.addNotation( 'addition',        'A+B' )
latex.addNotation( 'subtraction',     'A-B' )

latex.addNotation( 'logicaltrue',     '\\top' )
latex.addNotation( 'logicalfalse',    '\\bot' )
latex.addNotation( 'contradiction',   '\\rightarrow \\leftarrow' )

latex.addNotation( 'logicnegation',   '\\neg A' )
latex.addNotation( 'logicnegation',   '\\lnot A' )
latex.addNotation( 'conjunction',     'A\\wedge B' )
latex.addNotation( 'conjunction',     'A\\land B' )
latex.addNotation( 'disjunction',     'A\\vee B' )
latex.addNotation( 'disjunction',     'A\\lor B' )
latex.addNotation( 'implication',     'A\\Rightarrow B' )
latex.addNotation( 'implication',     'B\\Leftarrow A' )
latex.addNotation( 'iff',             'A\\Leftrightarrow B' )

latex.addNotation( 'universal',       '\\forall A, B' )
latex.addNotation( 'existential',     '\\exists A, B' )
latex.addNotation( 'existsunique',    '\\exists ! A, B' )

latex.addNotation( 'emptyset',        '\\emptyset' )
latex.addNotation( 'emptyset',        '\\{ \\}' )
latex.addNotation( 'emptyset',        '\\left\\{ \\right\\}' )
latex.addNotation( 'finiteset',       '\\{A\\}' )
latex.addNotation( 'finiteset',       '\\left\\{A\\right\\}' )
latex.addNotation( 'oneeltseq',       'A' )
latex.addNotation( 'eltthenseq',      'A,B' )
latex.addNotation( 'onenumseq',       'A' )
latex.addNotation( 'numthenseq',      'A,B' )

latex.addNotation( 'union',           'A\\cup B' )
latex.addNotation( 'intersection',    'A\\cap B' )
latex.addNotation( 'setdifference',   'A\\setminus B' )
latex.addNotation( 'setdifference',   'A-B' )
latex.addNotation( 'complement',      '\\bar A' )
latex.addNotation( 'complement',      'A\'' )
latex.addNotation( 'setproduct',      'A\\times B' )

latex.addNotation( 'subset',          'A\\subset B' )
latex.addNotation( 'subseteq',        'A\\subseteq B' )
latex.addNotation( 'nounisin',        'A\\in B' )
latex.addNotation( 'propisin',        'A\\in B' )
latex.addNotation( 'nounisnotin',     'A\\notin B' )
latex.addNotation( 'propisnotin',     'A\\notin B' )

latex.addNotation( 'tuple',           '(A)' )
latex.addNotation( 'vector',          '\\langle A\\rangle' )

latex.addNotation( 'funcsignature',   'A:B\\to C' )
latex.addNotation( 'funcsignature',   'A:B\\rightarrow C' )
latex.addNotation( 'funcsignature',   'A\\colon B\\to C' )
latex.addNotation( 'funcsignature',   'A\\colon B\\rightarrow C' )
latex.addNotation( 'prefixfuncapp',   'A B' )
latex.addNotation( 'numfuncapp',      'A(B)' )
latex.addNotation( 'propfuncapp',     'A(B)' )
latex.addNotation( 'setfuncapp',      'A(B)' )
latex.addNotation( 'funccomp',        'A\\circ B' )
latex.addNotation( 'funcinverse',     'A ^ { - 1 }' )

latex.addNotation( 'sinfunc',         '\\sin' )
latex.addNotation( 'cosfunc',         '\\cos' )
latex.addNotation( 'tanfunc',         '\\tan' )
latex.addNotation( 'cotfunc',         '\\cot' )
latex.addNotation( 'secfunc',         '\\sec' )
latex.addNotation( 'cscfunc',         '\\csc' )

latex.addNotation( 'logarithm',       '\\log' )
latex.addNotation( 'naturallog',      '\\ln' )
latex.addNotation( 'logwithbase',     '\\log_A' )

latex.addNotation( 'equality',        'A=B' )
latex.addNotation( 'inequality',      'A\\ne B' )
latex.addNotation( 'inequality',      'A\\neq B' )
latex.addNotation( 'funcequality',    'A=B' )
latex.addNotation( 'funcinequality',  'A\\ne B' )
latex.addNotation( 'funcinequality',  'A\\neq B' )
latex.addNotation( 'lessthan',        'A<B' )
latex.addNotation( 'lessthan',        'A\\lt B' )
latex.addNotation( 'lessthanoreq',    'A\\le B' )
latex.addNotation( 'lessthanoreq',    'A\\leq B' )
latex.addNotation( 'greaterthan',     'A>B' )
latex.addNotation( 'greaterthan',     'A\\gt B' )
latex.addNotation( 'greaterthanoreq', 'A\\ge B' )
latex.addNotation( 'greaterthanoreq', 'A\\geq B' )

latex.addNotation( 'binrelapp',       'B A C' )
latex.addNotation( 'divisibility',    '|' )
latex.addNotation( 'approximately',   '\\approx' )
latex.addNotation( 'genericrelation', '\\sim' )
latex.addNotation( 'equivmodulo',     'A \\equiv B \\mod C' )
latex.addNotation( 'equivmodulo',     'A \\equiv _ C B' )

latex.addNotation( 'equivclass',      '[A,B]' )
latex.addNotation( 'equivclass',      '\\left[A,B\\right]' )
latex.addNotation( 'bareequivclass',  '[A]' )
latex.addNotation( 'bareequivclass',  '\\left[A\\right]' )
latex.addNotation( 'eqmodclass',      '[A, \\equiv _ B]' )
latex.addNotation( 'eqmodclass',      '\\left[A, \\equiv _ B\\right]' )

latex.addNotation( 'settype',         'a set' )
latex.addNotation( 'numbertype',      'a number' )
latex.addNotation( 'reltype',         'a relation' )
latex.addNotation( 'partialordtype',  'a partial order' )
latex.addNotation( 'equivreltype',    'an equivalence relation' )

latex.addNotation( 'hastype',         'A \\text{is B}' )
latex.addNotation( 'hastype',         'A \\text{is } \\text{B}' )
latex.addNotation( 'hastype',         'A \\text{is} ~ \\text{B}' )

latex.addNotation( 'numefa',          '\\mathcal{A} (B)' )
latex.addNotation( 'propefa',         '\\mathcal{A} (B)' )
latex.addNotation( 'setefa',          '\\mathcal{A} (B)' )

latex.addNotation( 'givenvariant1',   '\\text{Assume }X', { variables : [ 'X' ] } )
latex.addNotation( 'givenvariant1',   '\\text{Assume}~X', { variables : [ 'X' ] } )
latex.addNotation( 'givenvariant2',   '\\text{assume }X', { variables : [ 'X' ] } )
latex.addNotation( 'givenvariant2',   '\\text{assume}~X', { variables : [ 'X' ] } )
latex.addNotation( 'givenvariant3',   '\\text{Given }X', { variables : [ 'X' ] } )
latex.addNotation( 'givenvariant3',   '\\text{Given}~X', { variables : [ 'X' ] } )
latex.addNotation( 'givenvariant4',   '\\text{given }X', { variables : [ 'X' ] } )
latex.addNotation( 'givenvariant4',   '\\text{given}~X', { variables : [ 'X' ] } )

latex.addNotation( 'letvariant1',     '\\text{Let }A' )
latex.addNotation( 'letvariant2',     '\\text{let }A' )
latex.addNotation( 'letbevariant1',   '\\text{Let }A \\text{ be such that }B' )
latex.addNotation( 'letbevariant2',   '\\text{let }A \\text{ be such that }B' )
latex.addNotation( 'forsomevariant1', '\\text{For some }A, B' )
latex.addNotation( 'forsomevariant2', '\\text{for some }A, B' )
latex.addNotation( 'forsomevariant3', 'B \\text{ for some } A' )
latex.addNotation( 'forsomevariant4', 'B~\\text{for some}~A' )
